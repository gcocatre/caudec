#!/bin/bash

# Copyright © 2012 - 2025 Guillaume Cocatre-Zilgien <guillaume@cocatre.net>
# https://github.com/gcocatre/caudec
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Global variables =============================================================

declare -r Self_Name='caudec'
declare -r Self_Called_As="${0##*/}"
declare -r Self_Version='2.3.0'

# Ex_Usage: The command was used incorrectly, e.g., with the wrong number of arguments, a bad flag, a bad syntax in a parameter, or whatever.
# Ex_Data_Err: The input data was incorrect in some way. This should only be used for user's data & not system files.
# Ex_No_Input: An input file (not a system file) did not exist or was not readable. This could also include errors like "No message" to a mailer (if it cared to catch it).
# Ex_No_User: The user specified did not exist. This might be used for mail addresses or remote logins.
# Ex_No_Host: The host specified did not exist. This is used in mail addresses or network requests.
# Ex_Unavailable: A service is unavailable. This can occur if a support program or file does not exist. This can also be used as a catchall message when something you wanted to do doesn't work, but you don't know why.
# Ex_Software: An internal software error has been detected. This should be limited to non-operating system related errors as possible.
# Ex_Os_Err: An operating system error has been detected. This is intended to be used for such things as "cannot fork", "cannot create pipe", or the like. It includes things like getuid returning a user that does not exist in the passwd file.
# Ex_Os_File: Some system file (e.g., /etc/passwd, /etc/utmp, etc.) does not exist, cannot be opened, or has some sort of error (e.g., syntax error).
# Ex_Cant_Create: A (user specified) output file cannot be created.
# Ex_Io_Err: An error occurred while doing I/O on some file.
# Ex_Temp_Fail: temporary failure, indicating something that is not really an error. In sendmail, this means that a mailer (e.g.) could not create a connection, and the request should be reattempted later.
# Ex_Protocol: the remote system returned something that was "not possible" during a protocol exchange.
# Ex_No_Perm: You did not have sufficient permission to perform the operation. This is not intended for file system problems, which should use NOINPUT or CANTCREAT, but rather for higher level permissions.

declare -r Ex_Ok=0            # successful termination
declare -r Ex_Ko=1            # unsuccessful termination
declare -r Ex_Usage=64        # command line usage error
declare -r Ex_Data_Err=65     # data format error
declare -r Ex_No_Input=66     # cannot open input
declare -r Ex_No_User=67      # addressee unknown
declare -r Ex_No_Host=68      # host name unknown
declare -r Ex_Unavailable=69  # service unavailable
declare -r Ex_Software=70     # internal software error
declare -r Ex_Os_Err=71       # system error (e.g., can't fork)
declare -r Ex_Os_File=72      # critical OS file missing
declare -r Ex_Cant_Create=73	# can't create (user) output file
declare -r Ex_Io_Err=74       # input/output error
declare -r Ex_Temp_Fail=75    # temp failure; user is invited to retry
declare -r Ex_Protocol=76     # remote error in protocol
declare -r Ex_No_Perm=77      # permission denied
declare -r Ex_Config_Err=78   # configuration error
declare -r Ex_Interrupt=143   # user interruption (Ctrl+C)

# https://dev.to/ifenna__/adding-colors-to-bash-scripts-48g4

# Clr_El="\\033[2K\\033[0G" # FIXME: can't remember what that does
Clr_Ok="\\033[1;32m" # bright green
Clr_Ko="\\033[1;31m" # bright red
Clr_Wg="\\033[1;33m" # bright yellow

Clr_Rst="\\033[0m" # reset (normal color)

Clr_N_Bk="\\033[0;30m" # black
Clr_B_Bk="\\033[1;30m" # dark gray
Clr_N_Rd="\\033[0;31m" # dark red
Clr_B_Rd="\\033[1;31m" # bright red
Clr_N_Gr="\\033[0;32m" # dark green
Clr_B_Gr="\\033[1;32m" # bright green
Clr_N_Yl="\\033[0;33m" # brown
Clr_B_Yl="\\033[1;33m" # yellow
Clr_N_Bl="\\033[0;34m" # dark blue
Clr_B_Bl="\\033[1;34m" # bright blue
Clr_N_Pp="\\033[0;35m" # dark purple
Clr_B_Pp="\\033[1;35m" # bright purple
Clr_N_Cy="\\033[0;36m" # dark cyan
Clr_B_Cy="\\033[1;36m" # bright cyan
Clr_N_Wh="\\033[0;37m" # bright gray
Clr_B_Wh="\\033[1;37m" # white

declare -r Self_Pid_Dir="/tmp/${Self_Name}"
declare -r Self_Io_Dir="${Self_Pid_Dir}/io"

declare -r Flac_Max_Threads=128
declare -r WavPack_Max_Threads=12

# User settings ================================================================

if [ -r '/etc/caudecrc' ]; then
	. '/etc/caudecrc'
	test -n "$maxInstances" && rootMaxInstances="$maxInstances"
	test -n "$maxInputFiles" && rootMaxInputFiles="$maxInputFiles"
	test -n "$preloadSources" && rootPreloadSources="$preloadSources"
fi

if [ -r "${HOME}/.caudecrc" ]; then
	. "${HOME}/.caudecrc"
fi

# sanitize caudecrc input

case "$ID3Padding" in
	[0-9]*) true ;; # nothing to do
	*) ID3Padding=512 ;;
esac

# true by default
if [ "$preventClipping" = "false" ]; then preventClipping=false; else preventClipping=true; fi

# false by default
if [ "$computeAudioPeaks" = "true" ]; then computeAudioPeaks=true; else computeAudioPeaks=false; fi
if [ "$ignoreUnsupportedFiles" = "true" ]; then ignoreUnsupportedFiles=true; else ignoreUnsupportedFiles=false; fi
if [ "$keepWavMetadata" = "true" ]; then keepWavMetadata=true; else keepWavMetadata=false; fi
if [ "$setCompilationFlagWithAlbumArtist" = "true" ]; then setCompilationFlagWithAlbumArtist=true; else setCompilationFlagWithAlbumArtist=false; fi
if [ "$tagCompressionSetting" = "true" ]; then tagCompressionSetting=true; else tagCompressionSetting=false; fi

test -z "$hashes" && hashes=''
if [ -n "$hashes" ]; then
	hashes="${hashes// /}"
	hashes="${hashes//,/ } "
fi

test -z "$tagWhitelist" && tagWhitelist=''
if [ -n "$tagWhitelist" ]; then
	tagWhitelist="${tagWhitelist//, /,}"
	tagWhitelist="${tagWhitelist%,}"
fi

test -z "$tagBlacklist" && tagBlacklist=''
if [ -n "$tagBlacklist" ]; then
	tagBlacklist="${tagBlacklist//, /,}"
	tagBlacklist="${tagBlacklist%,}"
fi

if [ -n "$rootMaxInstances" ]; then maxInstances="$rootMaxInstances"; fi
case "$maxInstances" in
	[0-9]*) if [ $maxInstances -lt 1 ]; then maxInstances=1 ; fi ;;
	*) maxInstances=1 ;;
esac

if [ -n "$rootMaxInputFiles" ]; then maxInputFiles="$rootMaxInputFiles"; fi
case "$maxInputFiles" in
	[0-9]*) if [ $maxInputFiles -lt 1 ]; then maxInputFiles=100 ; fi ;;
	*) maxInputFiles=100 ;;
esac

# true by default
if [ -n "$rootPreloadSources" ]; then preloadSources="$rootPreloadSources"; fi
if [ "$preloadSources" = "false" ]; then preloadSources=false; else preloadSources=true; fi

# true by default
if [ "$enableColors" = "false" ]; then
	Clr_Ok="" Clr_Ko="" Clr_Wg="" Clr_Rst="" Clr_N_Bk="" Clr_B_Bk="" Clr_N_Rd="" Clr_B_Rd="" Clr_N_Gr="" Clr_B_Gr=""
	Clr_N_Yl="" Clr_B_Yl="" Clr_N_Bl="" Clr_B_Bl="" Clr_N_Pp="" Clr_B_Pp="" Clr_N_Cy="" Clr_B_Cy="" Clr_N_Wh=""
	Clr_B_Wh=""
fi

# true by default
if [ "$useBrightColors" = "false" ]; then
	useBrightColors=false
	Clr_Ok="$Clr_N_Gr" Clr_Ko="$Clr_N_Rd" Clr_Wg="$Clr_N_Yl" Clr_N_Cy="$Clr_N_Bl"
else
	useBrightColors=true
fi

# Functions ====================================================================

debug () {
	local str="$1"
	echo -e "${Clr_Wg}>>> DEBUG:${Clr_Rst} $str" 1>&2
}

printUsage () {
	if [ "$Self_Called_As" = 'decaude' ]; then
		echo "caudec ${Self_Version}: multiprocess audio converter
Copyright © 2012 - 2025 Guillaume Cocatre-Zilgien
https://github.com/gcocatre/caudec

Usage: decaude FILES
Decodes FILES to WAV (same as 'caudec -d' and 'caudec -c wav').
Instead of multiple files, one or more directories may be specified.
See also: caudec -h"
	else
		echo "caudec ${Self_Version}: multiprocess audio converter
Copyright © 2012 - 2025 Guillaume Cocatre-Zilgien
https://github.com/gcocatre/caudec

Usage: $Self_Name [ GLOBAL PARAMETERS ] [ PROCESSING [ PARAMETERS ] ] FILES
Operate on multiple audio files at once, in parallel.
Instead of multiple files, one or more directories may be specified.
Multiple codec switches (optionally paired with a -q switch) may be specified.
Supported input files: .wav, .aiff, .caf, .flac, .wv, .ape, .m4a

-------------------------------------------------------------------------------

Global parameters:

  -n N      launch N processes concurrently (1-${maxProcesses});
            by default, the number of CPU cores.

  -i        ignore unsupported files

  -s        be silent, only print errors

  -z        produce machine-parsable output; must be the first parameter on the
            command line to take effect. Run 'caudec -z' on its own to print
            a description of the syntax.

  -Z        produce human-readable output to STDOUT, and machine-parsable
            output to STDERR

-------------------------------------------------------------------------------

Applying gain after decoding and before encoding, with an upper limit of 0dBFS:

  -G ARG    apply ReplayGain ('album' or 'track') if found in source file
            metadata. Note: it is possible to specify a preamp value with an
            additional -G GAIN parameter (see below), for instance
            '-G album -G -3' or '-G track -G +2'.

  -G ARG    apply peak normalization ('albumpeak' or 'trackpeak'); same as
            above, except album or track peak values are used as a starting
            point instead of album or track gain values. An additional preamp
            value may be specified as well (see -G GAIN below).

  -G GAIN   apply arbitrary GAIN (signed number from -99.99 to +99.99)

-------------------------------------------------------------------------------

Resampling after decoding and before encoding:

  -b BITS   bit depth (16, 24)
  -r HZ     sampling rate in Hz (44100, 48000, 88200, 96000, 176400, 192000,
            352800, 384000)
  -r KHZ    sampling rate in kHz (44[.1], 48, 88[.2], 96, 176[.4], 192, 352[.8],
            384)
  -r cd     equivalent to -b 16 -r 44100 -2 (includes conversion to stereo)
  -r dvd    equivalent to -b 16 -r 48000
  -r sacd   equivalent to -b 24 -r 88200
  -r dvda   equivalent to -b 24 -r 96000
  -r bluray equivalent to -b 24 -r 96000
  -r pono   equivalent to -b 24 -r 192000
  -r dxd    equivalent to -b 24 -r 352800
  -2        convert to stereo: 2.1, 4.0, 5.0, 5.1 and 7.1 audio will be
            downmixed, using proper channel mappings; mono audio will be
            upmixed to dual-mono (stereo with two identical channels)

-------------------------------------------------------------------------------

Encoding parameters (mutually exclusive from all other actions):

  -c CODEC  use specified CODEC: wav, aiff, caf,
            flac, wv (WavPack), wvh (WavPack Hybrid), wvl (WavPack lossy),
            lossyWAV, lossyFLAC, lossyWV, ape (Monkey's Audio), alac (m4a),
            aac (m4a), mp3, ogg / vorbis, opus.

  -C CODEC  use specified CODEC, but discard existing metadata

  -q ARG    set compression level (variable bitrate mode; try -q help for
            a list of valid values)

  -b ARG    constant or target bitrate in bits per sample (for -c wvh/wvl)
            or in kilobits per second (for all lossy codecs)
  -B ARG    average bitrate in kilobits per second (for all lossy codecs)

  -o DIR    set existing output directory
  -O DIR    set output directory, create it if it doesn't exist already
  -P DIR    set and create output directory, and mirror the source file's
            path components (e.g. 'a/b/file.flac' => 'DIR/a/b/file.ogg')

  -l DIR    set existing directory for hard linking lossy .wv files from
            WavPackHybrid's output directory
  -L DIR    set and create a directory for hard linking lossy .wv files from
            WavPackHybrid's output directory

  -a FILE   embed cover art FILE into supported files. Specify -a first
            to embed the same file for all supported codecs specified by -c,
            or specify -a after -c to embed cover art only for that codec,
            if supported. FILE must be a filename and that file must be
            located in the source directory.

  -f ARG    copy certain files to the output directory. ARG may be a 'all',
            a comma separated list of files, and / or file extensions preceded
            by a dot. If ARG is a list of files, they must be filenames and
            those files must be located in the source directory.

  -k        keep existing destination files (don't overwrite them)
  -K        keep existing destination files if they're newer than their source


When transcoding to multiple codecs at once (multiple -c parameters),
specify a -o/O/P parameter after each -c parameter in order to set per-codec
output directories. For instance:
\$ caudec -c flac -P ~/Music/FLAC -c mp3 -P ~/Music/MP3 \"Artist/Album\"/*.flac


Similarly, specifying -a/-f after a -c parameter will affect only that codec.
For instance:
\$ caudec -c flac -P ~/Music/FLAC -f cover.jpg \\
  -c mp3 -P ~/Music/MP3 -f folder.jpg \"Artist/Album\"/*.flac


Creating a WavPack Hybrid collection with a different root directory for lossy:
\$ caudec -c wvh -P ~/Music/Lossless -L ~/Music/Lossy \"Artist/Album\"/*.flac
That will create a mirrored directory structure with hard linked lossy files.
~/Music/Lossless will contain the full lossless collection, which can be safely
backed up and ~/Music/Lossy will contain only the lossy part of the collection.
Little to no extra storage will be used (just extra inodes).

-------------------------------------------------------------------------------

Decoding parameters (all mutually exlusive from each other and other actions):

  -d        decode to WAV (input: AIFF, CAF, FLAC, WavPack, Monkey's Audio)
  -t        test file integrity
  -H HASH   compute hash of raw PCM (CRC32, MD5, SHA1, SHA256 or SHA512,
            FLAC, WavPack, Monkey's Audio and lossyFLAC, lossyWV only)
  -H ^HASH  do NOT compute HASH even if it's in caudecrc

-------------------------------------------------------------------------------

ReplayGain parameters (mutually exclusive from all other actions):

  -g        generate ReplayGain metadata

  -G ARG    MP3: apply ReplayGain ('album' or 'track') using MP3's gain header.
            It is the standard way for MP3 and is reversible.

  -G undo   MP3: reverse ReplayGain using MP3's gain header.
            Other codecs: remove ReplayGain metadata.

-------------------------------------------------------------------------------

Touching file times (mutually exclusive from all other actions):

  -T        touch files using metadata to reflect the music's release date
            and duration. Provide all files as arguments, not just audio files,
            although at least one audio file is required for this to work.
            Use with -l when dealing with a hard linked collection (-c wvh).
            Ex: $Self_Name -T ~/Music/Lossless/Artist/Album/*
            Ex: $Self_Name -T ~/Music/Lossless/Artist/Album/* -l ~/Music/Lossy

-------------------------------------------------------------------------------

Information:

  -h        display this help and exit
  -V        output version information and exit

-------------------------------------------------------------------------------

caudec uses a temporary directory for processing files (\$TMPDIR or /tmp by
default). If you wish to use another directory, set the CAUDECDIR environment
variable to its path (export CAUDECDIR=\"/some/dir\"), or set CAUDECDIR in your
configuration file (~/.caudecrc or /etc/caudecrc).

To enable debugging, set the CAUDECDEBUG environment variable to 'true'
(export CAUDECDEBUG='true'). caudec will output some additional information,
as well as a log of errors that occurred while using external tools.

For more help, see the online documentation:
https://github.com/gcocatre/caudec"
	fi
}

printMachineSyntax () {
	echo "-------------------------------------------------------------------------------
         Format specification of caudec's machine-parsable output (-z)
-------------------------------------------------------------------------------

Fields are separated with pipes ('|', Unicode: U+007C); pipe characters present
in filenames or messages are replaced with the visually similar 'broken bar'
sign ('¦', Unicode: U+00A6).

status|status_info|status_data|file|message|process_id

status: one of info, success, error, warning, abort.

status_info: optional additional information about the status (usage,
    initialization, decoding, processing, encoding, testing, hashing, debugging,
    track_gain, album_gain, checking_version, aborting, hash_type,
    bitrate_codecName, processing_rate, touch_file, touch_files).

status_data: optional data about the status (hash type, hash value, hash error,
    gain value in dB, bitrate in bits per second, processing rate, version
    status). Some status_data keywords:
    * filesystem (filesystem related error or information),
    * server (server related error or information),
    * command_line (command line related error or information),
    * bad_value (user provided a parameter with a bad argument),
    * quota (some limit has been reached),
    * internal (internal software error / warning),
    * no_hash (no hash metadata found),
    * no_hash_tool (no hashing tools available),
    * bad_internal_hash (internal MD5 hash is incorrect),
    * user_agent (user agent sent to caudec's server),
    * up_to_date (caudec is up to date),
    * new_version_available (there's a new version of caudec available),
    * running_newer_version (local copy of caudec is newer than the latest
      available online)

file: path of the file that is affected by the status (if applicable).

message: optional human-readable information about the status.

process_id: identifier (PID) of the caudec process."
}

# status;status_info;status_data;file;message;process_number
getMachineParsableString () {
	local pid=''

	if [ -n "$BASHPID" ]; then
		pid="$BASHPID"
	elif [ -n "$$" ]; then
		pid="$$"
	fi

	# replace pipes ('|', Unicode: U+007C) with 'broken bar' signs ('¦', Unicode: U+00A6)
	file="${file//|/¦}"
	msg="${msg//|/¦}"

	case "$msgType" in
		abort) str="$( printf "%s|%s|%s|%s|%s|%s\n" 'info' 'aborting' '' '' 'Aborting.' '' )" ;;

		info)
			if [ -n "$bitrate" ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" 'info' "bitrate_${codec}" "$bitrate" '' "$msg" "$pid" )"
			elif [ -n "$rate" ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" 'info' 'processing_rate' "$rate" '' "$msg" "$pid" )"
			elif [ -n "$hashType" ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" 'info' "$hashType" "$statusData" "$file" '' "$pid" )"
			else
				str="$( printf "%s|%s|%s|%s|%s|%s\n" 'info' "$statusInfo" "$statusData" '' "$msg" "$pid" )"
			fi
			;;

		success)
			if [ "$statusInfo" = 'track_gain' ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$gain" "$file" '' "$pid" )"
			elif [ "$statusInfo" = 'album_gain' ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$gain" "$file" "$msg" "$pid" )"
			elif [ "$statusInfo" = 'touch_file' ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$dateTime" "$file" "$msg" "$pid" )"
			elif [ "$statusInfo" = 'touch_files' ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$albumTime" "$path" "$msg" "$pid" )"
			elif [ "$statusInfo" = 'testing' ]; then
				if [ -n "$hashError" ]; then
					str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$hashError" "$file" '' "$pid" )"
				else
					str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$hashType" "$file" '' "$pid" )"
				fi
			else
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$statusData" "$file" "$msg" "$pid" )"
			fi
			;;

		error)
			if [ "$statusInfo" = 'testing' ]; then
				if [ -n "$hashError" ]; then
					str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$hashError" "$file" '' "$pid" )"
				else
					str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$hashType" "$file" '' "$pid" )"
				fi
			elif [ "$statusInfo" = 'album_gain' ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" '' '' "$msg" "$pid" )"
			else
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$statusData" "$file" "$msg" "$pid" )"
			fi
			;;

		warning)
			if [ "$statusInfo" = 'testing' ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$hashError" "$file" "$msg" "$pid" )"
			elif [ -n "$hashError" ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$hashError" "$file" "$msg" "$pid" )"
			else
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$statusData" "$file" "$msg" "$pid" )"
			fi
			;;
	esac

	if [ -n "$str" ]; then
		echo -e "$str"
	fi
}

getHumanReadableString () {
	case "$msgType" in
		info)
			if [ -n "$msg" ]; then
				str="$( printf "${Clr_B_Bk} * ${Clr_Rst}%s\n" "$msg" )"
			fi ;;

		abort) str="$( printf "${Clr_Wg} * ${Clr_Rst}%s\n" 'Aborting.' )" ;;

		success)
			if [ "$statusInfo" = 'track_gain' ]; then
				str="$( printf "${Clr_B_Bk}%2u ${Clr_Ok}OK ${Clr_Rst}%9s ${Clr_N_Cy}%s${Clr_Rst}\n" $p "$gain dB" "$fileName" )"
			elif [ "$statusInfo" = 'album_gain' ]; then
				str="$( printf "${Clr_B_Bk} * ${Clr_Ok}OK ${Clr_Rst}%9s ${Clr_Rst}%s\n" "$gain dB" 'Album gain' )"
			elif [ "$statusInfo" = 'touch_file' ]; then
				str="$( printf "${Clr_B_Bk}%2u ${Clr_Ok}OK ${Clr_Rst}%s ${Clr_N_Cy}%s${Clr_Rst}\n" $p "$dateTime" "$fileName" )"
			elif [ "$statusInfo" = 'touch_files' ]; then
				str="$( printf "${Clr_B_Bk} * ${Clr_Ok}OK ${Clr_Rst}%10s ${Clr_Rst}%s\n" "$albumTime" "Album length" )"
			elif [ "$statusInfo" = 'testing' ]; then
				if [ -n "$numberOfThreads" ]; then
					if [ $numberOfThreads -lt 2 ]; then
						str="$( printf "${Clr_B_Bk}%2u ${Clr_B_Bk}%2ux ${Clr_Ok}OK ${Clr_Rst}%s ${Clr_N_Cy}%s${Clr_Rst}\n" $p "$numberOfThreads" "$hashType" "$fileName" )"
					elif [ $numberOfThreads -ge 2 -a $numberOfThreads -lt 4 ]; then
						str="$( printf "${Clr_B_Bk}%2u ${Clr_N_Gr}%2ux ${Clr_Ok}OK ${Clr_Rst}%s ${Clr_N_Cy}%s${Clr_Rst}\n" $p "$numberOfThreads" "$hashType" "$fileName" )"
					elif [ $numberOfThreads -ge 4 ]; then
						str="$( printf "${Clr_B_Bk}%2u ${Clr_Ok}%2ux ${Clr_Ok}OK ${Clr_Rst}%s ${Clr_N_Cy}%s${Clr_Rst}\n" $p "$numberOfThreads" "$hashType" "$fileName" )"
					fi
				else
					str="$( printf "${Clr_B_Bk}%2u ${Clr_Ok}OK ${Clr_Rst}%s ${Clr_N_Cy}%s${Clr_Rst}\n" $p "$hashType" "$fileName" )"
				fi
			elif [ -n "$file" ]; then # transcoding or hashing
				if [ -n "$p" ]; then
					if [ -n "$numberOfThreads" ]; then
						if [ $numberOfThreads -lt 2 ]; then
							str="$( printf "${Clr_B_Bk}%2u ${Clr_B_Bk}%2ux ${Clr_Ok}OK ${Clr_N_Cy}%s${Clr_Rst}\n" $p "$numberOfThreads" "$fileName" )"
						elif [ $numberOfThreads -ge 2 -a $numberOfThreads -lt 4 ]; then
							str="$( printf "${Clr_B_Bk}%2u ${Clr_N_Gr}%2ux ${Clr_Ok}OK ${Clr_N_Cy}%s${Clr_Rst}\n" $p "$numberOfThreads" "$fileName" )"
						elif [ $numberOfThreads -ge 4 ]; then
							str="$( printf "${Clr_B_Bk}%2u ${Clr_Ok}%2ux ${Clr_Ok}OK ${Clr_N_Cy}%s${Clr_Rst}\n" $p "$numberOfThreads" "$fileName" )"
						fi
					else
						str="$( printf "${Clr_B_Bk}%2u ${Clr_Ok}OK ${Clr_N_Cy}%s${Clr_Rst}\n" $p "$fileName" )"
					fi
				else
					str="$( printf "${Clr_B_Bk} * ${Clr_Ok}OK ${Clr_N_Cy}%s${Clr_Rst}\n" "$fileName" )"
				fi
			elif [ -n "$msg" ]; then
				str="$( printf "${Clr_B_Bk} * ${Clr_Ok}OK${Clr_Rst}: %s\n" "$msg" )"
			fi
			;;

		error)
			if [ "$statusInfo" = 'decoding' ]; then
				str="$( printf "${Clr_B_Bk}%2u ${Clr_Ko}DC ${Clr_N_Cy}%s${Clr_Rst}\n" $p "$fileName" )"
			elif [ "$statusInfo" = 'processing' ]; then
				str="$( printf "${Clr_B_Bk}%2u ${Clr_Ko}PR ${Clr_N_Cy}%s${Clr_Rst}\n" $p "$fileName" )"
			elif [ "$statusInfo" = 'testing' ]; then
				if [ -n "$hashType" ]; then
					str="$( printf "${Clr_B_Bk}%2u ${Clr_Ko}ER ${Clr_Rst}%s ${Clr_N_Cy}%s${Clr_Rst}\n" $p "$hashType" "$fileName" )"
				elif [ -n "$msg" ]; then
					str="$( printf "${Clr_B_Bk}%2u ${Clr_Ko}ER ${Clr_N_Cy}%s${Clr_Rst}: %s\n" $p "$fileName" "$msg" )"
				else
					str="$( printf "${Clr_B_Bk}%2u ${Clr_Ko}ER ${Clr_N_Cy}%s${Clr_Rst}\n" $p "$fileName" )"
				fi
			elif [ -n "$file" ]; then
				if [ -n "$msg" ]; then
					if [ -n "$p" ]; then
						str="$( printf "${Clr_B_Bk}%2u ${Clr_Ko}ER ${Clr_N_Cy}%s${Clr_Rst}: %s\n" $p "$fileName" "$msg" )"
					else
						str="$( printf "${Clr_B_Bk} * ${Clr_Ko}ER ${Clr_N_Cy}%s${Clr_Rst}: %s\n" "$fileName" "$msg" )"
					fi
				else
					if [ -n "$p" ]; then
						str="$( printf "${Clr_B_Bk}%2u ${Clr_Ko}ER ${Clr_N_Cy}%s${Clr_Rst}\n" $p "$fileName" )"
					else
						str="$( printf "${Clr_B_Bk} * ${Clr_Ko}ER ${Clr_N_Cy}%s${Clr_Rst}\n" "$fileName" )"
					fi
				fi
			elif [ -n "$msg" ]; then
				if [ -n "$p" ]; then
					str="$( printf "${Clr_B_Bk}%2u ${Clr_Ko}ER${Clr_Rst}: %s\n" $p "$msg" )"
				else
					str="$( printf "${Clr_B_Bk} * ${Clr_Ko}ER${Clr_Rst}: %s\n" "$msg" )"
				fi
			fi
			;;

		warning)
			if [ -n "$file" ]; then
				if [ -n "$p" ]; then
					if [ -n "$numberOfThreads" ]; then
						str="$( printf "${Clr_B_Bk}%2u ${Clr_B_Bk}%2ux ${Clr_Wg}WG ${Clr_N_Cy}%s${Clr_Rst}: %s\n" $p "$numberOfThreads" "$fileName" "$msg" )"
					else
						str="$( printf "${Clr_B_Bk}%2u ${Clr_Wg}WG ${Clr_N_Cy}%s${Clr_Rst}: %s\n" $p "$fileName" "$msg" )"
					fi
				else
					str="$( printf "${Clr_B_Bk} * ${Clr_Wg}WG ${Clr_N_Cy}%s${Clr_Rst}: %s\n" "$fileName" "$msg" )"
				fi
			else
				if [ -n "$p" ]; then
					str="$( printf "${Clr_B_Bk}%2u ${Clr_Wg}WG${Clr_Rst}: %s\n" $p "$msg" )"
				else
					str="$( printf "${Clr_B_Bk} * ${Clr_Wg}WG${Clr_Rst}: %s\n" "$msg" )"
				fi
			fi
			;;
	esac

	if [ -n "$str" ]; then
		echo -e "$str"
	fi
}

printMessageToStdoutOrStderr () {
	local str="$1" stdOut="$2"

	if [ -n "$str" ]; then
		if [ "$stdOut" = 'stderr' ]; then
			echo -e "$str" 1>&2
		else
			echo -e "$str"
		fi
	fi
}

printMessage () {
	local msgType='info' msgVerbose='default' msgDebug='normal' msgOut='stdout' statusInfo='' statusData=''
	local file='' path='' fileDir='' msg='' p='' numberOfThreads='' hashType='' hashError='' gain='' bitrate='' rate=''
	local codec='' outputCodec='' str=''

	for a in "$@"; do
		case "$a" in
			info) msgType="$a" msgVerbose='verbose' ;;
			success) msgType="$a" msgVerbose='verbose' ;;
			warning|error|abort) msgType="$a" msgOut='stderr' ;;
			verbose) msgVerbose='verbose' ;;
			debug) msgDebug='debug' statusInfo='debugging' ;;
			stderr) msgOut='stderr' ;;
			initialization|usage|encoding|processing|decoding|hashing|testing|album_gain|track_gain|touch_file|touch_files|checking_version) statusInfo="$a" ;;
			unsupported|quota|bad_value|filesystem|command_line|internal|user_agent) statusData="$a" ;;
			server|up_to_date|new_version_available|running_newer_version) statusData="$a" ;;
			file:*) file="${a#file:}"; fileDir="$( dirname "$file" )"; fileName="$( basename "$file" )" ;;
			path:*) path="${a#path:}" ;;
			outputCodec:*) statusData="${a#outputCodec:}" ;;
			+*dB|-*dB) gain="${a% dB}" ;;
			*bps) bitrate="${a%bps}" ;;
			*x) rate="${a%x}" ;;
			bitrate_*) codec="${a#bitrate_}" ;;
			[0-9]*) p="$a" ;;
			threads:[0-9]*) numberOfThreads="${a#threads:}" ;;
			dateTime:[0-9]*) dateTime="${a#dateTime:}" ;;
			albumTime:[0-9:]*) albumTime="${a#albumTime:}" ;;

			CRC32|MD5|SHA1|SHA256|SHA512) hashType="$a" ;;
			no_hash|no_hash_tool|bad_internal_hash) hashError="$a" ;;

			CRC32=*) statusData="${a#CRC32=}" ;;
			MD5=*) statusData="${a#MD5=}" ;;
			SHA1=*) statusData="${a#SHA1=}" ;;
			SHA256=*) statusData="${a#SHA256=}" ;;
			SHA512=*) statusData="${a#SHA512=}" ;;

			*) msg="$a" ;;
		esac
	done

	if [ "$msgVerbose" = 'verbose' -a "$verbose" != 'true' ]; then return $Ex_Ok; fi
	if [ "$msgDebug" = 'debug' -a -z "$CAUDECDEBUG" ]; then return $Ex_Ok; fi

	case "$outputMode" in
		human) printMessageToStdoutOrStderr "$( getHumanReadableString )" "$msgOut" ;;
		machine) printMessageToStdoutOrStderr "$( getMachineParsableString )" "$msgOut" ;;
		humanAndMachine)
			printMessageToStdoutOrStderr "$( getHumanReadableString )" 'stdout'
			printMessageToStdoutOrStderr "$( getMachineParsableString )" 'stderr'
			;;
	esac

	return $Ex_Ok
}

getCompressionSetting () {
	local codec="$1" value="$2" source="$3" errormsg

	if [ -n "$source" ]; then
		errormsg="Configuration error (caudecrc):"
	else
		errormsg="$Self_Name -q:"
	fi

	case "$codec" in
		AAC)
			if [ -z "$value" ]; then value=1; fi
			case "$value" in
				[0-9]|1[0-4]) compression_AAC="$value" ;; # ffmpeg aac_at
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg compression level for $codec must be an integer between 0 and 14" ; exit $Ex_Usage ;;
			esac
			;;

		FLAC)
			if [ -z "$value" ]; then value=5; fi
			case "$value" in
				[0-8]) compression_FLAC="$value" ;;
				f|fast) compression_FLAC=0 ;;
				b|best) compression_FLAC=8 ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg compression level for $codec must be an integer between 0 and 8, or one of fast or best" ; exit $Ex_Usage ;;
			esac
			;;

		lossyWAV|lossyFLAC|lossyWV)
			if [ -z "$value" ]; then value="S"; fi
			case "$value" in
				x|p|c|s|h|e|i) compression_lossyWAV="$( echo "$value" | tr '[:lower:]' '[:upper:]' )" ;;
				X|P|C|S|H|E|I) compression_lossyWAV="$value" ;;
				extraportable) compression_lossyWAV='X' ;;
				portable) compression_lossyWAV='P' ;;
				economic) compression_lossyWAV='C' ;;
				standard) compression_lossyWAV='S' ;;
				high) compression_lossyWAV='H' ;;
				extreme) compression_lossyWAV='E' ;;
				insane) compression_lossyWAV='I' ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg compression level for $codec must be one of X, P, C, S, H, E, I, or one of extraportable, portable, economic, standard, high, extreme or insane" ; exit $Ex_Usage ;;
			esac
			;;

		MonkeysAudio)
			if [ -z "$value" ]; then value="2"; fi
			case "$value" in
				[1-5]) compression_MonkeysAudio="$value" ;;
				fast) compression_MonkeysAudio=1 ;;
				normal) compression_MonkeysAudio=2 ;;
				high) compression_MonkeysAudio=3 ;;
				extra*) compression_MonkeysAudio=4 ;;
				insane) compression_MonkeysAudio=5 ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg compression level for $codec must be a number between 1 and 5, or one of fast, normal, high, extra, insane" ; exit $Ex_Usage ;;
			esac
			;;

		MP3)
			if [ -z "$value" ]; then value="3"; fi
			case "$value" in
				[0-9]) compression_MP3="$value" ;;
				medium) compression_MP3=4 ;;
				standard) compression_MP3=2 ;;
				extreme) compression_MP3=0 ;;
				insane|320) compression_MP3=320 ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg compression level for $codec must be an integer between 0 and 9 or one of medium, standard, extreme, insane or 320" ; exit $Ex_Usage ;;
			esac
			;;

		OggVorbis)
			if [ -z "$value" ]; then value="3"; fi
			case "$value" in
				[0-9]|10) compression_OggVorbis="$value" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg compression level for $codec must be an integer between 0 and 10" ; exit $Ex_Usage ;;
			esac
			;;

		WavPack|WavPackHybrid|WavPackLossy)
			if [ -z "$value" ]; then value="gx1"; fi
			case "$value" in
				x|x[1-6]|g|gx|gx[1-6]|f|fx|fx[1-6]|h|hx|hx[1-6]|hh|hhx|hhx[1-6]) compression_WavPack="$value" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg compression level for $codec must be a combination of [f|g|h|hh][x[1-6]]" ; exit $Ex_Usage ;;
			esac
			;;
	esac
}

getConstantBitrate () {
	local codec="$1" bitrate="$2" source="$3" errormsg

	if [ -n "$source" ]; then
		errormsg="Configuration error (caudecrc):"
	else
		errormsg="$Self_Name -b:"
	fi

	case "$codec" in
		AAC)
			if [ -z "$bitrate" ]; then bitrate=128; fi # ffmpeg default
			case "$bitrate" in
				[0-9]|[1-9][0-9]|[1-2][0-9][0-9]|3[0-1][0-9]|320) bitrate_AAC="$bitrate" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg average bitrate for $codec must be an integer between 0 and 320 in kilobits per second" ; exit $Ex_Usage ;;
			esac
			;;

		MP3)
			if [ -z "$bitrate" ]; then bitrate=128; fi # LAME default
			case "$bitrate" in
				1[6-9]|[2-9][0-9]|[1-2][0-9][0-9]|3[0-1][0-9]|320) bitrate_MP3="$bitrate" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg constant bitrate for $codec must be an integer between 16 and 320 in kilobits per second" ; exit $Ex_Usage ;;
			esac
			;;

		OggVorbis)
			if [ -z "$bitrate" ]; then bitrate=96; fi # oggenc default
			case "$bitrate" in
				3[2-9]|[4-9][0-9]|[1-4][0-9][0-9]|500) bitrate_OggVorbis="$bitrate" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg target bitrate for $codec must be an integer between 32 and 500 in kilobits per second" ; exit $Ex_Usage ;;
			esac
			;;

		Opus)
			if [ -z "$bitrate" ]; then bitrate=96; fi # opusenc default
			case "$bitrate" in
				[6-9]|[1-9][0-9]|[1-2][0-9][0-9]|3[0-1][0-9]|320) bitrate_Opus="$bitrate" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg target bitrate for $codec must be an integer between 6 and 320 in kilobits per second" ; exit $Ex_Usage ;;
			esac
			;;

		WavPackHybrid|WavPackLossy) getAverageBitrate "$codec" "$bitrate" "$source" ;; # for backwards compatibility
	esac
}

getAverageBitrate () {
	local codec="$1" bitrate="$2" source="$3" errormsg

	if [ -n "$source" ]; then
		errormsg="Configuration error (caudecrc):"
	else
		errormsg="$Self_Name -B:"
	fi

	case "$codec" in
		AAC)
			if [ -z "$bitrate" ]; then bitrate=128; fi # ffmpeg default
			case "$bitrate" in
				[0-9]|[1-9][0-9]|[1-2][0-9][0-9]|3[0-1][0-9]|320) average_bitrate_AAC="$bitrate" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg average bitrate for $codec must be an integer between 0 and 320 in kilobits per second" ; exit $Ex_Usage ;;
			esac
			;;

		MP3)
			if [ -z "$bitrate" ]; then bitrate=128; fi # LAME default
			case "$bitrate" in
				[8-9]|[1-9][0-9]|[1-2][0-9][0-9]|30[0-9]|310) average_bitrate_MP3="$bitrate" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg average bitrate for $codec must be an integer between 8 and 310 in kilobits per second" ; exit $Ex_Usage ;;
			esac
			;;

		OggVorbis)
			if [ -z "$bitrate" ]; then bitrate=96; fi # oggenc default
			case "$bitrate" in
				3[2-9]|[4-9][0-9]|[1-4][0-9][0-9]|500) average_bitrate_OggVorbis="$bitrate" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg average bitrate for $codec must be an integer between 32 and 500 in kilobits per second" ; exit $Ex_Usage ;;
			esac
			;;

		Opus)
			if [ -z "$bitrate" ]; then bitrate=96; fi # opusenc default
			case "$bitrate" in
				[6-9]|[1-9][0-9]|[1-2][0-9][0-9]|3[0-1][0-9]|320) average_bitrate_Opus="$bitrate" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg average bitrate for $codec must be an integer between 6 and 320 in kilobits per second" ; exit $Ex_Usage ;;
			esac
			;;

		WavPackHybrid|WavPackLossy)
			if [ -z "$bitrate" ]; then bitrate=256; fi # WavPack default
			case "$bitrate" in
				[2-9]|[2-9].[0-9]|1[0-9]|1[0-9].[0-9]|2[0-3]|2[0-3].[0-9]) average_bitrate_WavPackLossy="$bitrate" ;;
				2[4-9]|[2-9][0-9]|[1-9][0-9][0-9]|[1-8][0-9][0-9][0-9]|9[0-5][0-9][0-9]|9600) average_bitrate_WavPackLossy="$bitrate" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg target bitrate for $codecodec must be a float between 2.0 and 23.9 in bits per sample, or an integer between 24 and 9600 in kilobits per second" ; exit $Ex_Usage ;;
			esac
			;;
	esac
}

getBitrateMode () {
	local codec="$1" mode="$2"

	case "$mode" in
		cbr|abr|vbr) mode="$( echo "$mode" | tr '[:lower:]' '[:upper:]' )" ;;
		CBR|ABR|VBR) true ;;
		'') mode='VBR' ;;
		*) printMessage 'error' 'usage' 'bad_value' "Configuration error (caudecrc): bitrate mode for $codec must be one of VBR, ABR or CBR" ; exit $Ex_Usage ;;
	esac

	case "$codec" in
		AAC)
			if [ "$mode" != "CBR" -a "$mode" != "ABR" ]; then
				printMessage 'error' 'usage' 'bad_value' "Configuration error (caudecrc): bitrate mode for $codec must be one of ABR or CBR"
				exit $Ex_Usage
			else
				AAC_MODE="$mode"
			fi
			;;
		MP3) MP3_MODE="$mode" ;;
		OggVorbis) OggVorbis_MODE="$mode" ;;
		Opus) Opus_MODE="$mode" ;;
	esac
}

cleanExit () {
	local nLines=0 swapDirBasename

	if [ -n "$CAUDECDEBUG" -a "$verbose" = "true" -a "$outputMode" != 'machine' -a $1 -ne $Ex_Ok -a $1 -ne $Ex_Interrupt -a -e "$errorLogFile" ]; then
		nLines="$( cat "$errorLogFile" 2>/dev/null | wc -l | tr -cd '0-9' )"
		if [ $nLines -gt 0 ]; then
			echo -e "\nError Log:\n================================================================================" 1>&2
			cat "$errorLogFile" 1>&2
		fi
	fi

	if [ -n "$SWAPDIR" ]; then
		rm -rf "$SWAPDIR"
		swapDirBasename="$( basename "$SWAPDIR" )"
		rm "${Self_Pid_Dir}"/"${swapDirBasename}"
	fi
	test -n "$TDIR" && rm -rf "$TDIR"

	for f in "$instanceDir"/ioLockFiles/* ; do
		if [ -e "$f" ]; then
			echo '' > "${Self_Io_Dir}/${f##*/}.lock" 2>/dev/null
			mv "${Self_Io_Dir}/${f##*/}.lock" "${Self_Io_Dir}/${f##*/}" >/dev/null 2>&1
		fi
	done

	rm -rf "$instanceDir"
	cleanUpInstances
	ls -d "${Self_Pid_Dir}"/instance.* >/dev/null 2>&1 || rm -rf "$Self_Io_Dir"

	rm -rf "$Self_Pid_Dir" >/dev/null 2>&1

	exit $1
}

cleanAbort () {
	echo
	printMessage 'abort'
	kill $( jobs -p ) >/dev/null 2>&1
	cleanExit $Ex_Interrupt
}

getInputFiles () {
	local index=0 fileOrDir ec=$Ex_Ok ext line inputDir

	if [ ${#inputFilesAndDirs[@]} -eq 1 -a -d "${inputFilesAndDirs[0]}" ]; then
		inputDir="${inputFilesAndDirs[0]}"
		unset inputFilesAndDirs
		declare -a inputFilesAndDirs=()
		while read line; do
			inputFilesAndDirs[index]="$line"
			index=$(( index + 1 ))
		done < <( find "$inputDir" -type f 2>/dev/null | sort -u 2>/dev/null )
		index=0
	fi

	for fileOrDir in "${inputFilesAndDirs[@]}"; do
		if [ -d "$fileOrDir" ]; then
			if [ -r "$fileOrDir" ]; then
				if [ "$OS" = 'Linux' ]; then
					while IFS= read -d $'\0' -r file ; do
						if [ -f "$file" -a -r "$file" ]; then
							inputFiles[$index]="$file"
							((index++))
						fi
					done < <(find "$fileOrDir" -type f -regex '.*\.\(wav\|aiff\|caf\|flac\|wv\|ape\|mp3\|m4a\|ogg\|opus\)$' -print0 2>/dev/null)
				else
					while IFS= read -d $'\0' -r file ; do
						if [ -f "$file" -a -r "$file" ]; then
							inputFiles[$index]="$file"
							((index++))
						fi
					done < <(find -E "$fileOrDir" -type f -regex '.*\.(wav|aiff|caf|flac|wv|ape|mp3|m4a|ogg|opus)$' -print0 2>/dev/null)
				fi
			else
				printMessage 'warning' 'usage' 'filesystem' "path:${fileOrDir}" 'directory is not readable (permission denied).' ; ec=$Ex_No_Input
			fi
		else
			inputFiles[$index]="$fileOrDir"
			((index++))
		fi
	done

	for fileOrDir in "${inputFiles[@]}"; do
		ext="${fileOrDir##*.}"
		if [ "$ext" != "opus" ]; then
			allFilesAreOpus=false
		fi
	done

	unset inputFilesAndDirs
	if [ $ec -eq $Ex_Ok ]; then
		return $Ex_Ok
	else
		printMessage 'abort' 'verbose'
		cleanExit $ec
	fi
}

checkInputFiles () {
	local inputFile ec=$Ex_Ok inputDirName commonFileExtension="" inputFileExtension="" inputFileExtensionAreAllTheSame=true refDn cdpath pdpath
	local index=0 addToSourceFiles errorMSG gotExistingFiles=false nChannels=0 gotAudioFile=false
	local dateSourceFile dateSourceFile outputCodec copyPath codec

	numberOfInputFiles="${#inputFiles[@]}"
	if [ $numberOfInputFiles -gt $maxInputFiles ]; then
		printMessage 'warning' 'usage' 'quota' "the number of input files ($numberOfInputFiles) is greater than maxInputFiles=${maxInputFiles}."
		printMessage 'abort'
		if [ "$outputMode" != 'machine' ]; then
			echo 1>&2
			echo "If you're processing multiple directories, try running caudec in a loop:
find * -type f -name '*.flac' -exec dirname '{}' ';' | sort -u | while read d;
do echo \"\$d\"; caudec -s -K -P /some/destination/dir -c ogg \"\$d\"/*.flac; done" 1>&2
		fi
		cleanExit $Ex_Usage
	fi

	for inputFile in "${inputFiles[@]}" ; do
		inputFileExtension="${inputFile##*.}"
		if [ -z "$commonFileExtension" ]; then
			commonFileExtension="$inputFileExtension"
		elif [ "$inputFileExtension" != "$commonFileExtension" ]; then
			inputFileExtensionAreAllTheSame=false
		fi
		addToSourceFiles=false
		inputDirName="$( dirname "$inputFile" )"
		if [ ! -e "$inputFile" ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${inputFile}" 'no such file.' ; ec=$Ex_No_Input
		elif [ ! -f "$inputFile" ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${inputFile}" 'not a regular file.' ; ec=$Ex_Data_Err
		elif [ ! -r "$inputFile" ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${inputFile}" 'cannot open file for reading (permission denied).' ; ec=$Ex_No_Input
		elif [ ! -w "$inputFile" -a $computeReplayGain = true ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${inputFile}" 'cannot open file for writing (permission denied).' ; ec=$Ex_Cant_Create
		elif [ ! -w "$inputFile" -a $hashFiles = true ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${inputFile}" 'cannot open file for writing (permission denied).' ; ec=$Ex_Cant_Create
		elif [ ! -w "$inputFile" -a $touchFiles = true ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${inputFile}" 'refusing to touch file that is read-only.' ; ec=$Ex_Cant_Create
		else
			if [ -n "$outputCodecs" ]; then # transcode
				for outputCodec in $outputCodecs; do
					copyPath="$( copyPathOrNot "$outputCodec" )"
					if [ "$copyPath" = "true" ]; then
						cdpath='/./' pdpath='/../'
						if [ "${inputFile:0:2}" = './' -o "${inputFile:0:3}" = '../' -o "$inputDirName" != "${inputDirName//$cdpath/@}" -o "$inputDirName" != "${inputDirName//$pdpath/@}" ]; then
							printMessage 'warning' 'usage' 'filesystem' "path:${inputFile}" "can't use paths containing ./ or ../ with caudec -P." ; ec=$Ex_Usage
							continue
						fi
					fi
				done
			fi

			if [ -n "$outputCodecs" ]; then # transcode
				case "$inputFile" in
					*.wav|*.aiff|*.caf|*.flac|*.wv|*.ape|*.m4a)
						addToSourceFiles=true
						case "$inputFile" in
							*.m4a)
								codec="$( ffprobe -v error -select_streams a:0 -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 "$inputFile" 2>/dev/null )"
								if [ "$codec" = "alac" ]; then
									addToSourceFiles=true
								else
									addToSourceFiles=false
									printMessage 'warning' 'processing' 'unsupported' "file:${inputFile}" "refusing to transcode from lossy codec ($codec)." ; ec=$Ex_Data_Err
								fi
								;;
						esac
						if [ $addToSourceFiles = false ]; then continue ; fi
						if [ $keepExistingFiles = true -o $keepNewerFiles = true ]; then
							getFileProps "$inputFile" "$outputCodec"
						fi
						if [ $keepExistingFiles = true ]; then
							if [ -e "$destFile" ]; then
								addToSourceFiles=false
								printMessage 'warning' 'usage' 'filesystem' 'verbose' "-k: \"$destFile\" exists already."
							fi
						fi
						if [ $keepNewerFiles = true ]; then
							if [ -e "$destFile" ]; then
								if isFileNewer "$destFile" "$sourceFile"; then
									addToSourceFiles=false
									if [ $gnudate = true ]; then
										dateSourceFile="$( $datecmd --date="@"$( $statcmd -c '%Y' "$sourceFile" )"" "+%Y-%m-%d %H:%M:%S" )"
										dateDestFile="$( $datecmd --date="@"$( $statcmd -c '%Y' "$destFile" )"" "+%Y-%m-%d %H:%M:%S" )"
									else
										dateSourceFile="$( $datecmd -r $( $statcmd -f '%c' "$sourceFile" ) "+%Y-%m-%d %H:%M:%S" )"
										dateDestFile="$( $datecmd -r $( $statcmd -f '%c' "$destFile" ) "+%Y-%m-%d %H:%M:%S" )"
									fi
									printMessage 'warning' 'usage' 'filesystem' 'verbose' "-K: '$dateDestFile' vs. '$dateSourceFile': \"$destFile\" is newer that the source."
								fi
							else
								addToSourceFiles=true
							fi
						fi
						;;

					*)
						if [ $ignoreUnsupportedFiles = false ]; then
							printMessage 'warning' 'processing' 'unsupported' "file:${inputFile}" 'unsupported format.'
							ec=$Ex_Data_Err
							continue
						fi
						;;
				esac

			else # actions other than transcoding
				if [ $checkFiles = true -o $hashFiles = true ]; then
					case "$inputFile" in
						*.flac|*.wv|*.ape) addToSourceFiles=true ;;
						*)
							if [ $ignoreUnsupportedFiles = true ]; then
								continue
							else
								printMessage 'warning' 'processing' 'unsupported' "file:${inputFile}" 'unsupported format.' ; ec=$Ex_Data_Err ; continue
							fi
							;;
					esac
				fi

				if [ $computeReplayGain = true ]; then
					if [ $inputFileExtensionAreAllTheSame = false ]; then
						printMessage 'error' 'usage' 'filesystem' "file:${inputFile}" "all files must have the same file extension" ; ec=$Ex_Data_Err
					else
						case "$inputFile" in
							*.flac|*.wv|*.ogg|*.opus|*.mp3)
								nChannels="$( getNumberOfChannels "$inputFile" )"
								if [ $nChannels -le 2 ]; then
									addToSourceFiles=true
								else
									if [ $ignoreUnsupportedFiles = true ]; then
										continue
									else
										printMessage 'warning' 'processing' 'unsupported' "file:${inputFile}" 'unsupported format (neither mono or stereo).' ; ec=$Ex_Data_Err ; continue
									fi
								fi
								;;

							*)
								if [ $ignoreUnsupportedFiles = true ]; then
									continue
								else
									printMessage 'warning' 'processing' 'unsupported' "file:${inputFile}" 'unsupported format.' ; ec=$Ex_Data_Err ; continue
								fi
								;;
						esac
					fi
				fi

				if [ $reverseReplayGain = true ]; then
					if [ $inputFileExtensionAreAllTheSame = false ]; then
						printMessage 'error' 'usage' 'filesystem' "file:${inputFile}" "all files must have the same file extension" ; ec=$Ex_Data_Err
					else
						case "$inputFile" in
							*.flac|*.wv|*.ape|*.ogg|*.opus|*.mp3) addToSourceFiles=true ;;
							*)
								if [ $ignoreUnsupportedFiles = true ]; then
									continue
								else
									printMessage 'warning' 'processing' 'unsupported' "file:${inputFile}" 'unsupported format.' ; ec=$Ex_Data_Err ; continue
								fi
								;;
						esac
					fi
				fi

				if [ $applyGain = true ]; then
					case "$inputFile" in
						*.mp3) addToSourceFiles=true ;;
						*)
							if [ $ignoreUnsupportedFiles = true ]; then
								continue
							else
								printMessage 'warning' 'processing' 'unsupported' "file:${inputFile}" 'unsupported format.' ; ec=$Ex_Data_Err ; continue
							fi
							;;
					esac
				fi

				if [ $touchFiles = true ]; then
					case "$inputFile" in
						*.flac|*.ogg|*.m4a|*.wv|*.ape|*.mp3|*.opus) gotAudioFile=true ;;
						*.wvc) continue ;;
					esac
					sourceFiles[$index]="$inputFile"
					((index++))
				fi
			fi
		fi

		if [ $addToSourceFiles = true ]; then
			sourceFiles[$index]="$inputFile"
			((index++))
		fi
	done

	if [ $touchFiles = true -a $gotAudioFile = false ]; then
		printMessage 'warning' 'processing' 'unsupported' 'at least one supported audio file is required.'; ec=$Ex_Data_Err
		printMessage 'abort' 'verbose'
		cleanExit $ec
	fi

	unset inputFiles
	numberOfSourceFiles=$index

	if [ $ec -ne $Ex_Ok ]; then
		printMessage 'abort'
		cleanExit $ec
	elif [ $numberOfSourceFiles -eq 0 ]; then
		if [ $keepExistingFiles = true ]; then
			printMessage 'warning' 'usage' 'filesystem' 'verbose' "-k: all or some destination files exist already, nothing to do."
		elif [ $keepNewerFiles = true ]; then
			printMessage 'warning' 'usage' 'filesystem' 'verbose' "-K: all or some destination files are newer than their source, nothing to do."
		fi
		printMessage 'warning' 'usage' 'filesystem' 'verbose' "no supported files to work with, nothing to do."
		printMessage 'abort' 'verbose'
		cleanExit $ec
	else
		return $Ex_Ok
	fi
}

checkOutputDirectories () {
	local outputCodec codecFullName codecDestDir

	for outputCodec in $outputCodecs; do
		codecFullName="$( getCodecFullName "$outputCodec" )"
		codecDestDir="$( getDestDir "$outputCodec" )"
		if [ ! -e "$codecDestDir" ]; then
			if ! mkdir -p "$codecDestDir" >/dev/null 2>&1 ; then
				printMessage 'error' 'usage' 'filesystem' "path:${codecDestDir}" "$Self_Name -O/P: failed to create directory, do you have write permissions? ($codecFullName)" ; exit $Ex_Cant_Create
			fi
		elif [ ! -d "$codecDestDir" ]; then
			if [ "$codecDestDir" = "$defaultDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${codecDestDir}" "$Self_Name: not a directory ($codecFullName)." ; exit $Ex_Cant_Create
			else
				printMessage 'error' 'usage' 'filesystem' "path:${codecDestDir}" "$Self_Name -O/P: not a directory ($codecFullName)" ; exit $Ex_Cant_Create
			fi
		elif [ ! -w "$codecDestDir" ]; then
			if [ "$codecDestDir" = "$defaultDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${codecDestDir}" "$Self_Name: permission denied, not writable ($codecFullName)" ; exit $Ex_Cant_Create
			else
				printMessage 'error' 'usage' 'filesystem' "path:${codecDestDir}" "$Self_Name -O/P: permission denied, not writable ($codecFullName)" ; exit $Ex_Cant_Create
			fi
		fi
	done
}

checkBinary () {
	local binary listOfBinaries="$@" pattern ec=$Ex_Ok

	for binary in $listOfBinaries; do
		pattern="x${binary}Y"
		if [ "$searchedBinaries" = "${searchedBinaries//$pattern/@}" ]; then # search for binary hasn't been done before
			searchedBinaries="${searchedBinaries}${pattern}" # make sure we don't check twice for nothing
			if which "$binary" >/dev/null 2>&1 ; then
				foundBinaries="${foundBinaries}${pattern}"
				continue
			else
				binaryMissing=true ec=$Ex_Ko
				if [ "$binary" = "opusgain" ]; then
					printMessage 'warning' 'initialization' 'filesystem' \
	"Binary \"${binary}\" not found. Make sure it is in your \$PATH, and that you've upgraded it to the latest available version. \
You may find it at https://github.com/FrancisRussell/zoog"
				else
					printMessage 'warning' 'initialization' 'filesystem' \
	"Binary \"${binary}\" not found. Make sure it is in your \$PATH, and that you've upgraded it to the latest available version."
				fi
			fi
		elif [ -z "$foundBinaries" -o "$foundBinaries" = "${foundBinaries//$pattern/@}" ]; then
			# binary was previously searched, but not found
			ec=$Ex_Ko
		fi
	done

	return $ec
}

checkMainBinaries () {
	if ! which 'which' >/dev/null 2>&1 ; then
		printMessage 'warning' 'initialization' 'filesystem' "Binary \"which\" not found. Make sure it is in your \$PATH."
		printMessage 'abort'
		cleanExit $Ex_Os_File
	fi

	checkBinary 'bc' 'cut' "$datecmd" 'find' 'grep' 'head' 'mktemp' 'ps' "$sedcmd" 'sort' 'soxi' 'stat' 'tail' 'tr' 'uname' 'wc' 'xargs'

	if [ $? -eq $Ex_Ko ]; then
		printMessage 'abort'
		cleanExit $Ex_Os_File
	else
		return $Ex_Ok
	fi
}

checkBinaries () {
	local sourceFile searchedBinaries='' binaryMissing=false hash outputCodec

	if ! which 'which' >/dev/null 2>&1 ; then
		printMessage 'warning' 'initialization' 'filesystem' "Binary \"which\" not found. Make sure it is in your \$PATH."
		printMessage 'abort'
		cleanExit $Ex_Os_File
	fi

	for sourceFile in "${sourceFiles[@]}" ; do
		case "$sourceFile" in
			*.ape|*.m4a) checkBinary 'ffprobe' ; break ;;
		esac
	done

	if [ $computeReplayGain = true ]; then
		for sourceFile in "${sourceFiles[@]}" ; do
			case "$sourceFile" in
				*.flac) checkBinary 'metaflac' ;;
				*.wv) checkBinary 'wvunpack' 'wvgain' 'wvtag' ;;
				*.ogg) checkBinary 'ogginfo' 'vorbisgain' 'vorbiscomment' ;;
				*.mp3) checkBinary 'ffprobe' 'mp3gain'; if [ $applyGain = false ]; then checkBinary 'eyeD3'; fi ;;
				*.opus) checkBinary 'opusinfo' 'opusgain' ;; # https://github.com/FrancisRussell/zoog
			esac
		done
	elif [ $reverseReplayGain = true ]; then
		for sourceFile in "${sourceFiles[@]}" ; do
			case "$sourceFile" in
				*.flac) checkBinary 'metaflac' ;;
				*.wv) checkBinary 'wvtag' ;;
				*.ape) checkBinary 'APEv2' ;;
				*.ogg) checkBinary 'vorbiscomment' ;;
				*.opus) checkBinary 'opusgain' ;;
				*.mp3) checkBinary 'mp3gain' ;;
			esac
		done
	elif [ $checkFiles = true ]; then
		checkBinary 'sox'
		for sourceFile in "${sourceFiles[@]}" ; do
			case "$sourceFile" in
				*.flac) checkBinary 'flac' 'metaflac' ;;
				*.wv) checkBinary 'wvunpack' 'APEv2' ;;
				*.ape) checkBinary 'mac' 'APEv2' ;;
			esac
		done
	elif [ $touchFiles = true ]; then
		for sourceFile in "${sourceFiles[@]}" ; do
			case "$sourceFile" in
				*.flac) checkBinary 'metaflac' ;;
				*.ogg) checkBinary 'ogginfo' 'vorbiscomment' ;;
				*.m4a) checkBinary 'ffmpeg' 'ffprobe' ;;
				*.opus) checkBinary 'opusinfo' ;;
				*.wv) checkBinary 'wvtag' 'wvunpack' ;;
				*.ape) checkBinary 'mac' 'APEv2' 'ffprobe' ;;
				*.mp3) checkBinary 'ffmpeg' ;;
			esac
		done
	else # transcode
		for sourceFile in "${sourceFiles[@]}" ; do
			case "$sourceFile" in
				*.aiff|*.caf) checkBinary 'sox' ;;
				*.flac) checkBinary 'flac' 'metaflac' ;;
				*.wv) checkBinary 'wvunpack' 'APEv2' ;;
				*.ape) checkBinary 'mac' 'APEv2' ;;
				*.m4a) checkBinary 'ffmpeg' ;;
			esac
		done

		if [ $applyGain = true ]; then
			checkBinary 'sox'
		fi
	fi

	for outputCodec in $outputCodecs; do
		case "$outputCodec" in
			AIFF|CAF) checkBinary 'sox' ;;
			FLAC) checkBinary 'flac' ;;
			WavPack|WavPackHybrid|WavPackLossy) checkBinary 'wavpack' 'APEv2' ;;
			MonkeysAudio) checkBinary 'mac' 'APEv2' ;;
			lossyWAV) checkBinary 'lossywav' ;;
			lossyFLAC) checkBinary 'lossywav' 'flac' ;;
			lossyWV) checkBinary 'lossywav' 'wavpack' 'APEv2' ;;
			OggVorbis) checkBinary 'oggenc' ;;
			MP3) checkBinary 'lame' 'eyeD3' ;;
			AAC|ALAC) checkBinary 'ffmpeg' ;;
			Opus) checkBinary 'opusenc' ;;
		esac
	done

	if [ -n "$hashes" ]; then
		checkBinary 'sox'
		if [ "$OS" = 'Linux' ]; then
			for hash in $hashes; do
				case $hash in
					CRC32) checkBinary 'cksfv' 'mkfifo' ;;
					MD5) checkBinary 'md5sum' ;;
					SHA1) checkBinary 'sha1sum' ;;
					SHA256) checkBinary 'sha256sum' ;;
					SHA512) checkBinary 'sha512sum' ;;
				esac
			done
		else
			for hash in $hashes; do
				case $hash in
					CRC32) checkBinary 'cksfv' 'mkfifo' ;;
					MD5) checkBinary 'md5' ;;
					SHA1|SHA256|SHA512) checkBinary 'shasum' ;;
				esac
			done
		fi
	fi

	if [ -n "$bitDepth" -o -n "$samplingRate" -o "$convertToStereo" != 'false' ]; then
		checkBinary 'sox'
	fi

	if [ $binaryMissing = true ]; then
		printMessage 'abort'
		cleanExit $Ex_Os_File
	else
		return $Ex_Ok
	fi
}

setNumberOfProcesses () {
	local newNumberOfProcesses=$1 processNumber

	for (( processNumber=0 ; processNumber < newNumberOfProcesses; processNumber++ )); do
		touch "${instanceDir}/process.$processNumber" >/dev/null 2>&1
	done

	if [ $newNumberOfProcesses -lt $nProcesses ]; then
		for (( processNumber=newNumberOfProcesses ; processNumber < nProcesses; processNumber++ )); do
			rm -f "${instanceDir}/process.$processNumber"
		done
	elif [ $newNumberOfProcesses -gt $nProcesses ]; then
		for (( processNumber=nProcesses ; processNumber < newNumberOfProcesses; processNumber++ )); do
			touch "${instanceDir}/process.$processNumber" >/dev/null 2>&1
		done
	fi

	nProcesses=$newNumberOfProcesses
}

isProcessRunning () {
	if ps "$1" >/dev/null 2>&1 ; then
		return $Ex_Ok
	else
		return $Ex_Ko
	fi
}

cleanUpInstances () {
	local pid tdir

	for d in "${Self_Pid_Dir}/instance".???????? ; do
		if [ -d "$d" -a -f "${d}/PID" ]; then
			pid="$( cat "${d}/PID" 2>/dev/null )"
			if ! isProcessRunning $pid ; then
				tdir="$( cat "${d}/tdir" 2>/dev/null )"
				if [ -d "$tdir" ]; then
					rm -rf "$tdir" >/dev/null 2>&1
				fi
				rm -rf "$d" >/dev/null 2>&1
			fi
		fi
	done

	for f in "${Self_Io_Dir}"/*.lock ; do
		if [ -f "$f" ]; then
			cleanUpCopyLockFile "${f%.lock}"
		fi
	done
}

handleInstance () {
	local nRunningProcesses=0 nAvailableProcesses=$nProcesses pid

	if [ -e "$Self_Pid_Dir" ]; then
		cleanUpInstances
	else
		mkdir -m 0777 -p "$Self_Pid_Dir" >/dev/null 2>&1
	fi

	if [ ! -d "$Self_Pid_Dir" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${Self_Pid_Dir}" "couldn't create directory."
		printMessage 'abort'
		cleanExit $Ex_Cant_Create
	elif [ ! -w "$Self_Pid_Dir" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${Self_Pid_Dir}" "directory is not writable (permission denied)."
		printMessage 'abort'
		cleanExit $Ex_No_Perm
	fi

	if [ ! -d "$Self_Io_Dir" ]; then
		mkdir -m 0777 -p "$Self_Io_Dir" >/dev/null 2>&1
	fi

	instanceDir="$( TMPDIR="$Self_Pid_Dir" mktemp -d "${Self_Pid_Dir}/instance.XXXXXXXX" 2>/dev/null )"
	if [ -z "$instanceDir" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${Self_Pid_Dir}" "mktemp failed to create a directory (do you have write permissions?)."
		printMessage 'abort'
		cleanExit $Ex_Os_Err
	elif [ ! -w "$instanceDir" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${instanceDir}" "directory is not writable (permission denied)."
		printMessage 'abort'
		cleanExit $Ex_No_Perm
	fi
	chmod 0775 "$instanceDir"
	mkdir -m 0775 "${instanceDir}/ioLockFiles"
	errorLogFile="${instanceDir}/errors.log"
	touch "$errorLogFile"
	echo "$$" > "${instanceDir}/PID"

	nInstances=$( find "$Self_Pid_Dir" -type d -name 'instance.*' 2>/dev/null | wc -l | tr -cd '0-9' )
	if [ $nInstances -le $maxInstances ]; then
		nRunningProcesses="$( getNumberOfCaudecProcesses )"
		nAvailableProcesses=$(( maxProcesses - nRunningProcesses ))
		if [ $nAvailableProcesses -eq 0 ]; then
			printMessage 'warning' 'usage' 'quota' "There are too many caudec processes already running."
			printMessage 'abort'
			cleanExit $Ex_Temp_Fail
		elif [ $nProcesses -gt $nAvailableProcesses ]; then
			printMessage 'warning' 'usage' 'quota' 'verbose' "Number of processes reduced to $nAvailableProcesses in order to stay within limits."
			setNumberOfProcesses $nAvailableProcesses
		else
			setNumberOfProcesses $nProcesses
		fi
		return 0
	else
		if [ $maxInstances -eq 1 ]; then
			printMessage 'warning' 'usage' 'quota' "Another instance of caudec is already running."
		else
			printMessage 'warning' 'usage' 'quota' "Too many instances of caudec are already running."
		fi
		printMessage 'info' 'stderr' "You might want to increase the 'maxInstances' value in /etc/caudecrc or ~/.caudecrc."
		printMessage 'abort'
		cleanExit $Ex_Temp_Fail
	fi
}

setupSwapDir () {
	local index ec=1 copyLockFile fileMilliseconds

	if [ -n "$TMPDIR" ]; then mktempDir="$TMPDIR"; else mktempDir='/tmp'; fi

	if [ -n "$CAUDECDIR" ]; then
		if [ "$CAUDECDIR" != '/' ]; then
			CAUDECDIR="${CAUDECDIR%/}" # remove trailing slash
		fi
		if [ "${CAUDECDIR:0:1}" != '/' ]; then # if not an absolute path, prepend current dir
			CAUDECDIR="${PWD}/${CAUDECDIR}"
		fi

		if [ ! -e "$CAUDECDIR" ]; then
			printMessage 'warning' 'initialization' 'filesystem' "path:${CAUDECDIR}" "CAUDECDIR doesn't exist."
			printMessage 'abort'
			cleanExit $Ex_Os_File
		elif [ ! -d "$CAUDECDIR" ]; then
			printMessage 'warning' 'initialization' 'filesystem' "path:${CAUDECDIR}" "CAUDECDIR is not a directory."
			printMessage 'abort'
			cleanExit $Ex_Cant_Create
		elif [ ! -w "$CAUDECDIR" ]; then
			printMessage 'warning' 'initialization' 'filesystem' "path:${CAUDECDIR}" "CAUDECDIR is not writable (permission denied)."
			printMessage 'abort'
			cleanExit $Ex_No_Perm
		fi
		mktempDir="$CAUDECDIR"
	fi

	if [ ! -e "$mktempDir" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${mktempDir}" "directory doesn't exist."
		printMessage 'abort'
		cleanExit $Ex_Os_File
	elif [ ! -d "$mktempDir" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${mktempDir}" "not a directory."
		printMessage 'abort'
		cleanExit $Ex_Cant_Create
	elif [ ! -w "$mktempDir" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${mktempDir}" "directory is not writable (permission denied)."
		printMessage 'abort'
		cleanExit $Ex_No_Perm
	fi

	TDIR="$( TMPDIR="$mktempDir" mktemp -d "${mktempDir}/${Self_Name}.XXXXXXXX" 2>/dev/null )"

	if [ -z "$TDIR" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${mktempDir}" "mktemp failed to create a directory (do you have write permissions?)."
		printMessage 'abort'
		cleanExit $Ex_Os_Err
	elif [ ! -w "$TDIR" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${TDIR}" "directory is not writable (permission denied)."
		printMessage 'abort'
		cleanExit $Ex_No_Perm
	fi

	chmod 0775 "$TDIR"

	# FIXME STAT: for some reason, gstat -c doesn't work here on macOS
	# if [ $gnustat = true ]; then
	# 	TDEV="$( $statcmd -c '%d' "$TDIR" )"
	# else
	# 	TDEV="$( $statcmd -f '%d' "$TDIR" )"
	# fi

	if [ "$OS" = 'Linux' ]; then
		TDEV="$( stat -c '%d' "$TDIR" )"
	else
		TDEV="$( stat -f '%d' "$TDIR" )"
	fi
	echo "$TDEV" > "${instanceDir}/tdev"
	echo "$TDIR" > "${instanceDir}/tdir"

	SWAPDIR="$TDIR"

	for ((index=0; index < ${#sourceFiles[@]}; index++)); do
		if [ "$OS" = 'Linux' ]; then
			copyLockFile="${Self_Io_Dir}/$( stat -c '%d' "${sourceFiles[$index]}" 2>> "$errorLogFile" )"
		else
			copyLockFile="${Self_Io_Dir}/$( stat -f '%d' "${sourceFiles[$index]}" 2>> "$errorLogFile" )"
		fi
		if [ ! -e "${copyLockFile}.lock" ]; then
			touch "$copyLockFile"
		fi

		touch "${TDIR}/${index}"

		fileMilliseconds="$( getFileMilliseconds "${sourceFiles[$index]}" 2>> "$errorLogFile" )"
		echo "$fileMilliseconds $index" > "${TDIR}/inputMilliseconds_${index}"

		if [ $nLossyWAV -ge 1 ]; then
			touch "${TDIR}/lossyWAV_${index}"
			touch "${TDIR}/lossyWAV_${index}_WAV_NEEDED"
		fi

		for outputCodec in $outputCodecs; do
			touch "${TDIR}/${outputCodec}_${index}"
			if [ "$outputCodec" = 'lossyFLAC' -o "$outputCodec" = 'lossyWV' ]; then
				touch "${TDIR}/${outputCodec}_${index}_LOSSYWAV_NEEDED"
				touch "${TDIR}/lossyWAV_${index}_WAV_NEEDED"
			else
				touch "${TDIR}/${outputCodec}_${index}_WAV_NEEDED"
			fi
		done
	done

	sort -n "${TDIR}/inputMilliseconds_"* > "${TDIR}/millisecondsAndFileNumbers"

	echo -n "0" > "${TDIR}/readTimes"
	touch "${TDIR}/transcodingErrorFiles"
	ln -s "$SWAPDIR" "$Self_Pid_Dir"
}

getNumberOfChannels () {
	local file="$1" numberOfChannels=0

	case "$file" in
		*.wav|*.aiff|*.caf) numberOfChannels="$( soxi -c "$file" 2>/dev/null )" ;;
		*.flac) numberOfChannels="$( metaflac --show-channels "$file" 2>/dev/null )" ;;
		*.wv) numberOfChannels="$( wvunpack -f "$file" 2>/dev/null | cut -d ";" -f 4 )" ;;
		*.ogg) numberOfChannels="$( ogginfo "$file" 2>/dev/null | grep -E "^Channels:" | tr -cd "0-9" )" ;;
		*.opus) numberOfChannels="$( opusinfo "$file" | grep -F "Channels: " | tr -cd "0-9" )" ;;
		*.mp3) numberOfChannels="$( soxi -c "$file" 2>/dev/null | tr -cd "0-9" )" ;;
		*) numberOfChannels="$( ffprobe -print_format 'default' -show_streams -select_streams 'a:0' "$file" 2>/dev/null | grep -F "channels=" | tr -cd "0-9" )" ;;
	esac

	if [ -z "$numberOfChannels" ]; then numberOfChannels=0; fi
	echo "$numberOfChannels"
}

getNumberOfCaudecProcesses () {
	local n=0

	n=$( find "$Self_Pid_Dir" -type f -name 'process.*' 2>/dev/null | wc -l | tr -cd '0-9' )
	case "$n" in
		[0-9]*) echo $n ;;
		*) echo 0 ;;
	esac
}

getNumberOfProcessedFiles () {
	ls -1 "${TDIR}/WAS_PROCESSED".* 2>/dev/null | wc -l | tr -cd '[:digit:]'
}

getNumberOfAvailableThreads () {
	local n=$1 maxThreads="$2" nProcessedFiles=0 nUnprocessedFiles nAvailableProcesses nMillisecondsLeft=0 nThreads=1

	if [ -z "$maxThreads" ]; then
		maxThreads=999999
	fi

	nProcessedFiles="$( getNumberOfProcessedFiles )"
	nAvailableProcesses=$(( maxProcessesSetByUser - ( numberOfSourceFiles - 1 - nProcessedFiles ) ))
	if [ $nAvailableProcesses -lt 2 ]; then
		echo 1
		return
	fi

	while read milliseconds number; do
		test -e "${TDIR}/WAS_PROCESSED.${number}" &>/dev/null && continue
		nMillisecondsLeft=$(( nMillisecondsLeft + milliseconds ))
	done < "${TDIR}/millisecondsAndFileNumbers"

	while read milliseconds number; do
		test -e "${TDIR}/WAS_PROCESSED.${number}" &>/dev/null && continue
		if [ "$number" = "$index" ]; then
			nThreads="$( printf "%.0f" "$( echo "scale=3; $maxProcessesSetByUser * $milliseconds / $nMillisecondsLeft" | bc )" )"
			break
		fi
	done < "${TDIR}/millisecondsAndFileNumbers"

	if [ $nThreads -lt 1 ]; then
		nThreads=1
	fi
	if [ $nThreads -gt $maxThreads ]; then
		nThreads=$maxThreads
	fi
	echo $nThreads
}


tagline () {
	local IFS=' ' tags switch value pattern nLines ereg
	test -e "$destTagFile" || return

	cp "$destTagFile" "${destTagFile}.${outputCodec}"

	if [ -n "$outputCodecs" ]; then
		pattern="x${outputCodec}Y"
		if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then
			for h in $hashes; do
				case $h in
					CRC32) ereg="${ereg}|CRC32=" ;;
					MD5) ereg="${ereg}|MD5=" ;;
					SHA1) ereg="${ereg}|SHA1=" ;;
					SHA256) ereg="${ereg}|SHA256=" ;;
					SHA512) ereg="${ereg}|SHA512=" ;;
				esac
			done
			if [ -n "$ereg" ]; then
				grep -iE "${ereg:1}" "$destTagFile" > "${destTagFile}.${outputCodec}"
			else
				rm -f "${destTagFile}.${outputCodec}" ; touch "${destTagFile}.${outputCodec}"
			fi
		fi

		case "$outputCodec" in
			WavPackLossy|MP3|AAC|ALAC|OggVorbis|Opus)
				if [ "$outputCodec" = 'WavPackLossy' ]; then
					grep -viE "MD5=|CRC32=|SHA1=|SHA256=|SHA512=" "${destTagFile}.${outputCodec}" > "${destTagFile}.${outputCodec}.tmp"
				else
					grep -viE "replaygain|MD5=|CRC32=|SHA1=|SHA256=|SHA512=" "${destTagFile}.${outputCodec}" > "${destTagFile}.${outputCodec}.tmp"
				fi
				mv "${destTagFile}.${outputCodec}.tmp" "${destTagFile}.${outputCodec}"
				for h in $hashes; do
					grep -i "SOURCE${h}=" "$destTagFile" >> "${destTagFile}.${outputCodec}"
				done
				;;

			FLAC|WavPack|WavPackHybrid|MonkeysAudio|ALAC)
				if isWavProcessed ; then # SoX was used on the WAV file for resampling, applying gain, or converting to stereo
					grep -viE "µµµCRC32=|µµµMD5=|µµµSHA1=|µµµSHA256=|µµµSHA512=" "${destTagFile}.${outputCodec}" > "${destTagFile}.${outputCodec}.tmp"
					mv "${destTagFile}.${outputCodec}.tmp" "${destTagFile}.${outputCodec}"
				else # no processing was done to the original WAV file
					for h in $hashes; do
						grep -viE "SOURCE${h}=" "${destTagFile}.${outputCodec}" > "${destTagFile}.${outputCodec}.tmp"
						mv "${destTagFile}.${outputCodec}.tmp" "${destTagFile}.${outputCodec}"
					done
					if [ $gnused = true ]; then
						$sedcmd -i'' -e 's@µµµCRC32=@SOURCECRC32=@i' -e 's@µµµMD5=@SOURCEMD5=@i' -e 's@µµµSHA1=@SOURCESHA1=@i' -e 's@µµµSHA256=@SOURCESHA256=@i' -e 's@µµµSHA512=@SOURCESHA512=@i' "${destTagFile}.${outputCodec}"
					else
						$sedcmd -i '' -e 's@µµµCRC32=@SOURCECRC32=@i' -e 's@µµµMD5=@SOURCEMD5=@i' -e 's@µµµSHA1=@SOURCESHA1=@i' -e 's@µµµSHA256=@SOURCESHA256=@i' -e 's@µµµSHA512=@SOURCESHA512=@i' "${destTagFile}.${outputCodec}"
					fi
				fi
				;;

			lossy*)
				grep -viE "MD5=|CRC32=|SHA1=|SHA256=|SHA512=" "${destTagFile}.${outputCodec}" > "${destTagFile}.${outputCodec}.tmp"
				mv "${destTagFile}.${outputCodec}.tmp" "${destTagFile}.${outputCodec}"
				for h in $hashes; do
					grep -i "SOURCE${h}=" "$destTagFile" >> "${destTagFile}.${outputCodec}"
					case "$h" in
						CRC32) if [ -f "$lossywavCRC32File" ]; then cat "$lossywavCRC32File" >> "${destTagFile}.${outputCodec}" ; fi ;;
						MD5) if [ -f "$lossywavMD5File" ]; then cat "$lossywavMD5File" >> "${destTagFile}.${outputCodec}" ; fi ;;
						SHA1) if [ -f "$lossywavSHA1File" ]; then cat "$lossywavSHA1File" >> "${destTagFile}.${outputCodec}" ; fi ;;
						SHA256) if [ -f "$lossywavSHA256File" ]; then cat "$lossywavSHA256File" >> "${destTagFile}.${outputCodec}" ; fi ;;
						SHA512) if [ -f "$lossywavSHA512File" ]; then cat "$lossywavSHA512File" >> "${destTagFile}.${outputCodec}" ; fi ;;
					esac
				done
				;;
		esac
	fi

	if isWavProcessed ; then # SoX was used on the WAV file for resampling, applying gain, or converting to stereo
		grep -Fvi 'replaygain' "${destTagFile}.${outputCodec}" > "${destTagFile}.${outputCodec}.tmp"
		mv "${destTagFile}.${outputCodec}.tmp" "${destTagFile}.${outputCodec}"
	fi

	if [ -n "$compressionTag" ]; then
		echo "$compressionTag" >> "${destTagFile}.${outputCodec}"
	fi

	nLines="$( cat "${destTagFile}.${outputCodec}" | wc -l | tr -cd '0-9' )"
	if [ $nLines -eq 0 ]; then
		return
	fi

	if [ -n "$1" ]; then
		while read line; do
			tags="${tags}\x00${1}\x00${line}"
		done < "${destTagFile}.${outputCodec}"
	else
		while read switch value; do
			tags="${tags}\x00${switch}\x00${value}"
		done < "${destTagFile}.${outputCodec}"
	fi
	rm -f "${destTagFile}.${outputCodec}"
	printf -- "%s" "${tags//%/%%}" | $sedcmd -e 's#§#\n#g' -e 's@\x02@\\\\x00@g'
}

# http://wiki.xiph.org/Field_names
# http://age.hobba.nl/audio/mirroredpages/ogg-tagging.html
# http://reallylongword.org/vorbiscomment/
# http://wiki.hydrogenaudio.org/index.php?title=APE_key
# http://www.id3.org/id3v2.3.0

# Sanitize track or disc number
getTrackOrDiscNumber () {
	local s="$1"

	s="${s%/*}"
	case "$s" in
		[0-9]|[0-9][0-9]|[0-9][0-9][0-9]|[0-9][0-9][0-9][0-9]) echo "$s" ;;
		*) echo '0' ;;
	esac
}

getTotalDiscsAndTracks () {
	local field value

	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		case "$field" in
			disctotal|totaldiscs)   totalDiscs="$( getTrackOrDiscNumber "$value" )" ;;
			tracktotal|totaltracks) totalTracks="$( getTrackOrDiscNumber "$value" )" ;;

			media|disc|discnumber)
				case "$value" in
					[0-9]*)
						if [ "${value#*/}" != "$value" ]; then
							totalDiscs="$( getTrackOrDiscNumber "${value#*/}" )"
						fi
						;;
				esac
				;;

			track|tracknumber)
				if [ "${value#*/}" != "$value" ]; then
					totalTracks="$( getTrackOrDiscNumber "${value#*/}" )"
				fi
				;;
		esac
	done < "$sourceTagFile"
}

vorbisCommentsToAPEv2 () {
	local line field value totalDiscs='' totalTracks=''

	getTotalDiscsAndTracks
	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		case "$field" in
			album)                 echo "Album=$value" ;;
			albumartist|"album artist") echo "Album Artist=$value" ;;
			artist)                echo "Artist=$value" ;;
			composer)              echo "Composer=$value" ;;
			conductor)             echo "Conductor=$value" ;;
			copyright)             echo "Copyright=$value" ;;
			crc32)                 echo "CRC32=$value" ;;
			date)                  printf 'Year=%.4s\n' "$value" ;;
			description)           echo "Comment=$value" ;;
			discnumber)
				if [ -n "$totalDiscs" ]; then
					printf 'Disc=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalDiscs"
				else
					printf 'Disc=%g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			disctotal|totaldiscs)  continue ;;
			ean/upc)               echo "EAN/UPC=$value" ;;
			encoder|encoding)      continue ;;
			genre)                 echo "Genre=$value" ;;
			isrc)                  echo "ISRC=$value" ;;
			labelno)               echo "Catalog=$value" ;;
			license)               echo "License=$value" ;;
			location)              echo "Record Location=$value" ;;
			md5)                   echo "MD5=$value" ;;
			performer)             echo "Performer=$value" ;;
			publisher)             echo "Publisher=$value" ;;
			replaygain_reference_loudness) echo "Replaygain_Reference_Loudness=$value" ;;
			replaygain_track_gain) echo "Replaygain_Track_Gain=$value" ;;
			replaygain_track_peak) echo "Replaygain_Track_Peak=$value" ;;
			replaygain_album_gain) echo "Replaygain_Album_Gain=$value" ;;
			replaygain_album_peak) echo "Replaygain_Album_Peak=$value" ;;
			sha1)                  echo "SHA1=$value" ;;
			sha256)                echo "SHA256=$value" ;;
			sha512)                echo "SHA512=$value" ;;
			sourcemedia)           echo "Media=$value" ;;
			subtitle)              echo "Subtitle=$value" ;;
			title)                 echo "Title=$value" ;;
			tracknumber)
				if [ -n "$totalTracks" ]; then
					printf 'Track=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalTracks"
				else
					printf 'Track=%g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			tracktotal|totaltracks) continue ;;
			*)                     echo "${field}=${value}" ;;
		esac
	done < "$sourceTagFile"
}

vorbisCommentsToEyeD3 () {
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks
	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		# replace ASCII hyphen-minus with an UTF-8 non-breaking hyphen only when they may cause failure,
		# and escape spaces
		value="$( echo "$value" | $sedcmd -e 's@^-@‑@' -e 's@ -@ ‑@g' -e 's@ @\\ @g' )"
		case "$field" in
			album)                 echo "--album $value" ;;
			albumartist|"album artist")
				echo "--album-artist $value"
				if [ "$value" = 'Various Artists' -o $setCompilationFlagWithAlbumArtist = true ]; then
					echo "--text-frame=TCMP:1" # iTunes 'compilation' frame
				fi
				;;
			artist)                echo "--artist $value" ;;
			composer)              echo "--composer $value" ;;
			conductor)             echo "--text-frame=TPE3:$value" ;;
			date)                  printf -- '--release-year %.4s\n--release-date %.4s\n--orig-release-date %.4s\n--recording-date %.4s\n' "$value" "$value" "$value" "$value" ;;
			# description)           echo "--tc $value" ;;
			discnumber)            printf -- '--disc-num %g\n' "$( getTrackOrDiscNumber "$value" )" ;;
			disctotal|totaldiscs)  printf -- '--disc-total %g\n' "$( getTrackOrDiscNumber "$value" )" "$totalDiscs" ;;
			encoder|encoding)      continue ;;
			genre)                 echo "--genre $value" ;;
			isrc)                  echo "--text-frame=TSRC:$value" ;;
			license) if [ "${value:0:7}" = 'http://' ]; then echo "--text-frame=WCOP:$value" ; fi ;;
			lyricist)              echo "--text-frame=TEXT:$value" ;;
			performer)             echo "--text-frame=TPE3:$value" ;;
			publisher)             echo "--publisher $value" ;;
			subtitle)              echo "--text-frame=TIT3:$value" ;;
			title)                 echo "--title $value" ;;
			tracknumber)           printf -- '--track %g\n' "$( getTrackOrDiscNumber "$value" )" ;;
			tracktotal|totaltracks) printf -- '--track-total %g\n' "$totalTracks" ;;
			# *)                     echo "--user-text-frame=${field}:${value}" ;;
			*) continue ;;
		esac
	done < "$sourceTagFile"
}

vorbisCommentsToM4A () {
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks

	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		case "$field" in
			album)                 echo "-metadata album=$value" ;;
			albumartist|"album artist")
				echo "-metadata album_artist=$value"
				if [ "$value" = 'Various Artists' -o $setCompilationFlagWithAlbumArtist = true ]; then
					echo "-metadata compilation=1" # iTunes 'compilation' frame
				fi
				;;
			artist)                echo "-metadata artist=$value" ;;
			composer)              echo "-metadata composer=$value" ;;
			copyright)             echo "-metadata copyright=$value" ;;
			date)                  printf -- '-metadata date=%.4s\n' "$value" ;;
			description)           echo "-metadata comment=$value" ;;
			discnumber)
				if [ -n "$totalDiscs" ]; then
					printf -- '-metadata disc=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalDiscs"
				else
					printf -- '-metadata disc=%g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			disctotal|totaldiscs)  continue ;;
			encoder|encoding)      continue ;;
			genre)                 echo "-metadata genre=$value" ;;
			isrc)                  echo "-metadata isrc=$value" ;;
			organization)          echo "-metadata label=$value" ;;
			title)                 echo "-metadata title=$value" ;;
			tracknumber)
				if [ -n "$totalTracks" ]; then
					printf -- '-metadata track=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalTracks"
				else
					printf -- '-metadata track=%g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			tracktotal|totaltracks) continue ;;
			cdec|encoding|itunnorm|itunsmpb|tool) continue ;;
			*) continue ;;
		esac
	done < "$sourceTagFile"
}

M4AToVorbisComments () {
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks
	if [ -n "$totalDiscs" ]; then
		printf 'DISCTOTAL=%g\n' "$totalDiscs"
	fi
	if [ -n "$totalTracks" ]; then
		printf 'TRACKTOTAL=%g\n' "$totalTracks"
	fi

	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		case "$field" in
			album)                 echo "ALBUM=$value" ;;
			album_artist)          echo "ALBUMARTIST=$value" ;;
			artist)                echo "ARTIST=$value" ;;
			composer)              echo "COMPOSER=$value" ;;
			copyright)             echo "COPYRIGHT=$value" ;;
			date)                  printf 'DATE=%.4s\n' "$value" ;;
			comment)               echo "DESCRIPTION=$value" ;;
			disc)                  printf 'DISCNUMBER=%g\n' "$( getTrackOrDiscNumber "$value" )" ;;
			genre)                 echo "GENRE=$value" ;;
			isrc)                  echo "ISRC=$value" ;;
			label)                 echo "ORGANIZATION=$value" ;;
			title)                 echo "TITLE=$value" ;;
			track)                 printf -- 'TRACKNUMBER=%g\n' "$( getTrackOrDiscNumber "$value" )";;
			*) continue ;;
		esac
	done < "$sourceTagFile"
}

M4AToAPEv2 () {
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks
	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		case "$field" in
			album)                 echo "Album=$value" ;;
			album_artist)          echo "Album Artist=$value" ;;
			artist)                echo "Artist=$value" ;;
			composer)              echo "Composer=$value" ;;
			copyright)             echo "Copyright=$value" ;;
			date)                  printf 'Year=%.4s\n' "$value" ;;
			comment)               echo "Comment=$value" ;;
			disc)
				if [ -n "$totalDiscs" ]; then
					printf 'Disc=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalDiscs"
				else
					printf 'Disc=%g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			genre)                 echo "Genre=$value" ;;
			isrc)                  echo "ISRC=$value" ;;
			title)                 echo "Title=$value" ;;
			track)
				if [ -n "$totalTracks" ]; then
					printf 'Track=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalTracks"
				else
					printf 'Track=%g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			*) continue ;;
		esac
	done < "$sourceTagFile"
}

M4AToEyeD3 () {
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks
	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		# replace ASCII hyphen-minus with an UTF-8 non-breaking hyphen only when they may cause failure,
		# and escape spaces
		value="$( echo "$value" | $sedcmd -e 's@^-@‑@' -e 's@ -@ ‑@g' -e 's@ @\\ @g' )"
		case "$field" in
			album)                 echo "--album $value" ;;
			album_artist)
				echo "--album-artist $value"
				if [ "$value" = 'Various Artists' -o $setCompilationFlagWithAlbumArtist = true ]; then
					echo "--text-frame=TCMP:1" # iTunes 'compilation' frame
				fi
				;;
			artist)                echo "--artist $value" ;;
			composer)              echo "--composer $value" ;;
			genre)                 echo "--genre $value" ;;
			isrc)                  echo "--text-frame=TSRC:$value" ;;
			disc)
				case "$value" in
					[0-9]*)
						printf -- '--disc-num %g\n' "$( getTrackOrDiscNumber "$value" )"
						if [ -n "$totalDiscs" ]; then
							printf -- '--disc-total %g\n' "$( getTrackOrDiscNumber "$value" )" "$totalDiscs"
						fi
						;;
				esac
				;;
			title)                 echo "--title $value" ;;
			track)
				if [ -n "$totalTracks" ]; then
					printf -- '--track %g\n' "$( getTrackOrDiscNumber "$value" )"
					printf -- '--track-total %g\n' "$totalTracks"
				else
					printf -- '--track %g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			year)                  printf -- '--release-year %.4s\n--release-date %.4s\n--orig-release-date %.4s\n--recording-date %.4s\n' "$value" "$value" "$value" "$value" ;;
			*) continue ;;
		esac
	done < "$sourceTagFile"
}

APEv2ToVorbisComments () {
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks
	if [ -n "$totalDiscs" ]; then
		printf 'DISCTOTAL=%g\n' "$totalDiscs"
	fi
	if [ -n "$totalTracks" ]; then
		printf 'TRACKTOTAL=%g\n' "$totalTracks"
	fi

	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		case "$field" in
			album)                 echo "ALBUM=$value" ;;
			albumartist|"album artist") echo "ALBUMARTIST=$value" ;;
			artist)                echo "ARTIST=$value" ;;
			catalog)               echo "LABELNO=$value" ;;
			comment)               echo "DESCRIPTION=$value" ;;
			composer)              echo "COMPOSER=$value" ;;
			conductor)             echo "CONDUCTOR=$value" ;;
			copyright)             echo "COPYRIGHT=$value" ;;
			crc32)                 echo "CRC32=$value" ;;
			ean/upc)               echo "EAN/UPC=$value" ;;
			encoder|encoding)      continue ;;
			genre)                 echo "GENRE=$value" ;;
			isrc)                  echo "ISRC=$value" ;;
			license)               echo "LICENSE=$value" ;;
			md5)                   echo "MD5=$value" ;;
			media|disc)
				case "$value" in
					[0-9]*) printf 'DISCNUMBER=%g\n' "$( getTrackOrDiscNumber "$value" )" ;;
					*) echo "SOURCEMEDIA=$value" ;;
				esac ;;
			performer)             echo "PERFORMER=$value" ;;
			publisher)             echo "PUBLISHER=$value" ;;
			'record location')     echo "LOCATION=$value" ;;
			replaygain_reference_loudness) echo "REPLAYGAIN_REFERENCE_LOUDNESS=$value" ;;
			replaygain_track_gain) echo "REPLAYGAIN_TRACK_GAIN=$value" ;;
			replaygain_track_peak) echo "REPLAYGAIN_TRACK_PEAK=$value" ;;
			replaygain_album_gain) echo "REPLAYGAIN_ALBUM_GAIN=$value" ;;
			replaygain_album_peak) echo "REPLAYGAIN_ALBUM_PEAK=$value" ;;
			sha1)                  echo "SHA1=$value" ;;
			sha256)                echo "SHA256=$value" ;;
			sha512)                echo "SHA512=$value" ;;
			subtitle)              echo "SUBTITLE=$value" ;;
			title)                 echo "TITLE=$value" ;;
			track)                 printf 'TRACKNUMBER=%g\n' "$( getTrackOrDiscNumber "$value" )" ;;
			year)                  printf 'DATE=%.4s\n' "$value" ;;
			*)                     echo "${field}=${value}" ;;
		esac
	done < "$sourceTagFile"
}

APEv2ToEyeD3 () {
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks
	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		# replace ASCII hyphen-minus with an UTF-8 non-breaking hyphen only when they may cause failure,
		# and escape spaces
		value="$( echo "$value" | $sedcmd -e 's@^-@‑@' -e 's@ -@ ‑@g' -e 's@ @\\ @g' )"
		case "$field" in
			album)                 echo "--album $value" ;;
			albumartist|"album artist")
				echo "--album-artist $value"
				if [ "$value" = 'Various Artists' -o $setCompilationFlagWithAlbumArtist = true ]; then
					echo "--text-frame=TCMP:1" # iTunes 'compilation' frame
				fi
				;;
			artist)                echo "--artist $value" ;;
			composer)              echo "--composer $value" ;;
			conductor)             echo "--text-frame=TPE3:$value" ;;
			encoder|encoding)      continue ;;
			genre)                 echo "--genre $value" ;;
			isrc)                  echo "--text-frame=TSRC:$value" ;;
			license) if [ "${value:0:7}" = 'http://' ]; then echo "--text-frame=WCOP:$value" ; fi ;;
			media|disc)
				case "$value" in
					[0-9]*)
						printf -- '--disc-num %g\n' "$( getTrackOrDiscNumber "$value" )"
						if [ -n "$totalDiscs" ]; then
							printf -- '--disc-total %g\n' "$( getTrackOrDiscNumber "$value" )" "$totalDiscs"
						fi
						;;
				esac
				;;
			performer)             echo "--text-frame=TPE3:$value" ;;
			publisher)             echo "--publisher $value" ;;
			subtitle)              echo "--text-frame=TIT3:$value" ;;
			title)                 echo "--title $value" ;;
			track)
				if [ -n "$totalTracks" ]; then
					printf -- '--track %g\n' "$( getTrackOrDiscNumber "$value" )"
					printf -- '--track-total %g\n' "$totalTracks"
				else
					printf -- '--track %g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			year)                  printf -- '--release-year %.4s\n--release-date %.4s\n--orig-release-date %.4s\n--recording-date %.4s\n' "$value" "$value" "$value" "$value" ;;
			# *)                     echo "--user-text-frame=${field}:${value}" ;;
			*) continue ;;
		esac
	done < "$sourceTagFile"
}

APEv2ToM4A () {
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks

	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		case "$field" in
			album)                 echo "-metadata album=$value" ;;
			albumartist|"album artist")
				echo "-metadata album_artist=$value"
				if [ "$value" = 'Various Artists' -o $setCompilationFlagWithAlbumArtist = true ]; then
					echo "-metadata compilation=1" # iTunes 'compilation' frame
				fi
				;;
			artist)                echo "-metadata artist=$value" ;;
			comment)               echo "-metadata comment=$value" ;;
			composer)              echo "-metadata composer=$value" ;;
			copyright)             echo "-metadata copyright=$value" ;;
			encoder|encoding)      continue ;;
			genre)                 echo "-metadata genre=$value" ;;
			isrc)                  echo "-metadata isrc=$value" ;;
			media|disc)
				case "$value" in
					[0-9]*)
						if [ -n "$totalDiscs" ]; then
							printf -- '-metadata disc=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalDiscs"
						else
							printf -- '-metadata disc=%g\n' "$( getTrackOrDiscNumber "$value" )"
						fi
						;;
				esac
				;;
			title)                 echo "-metadata title=$value" ;;
			track)
				if [ -n "$totalTracks" ]; then
					printf -- '-metadata track=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalTracks"
				else
					printf '-metadata track=%g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			year)                  printf -- '-metadata date=%.4s\n' "$value" ;;
			cdec|encoding*|itunnorm|itunsmpb|tool) continue ;;
			*) continue ;;
		esac
	done < "$sourceTagFile"
}

genTagFilter () {
	local taglist="$1" translations search match

	translations="@albumartist@,@album artist@
@date@,@year@
@description@,@comment@
@discnumber@,@disc@
@disctotal@,@totaldiscs@
@labelno@,@catalog@
@location@,@record location@
@organization@,@label@
@sourcemedia@,@media@
@tracknumber@,@track@
@tracktotal@,@totaltracks@"

	ereg="^${taglist//,/=|^}="
	search="@${taglist//,/@,@}@"
	OIFS="$IFS"; IFS=','
	for w in $search; do
		match="$( echo "$translations" | grep -Fi "$w" 2>/dev/null )"
		if [ -n "$match" ]; then
			match="${match//@/}"; match="${match//,/=|^}"
			ereg="${ereg}|^${match}="
		fi
	done
	IFS="$OIFS"
}

processSourceTagFile () {
	local firstLine=true nChars=0

	test -e "$sourceTagFile" || return

	# process multi-line tags
	while read line; do
		if [ "$line" != "${line%%=*}" ]; then # new field
			if [ $firstLine = true ]; then
				firstLine=false
				echo -n "$line"
			else
				echo -en "\n${line}"
			fi
		else # multi-line tag
			echo -n "§${line}"
		fi
	done < "$sourceTagFile" > "${sourceTagFile}.tmp"
	mv "${sourceTagFile}.tmp" "$sourceTagFile"
	nChars="$( cat "$sourceTagFile" | wc -m | tr -d ' ' )"
	if [ $nChars -gt 0 ]; then
		if [ $gnused = true ]; then
			$sedcmd -i'' -e 's@crc=@CRC32=@i' "$sourceTagFile" >/dev/null 2>&1
		else
			$sedcmd -i '' -e 's@crc=@CRC32=@i' "$sourceTagFile" >/dev/null 2>&1
		fi
		echo >> "$sourceTagFile"
	fi

	if [ -n "$outputCodecs" ]; then
		# white/blacklists
		if [ -n "$tagWhitelist" ]; then
			genTagFilter "$tagWhitelist"
			grep -iE "$ereg" "$sourceTagFile" > "${sourceTagFile}.tmp"
			mv "${sourceTagFile}.tmp" "$sourceTagFile"
		elif [ -n "$tagBlacklist" ]; then
			genTagFilter "$tagBlacklist"
			grep -viE "$ereg" "$sourceTagFile" > "${sourceTagFile}.tmp"
			mv "${sourceTagFile}.tmp" "$sourceTagFile"
		fi

		if isWavProcessed ; then
			ereg='^sourcecrc32=|^sourcemd5=|^sourcesha1=|^crc32=|^md5=|^sha1=|^µµµcrc32=|^µµµmd5=|^µµµsha1='
			grep -viE "$ereg" "$sourceTagFile" > "${sourceTagFile}.tmp" # purge former hash tags
			mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
		fi

		for h in $hashes; do
			case "$h" in
				CRC32)
					if [ -f "$sourceCRC32File" ]; then
						grep -viE "^SOURCECRC32=" "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
						cat "$sourceCRC32File" >> "$sourceTagFile"
					fi
					if [ -f "$losslessCRC32File" ]; then
						grep -viE "^CRC32=" "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
						cat "$losslessCRC32File" >> "$sourceTagFile"
					fi
					;;

				MD5)
					if [ -f "$sourceMD5File" ]; then
						grep -viE "^SOURCEMD5=" "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
						cat "$sourceMD5File" >> "$sourceTagFile"
					fi
					if [ -f "$losslessMD5File" ]; then
						grep -viE "^MD5=" "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
						cat "$losslessMD5File" >> "$sourceTagFile"
					fi
					;;

				SHA1)
					if [ -f "$sourceSHA1File" ]; then
						grep -viE "^SOURCESHA1=" "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
						cat "$sourceSHA1File" >> "$sourceTagFile"
					fi
					if [ -f "$losslessSHA1File" ]; then
						grep -viE "^SHA1=" "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
						cat "$losslessSHA1File" >> "$sourceTagFile"
					fi
					;;

				SHA256)
					if [ -f "$sourceSHA256File" ]; then
						grep -viE "^SOURCESHA256=" "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
						cat "$sourceSHA256File" >> "$sourceTagFile"
					fi
					if [ -f "$losslessSHA256File" ]; then
						grep -viE "^SHA256=" "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
						cat "$losslessSHA256File" >> "$sourceTagFile"
					fi
					;;

				SHA512)
					if [ -f "$sourceSHA512File" ]; then
						grep -viE "^SOURCESHA512=" "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
						cat "$sourceSHA512File" >> "$sourceTagFile"
					fi
					if [ -f "$losslessSHA512File" ]; then
						grep -viE "^SHA512=" "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
						cat "$losslessSHA512File" >> "$sourceTagFile"
					fi
					;;
			esac
		done
	fi
}

sanitizeApeTags () {
	local field lastField value lastValue first=true

	# transform duplicate fields into unique multi-value fields
	while read line; do
		lastField="$field" lastValue="$value"
		field="$( echo "${line%%=*}" | tr '[:upper:]' '[:lower:]' 2>/dev/null )"
		value="${line#*=}"
		if [ "$field" != "$lastField" ]; then
			if [ "$first" = "true" ]; then
				echo -en "${line}"
				first=false
			else
				echo -en "\n${line}"
			fi
		elif [ "$value" != "$lastValue" ]; then
			echo -n '\\x01'
			echo -n "$value"
		fi
	done < <( sort -u "$destTagFile" 2>/dev/null ) > "${destTagFile}.tmp"
	if [ -f "${destTagFile}.tmp" ]; then
		if [ "$OS" = "Linux" ]; then
			destTagFileSize=$( stat -f %s "${destTagFile}.tmp" )
		else
			destTagFileSize=$( stat -f %z "${destTagFile}.tmp" )
		fi
		if [ $destTagFileSize -gt 0 ]; then
			echo -en "\n" >> "${destTagFile}.tmp"
		fi
		rm -f "$destTagFile" >/dev/null 2>&1
		mv "${destTagFile}.tmp" "$destTagFile" >/dev/null 2>&1
	fi
}

convertTags () {
	destTagFile="${TDIR}/${index}.${2}.txt"
	test -e "$sourceTagFile" || return
	test -e "$destTagFile" && return
	shopt -qs nocasematch
	case $1 in
		vc)
			case $2 in
				vc)
					if [ -n "$outputCodecs" ]; then
						grep -viE '^encoder=|^encoding=' "$sourceTagFile" > "$destTagFile"
					else
						cp "$sourceTagFile" "$destTagFile" >/dev/null 2>&1
					fi
					;;

				ape) vorbisCommentsToAPEv2 > "$destTagFile" ;;
				mp3) vorbisCommentsToEyeD3 > "$destTagFile" ;;
				m4a) vorbisCommentsToM4A > "$destTagFile" ;;
			esac ;;

		ape)
			case $2 in
				ape)
					if [ -n "$outputCodecs" ]; then
						grep -viE '^encoder=|^encoding=' "$sourceTagFile" > "$destTagFile"
					else
						cp "$sourceTagFile" "$destTagFile" >/dev/null 2>&1
					fi
					;;

				vc) APEv2ToVorbisComments > "$destTagFile" ;;
				mp3) APEv2ToEyeD3 > "$destTagFile" ;;
				m4a) APEv2ToM4A > "$destTagFile" ;;

			esac
			case $2 in
				vc|mp3)
					if [ $gnused = true ]; then
						$sedcmd -i'' -e 's@\x02@ / @g' -e 's@^ro:@@' "$destTagFile"
					else
						$sedcmd -i '' -e 's@\x02@ / @g' -e 's@^ro:@@' "$destTagFile"
					fi
					;;
			esac
			;;

		m4a)
			case $2 in
				m4a)
					if [ -n "$outputCodecs" ]; then
						grep -viE '^encoder=|^encoding=' "$sourceTagFile" > "$destTagFile"
					else
						cp "$sourceTagFile" "$destTagFile" >/dev/null 2>&1
					fi
					;;

				ape) M4AToAPEv2 > "$destTagFile" ;;
				mp3) M4AToEyeD3 > "$destTagFile" ;;
				vc) M4AToVorbisComments > "$destTagFile" ;;
			esac ;;
	esac

	case "$destTagFile" in
		*.ape.txt) sanitizeApeTags ;;
	esac
	shopt -qu nocasematch
}

extractFlacArtwork () {
	local blockNumber withinPictureBlock=false picType picNumber=0 picExt description pattern ec=$Ex_Ok

	for outputCodec in $outputCodecs; do
		case "$outputCodec" in
			OggVorbis) continue ;; # unsupported formats
		esac
		pattern="x${outputCodec}Y"
		if [ "$preserveMetadata" != "${preserveMetadata//$pattern/@}" ]; then
			metaflac --list "$copyFile" 2>> "$errorLogFile" | grep -vE '[0-9A-F]{8}:' > "${TDIR}/${index}.flist" 2>/dev/null
			if [ $gnused = true ]; then
				$sedcmd -i'' -e 's@METADATA block #@\nMETADATA block #@' "${TDIR}/${index}.flist" # binary data can screw up the 'METADATA block #' line
			else
				$sedcmd -i '' -e 's@METADATA block #@\nMETADATA block #@' "${TDIR}/${index}.flist" # binary data can screw up the 'METADATA block #' line
			fi
			while read line; do
				if [ "${line:0:16}" = 'METADATA block #' ]; then
					blockNumber="${line#*#}"
				elif [ "$line" = 'type: 6 (PICTURE)' ]; then
					withinPictureBlock=true
				elif [ "${line:0:5}" = 'type:' -a $withinPictureBlock = true ]; then
					picType="${line#* }" ; picType="${picType%% *}"
				elif [ "${line:0:10}" = 'MIME type:' -a $withinPictureBlock = true ]; then
					case "$line" in
						'MIME type: image/jpeg') picExt='jpg' ;;
						'MIME type: image/png') picExt='png' ;;
						'MIME type: image/gif') picExt='gif' ;;
					esac
				elif [ "${line:0:12}" = 'description:' -a $withinPictureBlock = true ]; then
					description="${line/description: /}"
					if [ "$description" != 'description:' ]; then
						echo "$description" > "${SWAPDIR}/picture-${index}-${picNumber}.txt"
					fi
					metaflac --block-number=$blockNumber --export-picture-to="${SWAPDIR}/picture-${index}-${picNumber}_${picType}.${picExt}" "$copyFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
					if [ $ec -eq $Ex_Ok ]; then
						((picNumber++))
					else
						rm -rf "${SWAPDIR}/picture-${index}-${picNumber}_${picType}.${picExt}" "${SWAPDIR}/picture-${index}-${picNumber}.txt" >/dev/null 2>> "$errorLogFile"
					fi
					withinPictureBlock=false
				fi
			done < "${TDIR}/${index}.flist"
			rm -f "${TDIR}/${index}.flist" >/dev/null 2>&1
			return $ec
		fi
	done
	return $ec
}

extractAPEv2Artwork () {
	local picNumber=0 picExt='' picType=0 picTypeText='' pattern ec=$Ex_Ok otherType='' argString='' fieldName=''

	for outputCodec in $outputCodecs; do
		case "$outputCodec" in
			OggVorbis) continue ;; # unsupported formats
		esac
		pattern="x${outputCodec}Y"
		if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then continue; fi

		for fieldName in 'other' 'icon' 'other icon' 'front' 'back' 'leaflet' 'media' 'lead artist' 'artist' 'conductor' 'band' 'composer' 'lyricist' 'recording location' 'during recording' 'during performance' 'video' 'a bright colored fish' 'illustration' 'band logo' 'publisher logo'; do
			argString="${argString}\\x00-d\\x00cover art (${fieldName})=${SWAPDIR}/picture-${index}-${picNumber}_${picType}."
			((picType++))
			((picNumber++))
		done
		echo -en "-z${argString}\x00${copyFile}" | xargs -0 APEv2 >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
		return $ec
	done
	return $ec
}

extractAPEv2Binaries () {
	local pattern ec=$Ex_Ok argString='' fieldName='' b=0

	for outputCodec in $outputCodecs; do
		case "$outputCodec" in
			MonkeysAudio|WavPack*|lossyWV)
				pattern="x${outputCodec}Y"
				if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then continue; fi

				if [ ! -d "$apeBinariesDir" ]; then mkdir -p "$apeBinariesDir" >/dev/null 2>&1 ; fi
				while read fieldName; do
					echo "$fieldName" > "${apeBinariesDir}/${b}.txt" 2>/dev/null
					argString="${argString}\\x00-d\\x00${fieldName}=${apeBinariesDir}/${b}.bin"
					((b++))
				done < <( APEv2 -z "$copyFile" 2>/dev/null | grep -F '=data:' 2>/dev/null | cut -d '=' -f 1 2>/dev/null )

				if [ -n "$argString" ]; then
					echo -en "-z${argString}\x00${copyFile}" | xargs -0 APEv2 >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				fi
				return $ec
				;;

			*) continue ;;
		esac
	done
	return $ec
}

importCoverArt () {
	local ec=$Ex_Ok userSpecifiedArtwork

	for f in "${SWAPDIR}/picture-3-"*_*; do
		userSpecifiedArtwork="$( getCodecCoverArtFile "$outputCodec" )"
		if [ -n $userSpecifiedArtwork ]; then
			userSpecifiedArtwork="${sourceDirname}/${userSpecifiedArtwork}"
			if [ -f "$userSpecifiedArtwork" -a -r "$userSpecifiedArtwork" ]; then
				echo "" > "${SWAPDIR}/picture-${index}-3.txt"
				picExt="${userSpecifiedArtwork##*.}"
				picType=3
				swapFilePath="${SWAPDIR}/picture-${index}-0_${picType}.${picExt}"
				rm -f "$swapFilePath" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				if [ $ec -eq $Ex_Ok ]; then
					cp -f "$userSpecifiedArtwork" "$swapFilePath" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				fi
			fi
		fi
	done

	return $ec
}

importArtworkIntoFLAC () {
	local ec=$Ex_Ok picBasename="" picType picExt description='' descFile='' swapFilePath pattern

	pattern="x${outputCodec}Y"
	if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then
		return $Ex_Ok
	fi

	importCoverArt || ec=$Ex_Ko

	for f in "${SWAPDIR}/picture-${index}-"*_*; do
		if [ ! -e "$f" ]; then
			continue
		fi
		picBasename="$( basename "$f" )"
		picType="${picBasename#*_}"; picType="${picType%.*}"; descFile="${f%_*}.txt"
		description=''
		if [ -f "$descFile" ]; then
			description="$( cat "$descFile" 2>> "$errorLogFile" )"; description="${description//|//}" # replace | with /
		fi
		metaflac --import-picture-from="${picType}||${description}||${f}" "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
	done
	return $ec
}

genOpusArtworkCommandLine () {
	local ec=$Ex_Ok picBasename="" picType description='' descFile='' pattern cmdline=''

	pattern="x${outputCodec}Y"
	if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then
		echo "$cmdline"
		return 0
	fi

	importCoverArt || ec=$Ex_Ko

	for f in "${SWAPDIR}/picture-${index}-"*_*; do
		if [ ! -e "$f" ]; then continue; fi
		picBasename="$( basename "$f" )"
		picType="${picBasename#*_}"; picType="${picType%.*}"; descFile="${f%_*}.txt"
		description=''
		if [ -f "$descFile" ]; then
			description="$( cat "$descFile" 2>> "$errorLogFile" )"; description="${description//|//}" # replace | with /
		fi
		cmdline="${cmdline}\x00--picture=${picType}||${description}||${f}"
	done
	echo "$cmdline"
	return 0
}

importArtworkIntoAPEv2 () {
	local ec=$Ex_Ok picBasename="" picType picTypeText pattern af='' argString='' lastPicType=''

	pattern="x${outputCodec}Y"
	if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then
		return $Ex_Ok
	fi

	importCoverArt || ec=$Ex_Ko

	for f in "${SWAPDIR}/picture-${index}-"*_*; do
		if [ ! -e "$f" ]; then continue; fi
		picBasename="$( basename "$f" )"
		picType="${picBasename#*_}"; picType="${picType%.*}"
		if [ "$lastPicType" = "$picType" ]; then
			continue
		fi
		lastPicType="$picType"
		case "$picType" in
			0) picTypeText='other' ;;
			1) picTypeText='icon' ;;
			2) picTypeText='other icon' ;;
			3) picTypeText='front' ;;
			4) picTypeText='back' ;;
			5) picTypeText='leaflet' ;;
			6) picTypeText='media' ;;
			7) picTypeText='lead artist' ;;
			8) picTypeText='artist' ;;
			9) picTypeText='conductor' ;;
			10) picTypeText='band' ;;
			11) picTypeText='composer' ;;
			12) picTypeText='lyricist' ;;
			13) picTypeText='recording location' ;;
			14) picTypeText='during recording' ;;
			15) picTypeText='during performance' ;;
			16) picTypeText='video' ;;
			17) picTypeText='a bright colored fish' ;;
			18) picTypeText='illustration' ;;
			19) picTypeText='band logo' ;;
			20) picTypeText='publisher logo' ;;
		esac
		argString="${argString}\\x00-a\\x00Cover Art (${picTypeText})=${f}"
	done

	if [ -n "$argString" ]; then
		echo -en "-z${argString}\x00${encodedFile}" | xargs -0 APEv2 >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
	fi

	return $ec
}

importBinariesIntoAPEv2 () {
	local ec=$Ex_Ok pattern argString='' fieldName='' bf=''

	if [ ! -d "$apeBinariesDir" ]; then return $Ex_Ok; fi

	pattern="x${outputCodec}Y"
	if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then
		return $Ex_Ok
	fi

	for bf in "${apeBinariesDir}"/*.txt; do
		if [ ! -e "$bf" ]; then continue; fi
		fieldName="$( cat "$bf" )"
		argString="${argString}\\x00-b\\x00${fieldName}=${bf/.txt/.bin}"
	done

	if [ -n "$argString" ]; then
		echo -en "-z${argString}\x00${encodedFile}" | xargs -0 APEv2 >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
	fi

	return $ec
}

importArtworkIntoMP3 () {
	local ec=$Ex_Ok picBasename="" picType picTypeText pattern descFile description='' n=0

	pattern="x${outputCodec}Y"
	if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then
		return $Ex_Ok
	fi

	importCoverArt || ec=$Ex_Ko

	which 'eyeD3' >/dev/null 2>&1 || return $Ex_Ok
	for f in "${SWAPDIR}/picture-${index}-"*_*; do
		if [ ! -e "$f" ]; then continue; fi
		((n++))
		picBasename="$( basename "$f" )"
		picType="${picBasename#*_}"; picType="${picType%.*}"; descFile="${f%_*}.txt"
		case $picType in
			0) picTypeText='OTHER' ;;
			1) picTypeText='ICON' ;;
			2) picTypeText='OTHER_ICON' ;;
			3) picTypeText='FRONT_COVER' ;;
			4) picTypeText='BACK_COVER' ;;
			5) picTypeText='LEAFLET' ;;
			6) picTypeText='MEDIA' ;;
			7) picTypeText='LEAD_ARTIST' ;;
			8) picTypeText='ARTIST' ;;
			9) picTypeText='CONDUCTOR' ;;
			10) picTypeText='BAND' ;;
			11) picTypeText='COMPOSER' ;;
			12) picTypeText='LYRICIST' ;;
			13) picTypeText='RECORDING_LOCATION' ;;
			14) picTypeText='DURING_RECORDING' ;;
			15) picTypeText='DURING_PERFORMANCE' ;;
			16) picTypeText='VIDEO' ;;
			17) picTypeText='BRIGHT_COLORED_FISH' ;;
			18) picTypeText='ILLUSTRATION' ;;
			19) picTypeText='BAND_LOGO' ;;
			20) picTypeText='PUBLISHER_LOGO' ;;
			*) continue ;;
		esac
		description=''
		if [ -f "$descFile" ]; then
			description="$( cat "$descFile" 2>> "$errorLogFile" )"; description="${description//|//}" # replace | with /
		fi
		if [ -z "$description" ]; then
			description="${picTypeText}_${n}" # add a number to make it unique
		fi
		eyeD3 --quiet --to-v2.4 --add-image="${f}:${picTypeText}:${description}" "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
	done
	return $ec
}

computeCRC32 () {
	local hfile="$1" fifo dgst wtype='' earg=''

	wtype="$( soxi -e "$wavFile" 2>/dev/null )"
	if [ "$wtype" = 'Floating Point PCM' ]; then
		earg='-e unsigned-integer -b 16'
	fi

	fifo="${TDIR}/${index}.fifo"
	if [ ! -e "$fifo" ]; then mkfifo "$fifo" >/dev/null 2>> "$errorLogFile" ; fi
	sox $earg "$hfile" -t raw "$fifo" 2>> "$errorLogFile" &
	dgst="$( cksfv -b "$fifo" 2>> "$errorLogFile" | grep -Fv ';' )"
	dgst="${dgst##* }"
	if [ -n "$dgst" ]; then
		echo -n "${dgst##* }"
	fi
}

computeMD5 () {
	local wavFile="$1" dgst wtype='' earg=''

	wtype="$( soxi -e "$wavFile" 2>/dev/null )"
	if [ "$wtype" = 'Floating Point PCM' ]; then
		earg='-e unsigned-integer -b 16' # courtesy of David Bryant, author of WavPack
	fi

	if [ "$OS" = 'Linux' ]; then
		dgst="$( sox $earg "$wavFile" -t raw - 2>> "$errorLogFile" | md5sum - 2>> "$errorLogFile" )"
	else
		dgst="$( sox $earg "$wavFile" -t raw - 2>> "$errorLogFile" | md5 -q - 2>> "$errorLogFile" )"
	fi
	dgst="${dgst%% *}"
	if [ -n "$dgst" ]; then
		echo -n "$dgst"
	fi
}

computeSHA () {
	local wavFile="$1" hashtype="$2" hashvar='' dgst wtype='' earg=''

	wtype="$( soxi -e "$wavFile" 2>/dev/null )"
	if [ "$wtype" = 'Floating Point PCM' ]; then
		earg='-e unsigned-integer -b 16'
	fi

	if [ "$OS" = 'Linux' ]; then
		case "$hashtype" in
			SHA1) hashvar='sha1sum' ;;
			SHA256) hashvar='sha256sum' ;;
			SHA512) hashvar='sha512sum' ;;
		esac
	else
		case "$hashtype" in
			SHA1) hashvar='1' ;;
			SHA256) hashvar='256' ;;
			SHA512) hashvar='512' ;;
		esac
	fi

	if [ "$OS" = 'Linux' ]; then
		dgst="$( sox $earg "$wavFile" -t raw - 2>> "$errorLogFile" | $hashvar - 2>> "$errorLogFile" )"
	else
		dgst="$( sox $earg "$wavFile" -t raw - 2>> "$errorLogFile" | shasum -a $hashvar - 2>> "$errorLogFile" )"
	fi
	dgst="${dgst%% *}"
	if [ -n "$dgst" ]; then
		echo -n "$dgst"
	fi
}

getDownmixFactors () {
	local divider="$1"

	fv="$( echo "scale=5; 1 / $divider" | bc )"
	fv="$( printf "%.4f" "$fv" )"

	pv="$( echo "scale=5; (1 / sqrt(2)) / $divider" | bc )"
	pv="$( printf "%.4f" "$pv" )"

	hv="$( echo "scale=5; 0.5 / $divider" | bc )"
	hv="$( printf "%.4f" "$hv" )"
}

upmixToStereo () {
	local ec=$Ex_Ok

	sox $soxGuard -M "$wavFile" "$wavFile" $bitdepthcmd -c 2 "$resampledWavFile" $gaincmd $ratecmd $dithercmd >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko

	if [ $ec -eq $Ex_Ok -a -f "$resampledWavFile" ]; then
		mv -f "$resampledWavFile" "$wavFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
		if [ $ec -eq $Ex_Ok ]; then
			isWavProcessed 'true'
		fi
	fi
	if [ -e "$resampledWavFile" ]; then rm -f "$resampledWavFile"; fi
	return $ec
}

downmixToStereo () {
	local ec=$Ex_Ok surroundConfig='' fv='' pv='' hv=''

	# The following channel mappings have been thoroughly tested and should never clip, even in worst-case scenarios
	# Front ($fv): factor 1, LFE ($hv): factor 0.5 (1/2), everything else ($pv): factor 0.7071 (1 / sqrt(2))
	# http://www.academia.edu/2397757/A_downmix_approach
	case "$nChannels" in
		3) # FL, FR, LFE
			surroundConfig='2.1'
			getDownmixFactors '1.55'
			sox $soxGuard "$wavFile" $bitdepthcmd "$resampledWavFile" $ratecmd remix -m 1v${fv},3v${hv} 2v${fv},3v${hv} $dithercmd >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			;;

		4) # FL, FR, SL, SR
			surroundConfig='4.0'
			getDownmixFactors '1.75'
			sox $soxGuard "$wavFile" $bitdepthcmd "$resampledWavFile" $ratecmd remix -m 1v${fv},3v${pv} 2v${fv},4v${pv} $dithercmd >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			;;

		5) # FL, FR, C, SL, SR
			surroundConfig='5.0'
			getDownmixFactors '2.5'
			sox $soxGuard "$wavFile" $bitdepthcmd "$resampledWavFile" $ratecmd remix -m 1v${fv},3v${pv},4v${pv} 2v${fv},3v${pv},5v${pv} $dithercmd >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			;;

		6) # FL, FR, C, LFE, SL, SR
			surroundConfig='5.1'
			getDownmixFactors '3'
			sox $soxGuard "$wavFile" $bitdepthcmd "$resampledWavFile" $ratecmd remix -m 1v${fv},3v${pv},4v${hv},5v${pv} 2v${fv},3v${pv},4v${hv},6v${pv} $dithercmd >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			;;

		8) # FL, FR, C, LFE, SL, SR, BL, BR
			surroundConfig='7.1'
			getDownmixFactors '3.75'
			sox $soxGuard "$wavFile" $bitdepthcmd "$resampledWavFile" $ratecmd remix -m 1v${fv},3v${pv},4v${hv},5v${pv},7v${pv} 2v${fv},3v${pv},4v${hv},6v${pv},8v${pv} $dithercmd >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			;;

		*) return $Ex_Ok ;; # nothing to do
	esac

	unset fv pv hv

	if [ $ec -eq $Ex_Ok -a -f "$resampledWavFile" ]; then
		mv -f "$resampledWavFile" "$wavFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
		if [ $ec -eq $Ex_Ok ]; then
			isWavProcessed 'true'
		fi
	fi
	if [ -e "$resampledWavFile" ]; then rm -f "$resampledWavFile"; fi
	return $ec
}

isWavProcessed () {
	local val="$1"

	if [ -z "$wavProcessedStatusFile" ]; then
		wavProcessed='false'
	else
		if [ "$val" = "true" ]; then
			if [ ! -e "$wavProcessedStatusFile" ]; then
				touch "$wavProcessedStatusFile"
			fi
			wavProcessed='true'
		elif [ "$val" = "false" ]; then
			if [ -e "$wavProcessedStatusFile" ]; then
				rm -f "$wavProcessedStatusFile" >/dev/null 2>&1
			fi
			wavProcessed='false'
		else
			if [ -e "$wavProcessedStatusFile" ]; then
				wavProcessed='true'
			else
				wavProcessed='false'
			fi
		fi
	fi

	if [ "$wavProcessed" = "true" ]; then
		return $Ex_Ok
	else
		return $Ex_Ko
	fi
}

decode () {
	local ec=$Ex_Ok sourceTagFormat hline
	local soxGuard='' sourceMD5='' kfm='' nChannels=2 gaincmd='' ratecmd='' bitdepthcmd='' dithercmd='' gainPeak=''

	isWavProcessed 'false'
	if [ -e "$copyFile" ]; then
		case "$sourceExtension" in
			wav)
				sourceTagFormat='vc'
				mv "$copyFile" "$wavFile" >/dev/null 2>&1 || ec=$Ex_Ko
				touch "$sourceTagFile"
				;;

			aiff|caf)
				sourceTagFormat='vc'
				sox "$copyFile" -t wav "$wavFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				touch "$sourceTagFile"
				;;

			flac)
				sourceTagFormat='vc'
				getInternalMD5 "$copyFile"
				if [ $keepWavMetadata = true ]; then
					if ! flac -s -d --keep-foreign-metadata -o "$wavFile" "$copyFile" >/dev/null 2>&1; then
						if [ -e "$wavFile" ]; then rm -f "$wavFile"; fi
						flac -s -d -o "$wavFile" "$copyFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
					fi
				else
					flac -s -d -o "$wavFile" "$copyFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				fi
				if [ $ec -eq $Ex_Ok ]; then
					metaflac --no-utf8-convert --export-tags-to="$sourceTagFile" "$copyFile" >/dev/null 2>> "$errorLogFile" &&
					extractFlacArtwork || ec=$Ex_Ko
					if [ -e "$sourceTagFile" ]; then
						grep -iv 'WAVEFORMATEXTENSIBLE_CHANNEL_MASK=' "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv "${sourceTagFile}.tmp" "$sourceTagFile"
					fi
				fi
				;;

			wv)
				sourceTagFormat='ape' kfm='-w'
				getInternalMD5 "$copyFile"
				if [ $keepWavMetadata = true ]; then kfm='' ; fi
				nThreads=$( getNumberOfAvailableThreads $index $WavPack_Max_Threads )
				wvunpack -q $kfm -m --threads=$nThreads -o "$wavFile" "$copyFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				if [ $ec -eq $Ex_Ok ]; then
					APEv2 -z "$copyFile" 2>> "$errorLogFile" | grep -vE '(=data:)|(=artwork:)' | $sedcmd -e 's@\\n@\n@g' -e 's@\\x00@\x02@g' > "$sourceTagFile" 2>/dev/null
					extractAPEv2Binaries
					extractAPEv2Artwork
				fi
				;;

			ape)
				sourceTagFormat='ape'
				nThreads=$( getNumberOfAvailableThreads $index )
				mac "$copyFile" "$wavFile" -d -threads=$nThreads >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				if [ $ec -eq $Ex_Ok ]; then
					APEv2 -z "$copyFile" 2>> "$errorLogFile" | grep -vE '(=data:)|(=artwork:)' | $sedcmd -e 's@\\n@\n@g' -e 's@\\x00@\x02@g' > "$sourceTagFile" 2>/dev/null
					extractAPEv2Binaries
					extractAPEv2Artwork
				fi
				;;

			m4a)
				sourceTagFormat='m4a'
				nThreads=$( getNumberOfAvailableThreads $index )
				ffmpeg -i "$copyFile" -threads ${nThreads} "$wavFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				if [ $ec -eq $Ex_Ok ]; then
					ffmpeg -i "$copyFile" -f ffmetadata "$sourceTagFile" 2>> "$errorLogFile" || ec=$Ex_Ko
				fi
				;;

			*) ec=$Ex_Ko ;;
		esac

		if [ $sourceIsLossyWAV = true ]; then
			if [ ! -h "$lossywavFile" ]; then
				ln -s "${index}.wav" "$lossywavFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			fi
		fi
	else
		ec=$Ex_Ko
	fi

	if [ $ec -eq $Ex_Ok ]; then
		if [ -e "$copyFile" ]; then
			rm -f "$copyFile" "${copyFile}c"
		fi

		if [ -f "$sourceTagFile" ]; then
			if [ $gnused = true ]; then
				$sedcmd -i'' -e 's@SOURCEMD5=@µµµMD5=@i' -e 's@SOURCECRC32=@µµµCRC32=@i' -e 's@SOURCESHA1=@µµµSHA1=@i' -e 's@SOURCESHA256=@µµµSHA256=@i' -e 's@SOURCESHA512=@µµµSHA512=@i' "$sourceTagFile"
			else
				$sedcmd -i '' -e 's@SOURCEMD5=@µµµMD5=@i' -e 's@SOURCECRC32=@µµµCRC32=@i' -e 's@SOURCESHA1=@µµµSHA1=@i' -e 's@SOURCESHA256=@µµµSHA256=@i' -e 's@SOURCESHA512=@µµµSHA512=@i' "$sourceTagFile"
			fi
		fi

		gainValue='' gaincmd=''
		if [ $applyGain = true ]; then
			if [ "$applyGainType" = 'ALBUM' -o "$applyGainType" = 'TRACK' ]; then
				if [ "$applyGainType" = 'ALBUM' ]; then
					gainValue="$( grep -Fi 'replaygain_album_gain' "$sourceTagFile" 2>/dev/null | cut -d '=' -f 2 | cut -d ' ' -f 1 )"
				else
					gainValue="$( grep -Fi 'replaygain_track_gain' "$sourceTagFile" 2>/dev/null | cut -d '=' -f 2 | cut -d ' ' -f 1 )"
				fi
				if [ -n "$gainValue" ]; then
					if [ "${preamp:0:1}" = '-' ]; then
						gainValue="$( printf '%.2f' "$( echo "scale=5; ($gainValue - ${preamp:1}) / 1" | bc 2>> "$errorLogFile" )" )"
					elif [ "${preamp:0:1}" = '+' ]; then
						gainValue="$( printf '%.2f' "$( echo "scale=5; ($gainValue + ${preamp:1}) / 1" | bc 2>> "$errorLogFile" )" )"
					fi
					if [ "${gainValue:0:1}" != '-' -a "${gainValue:0:1}" != '+' ]; then
						gainValue="+${gainValue}"
					fi
				fi
			elif [ "$applyGainType" = 'ALBUM_PEAK' -o "$applyGainType" = 'TRACK_PEAK' ]; then
				if [ "$applyGainType" = 'ALBUM_PEAK' ]; then
					gainPeak="$( grep -Fi 'replaygain_album_peak' "$sourceTagFile" 2>/dev/null | cut -d '=' -f 2 )"
				elif [ "$applyGainType" = 'TRACK_PEAK' ]; then
					gainPeak="$( grep -Fi 'replaygain_track_peak' "$sourceTagFile" 2>/dev/null | cut -d '=' -f 2 )"
				fi
				if [ -n "$gainPeak" ]; then
					if [ "${gainPeak:0:1}" = '0' ]; then
						gainValue="$( computeGainFromPeak "$gainPeak" )"
						if [ "${gainValue:0:1}" != '-' ]; then # gainValue is positive
							if [ "${peakReference:0:1}" = '-' ]; then
								gainValue="${peakReference}"
							else
								gainValue=''
							fi
						else # gainValue is negative
							if [ "${peakReference:0:1}" = '-' ]; then
								gainValue="$( printf "%.2f" "$( echo "scale=5; (${gainValue:1} + ${peakReference}) / 1" | bc 2>> "$errorLogFile" )" )"
								if [ "${gainValue:0:1}" != '-' ]; then
									gainValue="+${gainValue}"
								fi
							else
								gainValue="+${gainValue:1}"
							fi
						fi
					elif [ "${peakReference:0:1}" = '-' ]; then
						gainValue="$peakReference"
					fi
				fi
			else
				gainValue="$applyGainType"
			fi

			if [ -n "$gainValue" ]; then
				gaincmd="gain $gainValue"
			fi
		fi

		if [ $applyGain = true -a -z "$gainValue" ]; then
			printMessage 'warning' 'processing' "file:${sourceFile}" $p "threads:1" "no gain value"
		fi

		nChannels=$( getNumberOfChannels "$wavFile" )
		if [ -z "$nChannels" -o "$nChannels" = '0' ]; then
			nChannels=2
		fi

		hasLossy=false hasLossless=false
		if [ -n "$gainValue" -o -n "$bitDepth" -o -n "$samplingRate" ]; then
			hasLossy=true
		elif [ "$convertToStereo" != 'false' -a $nChannels -ne 2 ]; then
			hasLossy=true
		fi
		for outputCodec in $outputCodecs; do
			case "$outputCodec" in
				lossy*|*Vorbis|Opus|WavPackLossy|MP3|AAC) hasLossy=true ;;
				FLAC|WavPack|WavPackHybrid|MonkeysAudio|ALAC) hasLossless=true ;;
			esac
		done

		if [ $hasLossy = true ]; then
			for h in $hashes; do
				case "$h" in
					CRC32)
						{
						hline="$( computeCRC32 "$wavFile" )"
						test -n "$hline" && echo "SOURCECRC32=${hline}" > "$sourceCRC32File"
						} & ;;

					MD5)
						{
						hline="$( computeMD5 "$wavFile" )"
						if [ -n "$hline" ]; then
							echo "SOURCEMD5=${hline}" > "$sourceMD5File"
							if [ -n "$sourceMD5" -a "$sourceMD5" != "$hline" ]; then
								printMessage 'warning' 'decoding' 'bad_internal_hash' $p "file:${sourceFile}" 'internal MD5 hash is incorrect (possible bug in the codec)!'
								printMessage 'info' 'decoding' 'stderr' 'Please file a bug report: https://github.com/gcocatre/caudec/issues'
							fi
						fi
						} & ;;

					SHA1)
						{
						hline="$( computeSHA "$wavFile" "$h" )"
						test -n "$hline" && echo "SOURCESHA1=${hline}" > "$sourceSHA1File"
						} & ;;

					SHA256)
						{
						hline="$( computeSHA "$wavFile" "$h" )"
						test -n "$hline" && echo "SOURCESHA256=${hline}" > "$sourceSHA256File"
						} & ;;

					SHA512)
						{
						hline="$( computeSHA "$wavFile" "$h" )"
						test -n "$hline" && echo "SOURCESHA512=${hline}" > "$sourceSHA512File"
						} & ;;
				esac
			done
			wait
		fi

		if [ $preventClipping = true ]; then
			soxGuard='-G'
		fi

		if [ -n "$bitDepth" ]; then
			bitdepthcmd="-b $bitDepth"
		fi

		if [ -n "$samplingRate" ]; then
			ratecmd="rate -v $samplingRate"
		fi

		if [ -n "$bitDepth" -o -n "$samplingRate" ]; then
			dithercmd='dither -a -s' # FL, FR, C, LFE, SL, SR, BL, BR; 1/4
		fi

		# convert to stereo (and at the same time, resample and / or apply gain if requested)
		if [ "$convertToStereo" != 'false' ]; then
			if [ $nChannels -gt 2 ]; then
				downmixToStereo || ec=$Ex_Io_Err
			elif [ $nChannels -eq 1 ]; then
				upmixToStereo || ec=$Ex_Io_Err
			fi
		fi

		# resample (and apply gain if requested) if not already done
		# make sure to test both wavProcessed != 'true' and ec = Ex_Ok, because wavProcessed will only be true if prior processing succeeded
		if [ $ec -eq $Ex_Ok -a "$wavProcessed" != 'true' ]; then # no prior processing, resampling has not yet be done
			if [ -n "$bitdepthcmd" -o -n "$ratecmd" ]; then
				sox $soxGuard "$wavFile" $bitdepthcmd "$resampledWavFile" $gaincmd $ratecmd $dithercmd >/dev/null 2>> "$errorLogFile" || ec=$Ex_Io_Err
				if [ $ec -eq $Ex_Ok -a -f "$resampledWavFile" ]; then
					mv -f "$resampledWavFile" "$wavFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Io_Err
					if [ $ec -eq $Ex_Ok ]; then
						isWavProcessed 'true'
					fi
				fi
				if [ -e "$resampledWavFile" ]; then rm -f "$resampledWavFile"; fi
			fi
		fi

		# apply gain if not already done
		if [ $ec -eq $Ex_Ok -a "$wavProcessed" != 'true' -a -n "$gaincmd" ]; then # no prior processing, gain has not yet been applied
			# debug "sox gaincmd=[$gaincmd]"
			sox $soxGuard "$wavFile" "$resampledWavFile" $gaincmd >/dev/null 2>> "$errorLogFile" || ec=$Ex_Io_Err
			if [ $ec -eq $Ex_Ok -a -f "$resampledWavFile" ]; then
				mv -f "$resampledWavFile" "$wavFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Io_Err
				if [ $ec -eq $Ex_Ok ]; then
					isWavProcessed 'true'
				fi
			fi
			if [ -e "$resampledWavFile" ]; then rm -f "$resampledWavFile"; fi
		fi
	fi

	if [ $ec -ne $Ex_Ok ]; then
		rm -f "$wavFile" "$copyFile" "${copyFile}c" "$lossywavFile" "$resampledWavFile" # in case it exists
		rm -f "${TDIR}/"*"_${index}" # delete all codec lock files
		rm -f "${TDIR}/"*"_${index}_WAV_NEEDED" # delete associated lock files
		if [ $ec -eq $Ex_Io_Err ]; then
			printMessage 'error' 'processing' "file:${sourceFile}" $p
		elif [ $ec -ne $Ex_Ok ]; then
			printMessage 'error' 'decoding' "file:${sourceFile}" $p
		fi
		return $Ex_Ko
	fi

	if [ $gnustat = true ]; then
		$statcmd -L --printf ' + %s' "$wavFile" >> "${TDIR}/bytes" 2>> "$errorLogFile"
	else
		$statcmd -L -n -f ' + %z' "$wavFile" >> "${TDIR}/bytes" 2>> "$errorLogFile"
	fi

	if [ $hasLossless = true ]; then
		for h in $hashes; do
			case "$h" in
				CRC32)
					if [ "$wavProcessed" != 'true' -a -f "$sourceCRC32File" ]; then
						$sedcmd -e 's@SOURCE@@' "$sourceCRC32File" > "$losslessCRC32File" 2>/dev/null
						hval="$( $sedcmd -e 's@SOURCE@@' "$sourceCRC32File" 2>/dev/null )"
						test -n "$hval" && printMessage 'info' "$h" "$hval" "file:${sourceFile}" $p
					else
						{
						hline="$( computeCRC32 "$wavFile" )"
						test -n "$hline" && echo "CRC32=${hline}" > "$losslessCRC32File"
						test -n "$hline" && printMessage 'info' "$h" "CRC32=$hline" "file:${sourceFile}" $p
						} &
					fi
					;;

				MD5)
					if [ "$wavProcessed" != 'true' -a -f "$sourceMD5File" ]; then
						$sedcmd -e 's@SOURCE@@' "$sourceMD5File" > "$losslessMD5File"
						hval="$( $sedcmd -e 's@SOURCE@@' "$sourceMD5File" 2>/dev/null )"
						test -n "$hval" && printMessage 'info' "$h" "$hval" "file:${sourceFile}" $p
					else
						{
						hline="$( computeMD5 "$wavFile" )"
						test -n "$hline" && printMessage 'info' "$h" "MD5=$hline" "file:${sourceFile}" $p
						if [ -n "$hline" ]; then
							echo "MD5=${hline}" > "$losslessMD5File"
							if [ "$wavProcessed" != 'true' -a -n "$sourceMD5" -a "$sourceMD5" != "$hline" ]; then
								printMessage 'warning' 'decoding' 'bad_internal_hash' $p "file:${sourceFile}" 'internal MD5 hash is incorrect (possible bug in the codec)!'
								printMessage 'info' 'decoding' 'stderr' 'Please file a bug report: https://github.com/gcocatre/caudec/issues'
							fi
						fi
						} &
					fi
					;;

				SHA1)
					if [ "$wavProcessed" != 'true' -a -f "$sourceSHA1File" ]; then
						$sedcmd -e 's@SOURCE@@' "$sourceSHA1File" > "$losslessSHA1File"
						hval="$( $sedcmd -e 's@SOURCE@@' "$sourceSHA1File" 2>/dev/null )"
						test -n "$hval" && printMessage 'info' "$h" "$hval" "file:${sourceFile}" $p
					else
						{
						hline="$( computeSHA "$wavFile" "$h" )"
						test -n "$hline" && echo "SHA1=${hline}" > "$losslessSHA1File"
						test -n "$hline" && printMessage 'info' "$h" "SHA1=$hline" "file:${sourceFile}" $p
						} &
					fi
					;;

				SHA256)
					if [ "$wavProcessed" != 'true' -a -f "$sourceSHA256File" ]; then
						$sedcmd -e 's@SOURCE@@' "$sourceSHA256File" > "$losslessSHA256File"
						hval="$( $sedcmd -e 's@SOURCE@@' "$sourceSHA256File" 2>/dev/null )"
						test -n "$hval" && printMessage 'info' "$h" "$hval" "file:${sourceFile}" $p
					else
						{
						hline="$( computeSHA "$wavFile" "$h" )"
						test -n "$hline" && echo "SHA256=${hline}" > "$losslessSHA256File"
						test -n "$hline" && printMessage 'info' "$h" "SHA256=$hline" "file:${sourceFile}" $p
						} &
					fi
					;;

				SHA512)
					if [ "$wavProcessed" != 'true' -a -f "$sourceSHA512File" ]; then
						$sedcmd -e 's@SOURCE@@' "$sourceSHA512File" > "$losslessSHA512File"
						hval="$( $sedcmd -e 's@SOURCE@@' "$sourceSHA512File" 2>/dev/null )"
						test -n "$hval" && printMessage 'info' "$h" "$hval" "file:${sourceFile}" $p
					else
						{
						hline="$( computeSHA "$wavFile" "$h" )"
						test -n "$hline" && echo "SHA512=${hline}" > "$losslessSHA512File"
						test -n "$hline" && printMessage 'info' "$h" "SHA512=$hline" "file:${sourceFile}" $p
						} &
					fi
					;;
			esac
		done
		wait
	fi

	processSourceTagFile

	for outputCodec in $outputCodecs; do
		case "$outputCodec" in
			FLAC|lossyFLAC|OggVorbis|Opus) convertTags $sourceTagFormat 'vc' ;;
			WavPack*|MonkeysAudio|lossyWV) convertTags $sourceTagFormat 'ape' ;;
			MP3) convertTags $sourceTagFormat 'mp3' ;;
			AAC|ALAC) convertTags $sourceTagFormat 'm4a' ;;
		esac
	done

	return $ec
}

encodeLossyWAV () {
	local ec=$Ex_Ok overwriteLossyWAV=true

	encodedFile="$lossywavFile"

	if [ $copyLossyWAV = true ]; then
		getFileProps "$sourceFile" 'lossyWAV'
		if [ $copyPath = "true" ]; then
			if ! mkdir -p "$destPath" >/dev/null 2>&1 ; then
				ec=$Ex_Ko
			fi
		fi
	fi

	if [ $ec -eq $Ex_Ok ]; then
		if [ ! -e "$lossywavFile" ]; then
			cd "$SWAPDIR"
			lossywav "${index}.wav" -q $compression_lossyWAV >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			cd "$OLDPWD"
		fi
	fi

	if [ $ec -eq $Ex_Ok ]; then
		for outputCodec in $outputCodecs; do
			case "$outputCodec" in
				lossyFLAC|lossyWV)
					for h in $hashes; do
						case $h in
							CRC32)
								hline="$( computeCRC32 "$lossywavFile" )"
								test -n "$hline" && echo "CRC32=$hline" > "$lossywavCRC32File"
								;;

							MD5)
								hline="$( computeMD5 "$lossywavFile" )"
								test -n "$hline" && echo "MD5=$hline" > "$lossywavMD5File"
								;;

							SHA1)
								hline="$( computeSHA "$lossywavFile" "$h" )"
								test -n "$hline" && echo "SHA1=$hline" > "$lossywavSHA1File"
								;;

							SHA256)
								hline="$( computeSHA "$lossywavFile" "$h" )"
								test -n "$hline" && echo "SHA256=$hline" > "$lossywavSHA256File"
								;;

							SHA512)
								hline="$( computeSHA "$lossywavFile" "$h" )"
								test -n "$hline" && echo "SHA512=$hline" > "$lossywavSHA512File"
								;;
						esac
					done
					break
					;;
			esac
		done

		if [ $copyLossyWAV = true ]; then
			overwriteLossyWAV=true
			if [ -e "$destFile" ]; then
				if [ $keepExistingFiles = true ]; then
					overwriteLossyWAV=false
				elif [ $keepNewerFiles = true ]; then
					if isFileNewer "$destFile" "$sourceFile"; then
						overwriteLossyWAV=false
					fi
				fi
			fi
			if [ $overwriteLossyWAV = true ]; then
				chmod 0644 "$encodedFile"
				rm -f "$destFile" >/dev/null 2>> "$errorLogFile"
				cp -a "$encodedFile" "$destFile" >/dev/null 2>> "$errorLogFile"
				printMessage 'success' 'encoding' $p "outputCodec:${outputCodec}" "file:${destFile}"
			fi
		fi
	else
		rm -f "$lossywavFile" # delete lossyWAV file if it exists
		rm -f "${TDIR}/lossy"*"_${index}" # delete all lossy* codec lock files
		rm -f "${TDIR}/"*"_${index}_LOSSYWAV_NEEDED" # delete associated codec lock files
		rm -f "${TDIR}/lossyWAV_${index}_WAV_NEEDED"
		printMessage 'error' 'encoding' $p "file:${sourceFile}"
	fi

	return $ec
}

getEncoderVersions () {
	local outputCodec oggencPath vorbisPrefix libvorbisVersion

	for outputCodec in $outputCodecs; do
		case "$outputCodec" in
			FLAC) flacVersion="$( flac --version | head -n 1 )"; flacVersion="${flacVersion##* }" ;;
			MonkeysAudio) apeVersion="$( mac 2>&1 | grep -F '(c)' | tr -d ' ' | cut -d '(' -f 2 | cut -d ')' -f 1 )"; apeVersion="${apeVersion#v}" ;;
			MP3) laSelf_Version="$( lame --version 2>/dev/null | grep -E 'LAME.*version' | cut -d 'v' -f 2 | cut -d '(' -f 1 | cut -d ' ' -f 2- )" ; laSelf_Version="${laSelf_Version% *}" ;;
			AAC) aacVersion="$( ffmpeg -version 2>/dev/null | grep -E '^ffmpeg version' | cut -d ' ' -f 3 )" ;;
			ALAC) alacVersion="$( ffmpeg -version 2>/dev/null | grep -E '^ffmpeg version' | cut -d ' ' -f 3 )" ;;
			Opus) opusVersion="$( opusenc --version 2>/dev/null | grep -F 'opusenc' )" ;;

			WavPack|WavPackHybrid|WavPackLossy)
				wavpackVersion="$( wavpack --version 2>/dev/null | head -n 1 )"
				wavpackVersion="${wavpackVersion##* }"
				;;

			lossy*)
				lossywavVersion="$( lossywav -v 2>/dev/null | grep -F 'lossyWAV' | tr -d '\r\n' )" # recent lossyWAV
				if [ -z "$lossywavVersion" ]; then
					lossywavVersion="$( lossywav -v 2>&1 | grep -F 'lossyWAV' | tr -d '\r\n' )" # old lossyWAV
				fi
				lossywavVersion="${lossywavVersion##* }"
				;;

			OggVorbis)
				oggencVersion="$( oggenc -V | tr -cd '0-9.' )"
				oggencPath="$( which oggenc )"
				vorbisPrefix="${oggencPath%/oggenc}"; vorbisPrefix="${vorbisPrefix%/bin}"
				if [ -f "${vorbisPrefix}/lib/pkgconfig/vorbisenc.pc" ]; then
					libvorbisVersion="$( grep -i 'version' "${vorbisPrefix}/lib/pkgconfig/vorbisenc.pc" | tr -cd '0-9.' )"
					oggencVersion="${oggencVersion}, libvorbis $libvorbisVersion"
				fi
				;;
		esac
	done
}

isFileNewer () {
	local fileA="$1" fileB="$2" mtimeA mtimeB

	# Don't use 'test -nt' because it doesn't work on files touched by 'caudec -T '
	if [ -e "$fileA" -a -e "$fileB" ]; then
		if [ $gnustat = true ]; then
			mtimeA="$( $statcmd -c '%Y' "$fileA" )"
			mtimeB="$( $statcmd -c '%Y' "$fileB" )"
		else
			mtimeA="$( $statcmd -f '%c' "$fileA" )"
			mtimeB="$( $statcmd -f '%c' "$fileB" )"
		fi
		if [ $mtimeA -gt $mtimeB ]; then
			return $Ex_Ok
		else
			return $Ex_Ko
		fi
	else
		return $Ex_Ok
	fi
}

areInodesDifferent () {
	local fileA="$1" fileB="$2" inodeA inodeB

	if [ -e "$fileA" -a -e "$fileB" ]; then
		inodeA="$( ls -i "$fileA" 2>/dev/null | cut -d " " -f 1 2>/dev/null )"
		inodeB="$( ls -i "$fileB" 2>/dev/null | cut -d " " -f 1 2>/dev/null )"
		if [ "$inodeA" != "$inodeB" ]; then
			return $Ex_Ok
		else
			return $Ex_Ko
		fi
	else
		return $Ex_Ok
	fi
}

copyOrLinkAllFiles () {
	local codec="$1" sourceDirFile otherFileBasename destOtherFile destOtherLinkedFile
	for sourceDirFile in "$sourceDirname"/*; do
		case "$sourceDirFile" in
			*.wav|*.caf|*.aiff|*.flac|*.wv|*.wvc|*.ape|*.ogg|*.mp3|*.m4a|*.opus) continue ;;
		esac
		if [ -f "$sourceDirFile" ]; then
			otherFileBasename="${sourceDirFile##*/}"
			destOtherFile="${destPath}/${otherFileBasename}"
			if [ "$codec" = "WavPackLossy" -a -n "$linkDir" ]; then
				destOtherLinkedFile="${destLinkPath}/${otherFileBasename}"
				if areInodesDifferent "$destOtherFile" "$destOtherLinkedFile"; then
					rm -f "$destOtherLinkedFile" >/dev/null 2>> "$errorLogFile" &&
					ln -f "$destOtherFile" "$destOtherLinkedFile" >/dev/null 2>> "$errorLogFile"
				fi
			else
				if isFileNewer "$sourceDirFile" "$destOtherFile"; then
					cp "$sourceDirFile" "$destOtherFile" >/dev/null 2>> "$errorLogFile"
				fi
			fi
		fi
	done
}

copyOrLinkCommaSeparatedFiles () {
	local codec="$1" pattern="$2" listOfOtherFiles otherFile extOtherFile otherFileBasename destOtherFile destOtherLinkedFile

	OIFS="$IFS"; IFS=','
	read -a listOfOtherFiles <<< "$pattern"
	for otherFile in "${listOfOtherFiles[@]}"; do
		case "$otherFile" in
			.*)
				for extOtherFile in "$sourceDirname"/*"$otherFile"; do
					if [ -f "$extOtherFile" ]; then
						otherFileBasename="${extOtherFile##*/}"
						destOtherFile="${destPath}/${otherFileBasename}"
						if [ "$codec" = "WavPackLossy" -a -n "$linkDir" ]; then
							destOtherLinkedFile="${destLinkPath}/${otherFileBasename}"
							if areInodesDifferent "$destOtherFile" "$destOtherLinkedFile"; then
								rm -f "$destOtherLinkedFile" >/dev/null 2>> "$errorLogFile" &&
								ln -f "$destOtherFile" "$destOtherLinkedFile" >/dev/null 2>> "$errorLogFile"
							fi
						else
							if isFileNewer "$extOtherFile" "$destOtherFile"; then
								cp "$extOtherFile" "$destOtherFile" >/dev/null 2>> "$errorLogFile"
							fi
						fi
					fi
				done
			;;

			*)
				if [ -f "${sourceDirname}/${otherFile}" ]; then
					destOtherFile="${destPath}/${otherFile}"
					if [ "$codec" = "WavPackLossy" -a -n "$linkDir" ]; then
						destOtherLinkedFile="${destLinkPath}/${destOtherFile}"
						if areInodesDifferent "$destOtherFile" "$destOtherLinkedFile"; then
							rm -f "$destOtherLinkedFile" >/dev/null 2>> "$errorLogFile" &&
							ln -f "$destOtherFile" "$destOtherLinkedFile" >/dev/null 2>> "$errorLogFile"
						fi
					else
						if isFileNewer "$extOtherFile" "$destOtherFile"; then
							cp "${sourceDirname}/${otherFile}" "$destOtherFile" >/dev/null 2>> "$errorLogFile"
						fi
					fi
				fi
			;;
		esac
	done
	IFS="$OIFS"
}

copyOrLinkFile () {
	local codec="$1" otherFile="$2" extOtherFile otherFileBasename destOtherFile destOtherLinkedFile

	case "$otherFile" in
		.*)
			for extOtherFile in "$sourceDirname"/*"$otherFile"; do
				if [ -f "$extOtherFile" ]; then
					otherFileBasename="${extOtherFile##*/}"
					destOtherFile="${destPath}/${otherFileBasename}"
					if [ "$codec" = "WavPackLossy" -a -n "$linkDir" ]; then
						destOtherLinkedFile="${destLinkPath}/${otherFileBasename}"
						if areInodesDifferent "$destOtherFile" "$destOtherLinkedFile"; then
							rm -f "$destOtherLinkedFile" >/dev/null 2>> "$errorLogFile" &&
							ln -f "$destOtherFile" "$destOtherLinkedFile" >/dev/null 2>> "$errorLogFile"
						fi
					else
						if isFileNewer "$extOtherFile" "$destOtherFile"; then
							cp "$extOtherFile" "$destOtherFile" >/dev/null 2>> "$errorLogFile"
						fi
					fi
				fi
			done
		;;

		*)
			if [ -f "${sourceDirname}/${otherFile}" ]; then
				destOtherFile="${destPath}/${otherFile}"
				if [ "$codec" = "WavPackLossy" -a -n "$linkDir" ]; then
					destOtherLinkedFile="${destLinkPath}/${otherFile}"
					if areInodesDifferent "$destOtherFile" "$destOtherLinkedFile"; then
						rm -f "$destOtherLinkedFile" >/dev/null 2>> "$errorLogFile" &&
						ln -f "$destOtherFile" "$destOtherLinkedFile" >/dev/null 2>> "$errorLogFile"
					fi
				else
					if isFileNewer "${sourceDirname}/${otherFile}" "$destOtherFile"; then
						cp "${sourceDirname}/${otherFile}" "$destOtherFile" >/dev/null 2>> "$errorLogFile"
					fi
				fi
			fi
		;;
	esac
}

copyOrLinkOtherFiles () {
	local codec="$1"

	pattern="$( getCodecOtherFiles "$codec" )"

	if [ -n "$pattern" ]; then
		case "$pattern" in
			all) copyOrLinkAllFiles "$codec" ;;
			*,*) copyOrLinkCommaSeparatedFiles "$codec" "$pattern" ;;
			*) copyOrLinkFile "$codec" "$pattern" ;;
		esac
	fi
}

encode () {
	local nDecodingThreads=$1 nThreads=1
	local ec=$Ex_Ok pattern="x${outputCodec}Y" kfm='' statusInfo='' nRunningProcesses listOfOtherFiles
	local audioFile otherFile otherFileBasename extOtherFile destOtherFile compressionTag='' nChannels
	local compression_param quality_arg

	getFileProps "$sourceFile" "$outputCodec"
	case "$outputCodec" in
		WAV)
			if [ $sourceIsLossyWAV = true ]; then
				destExtension='lossy.wav'; encodedFile="$lossywavFile"
			else
				destExtension='wav'; encodedFile="$wavFile"
			fi
			;;

		AIFF)
			destExtension='aiff'; encodedFile="${SWAPDIR}/${index}-${outputCodec}.${destExtension}"
			sox "$wavFile" "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			;;

		CAF)
			destExtension='caf'; encodedFile="${SWAPDIR}/${index}-${outputCodec}.${destExtension}"
			sox "$wavFile" "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			;;

		ALAC)
			destExtension='m4a'; encodedFile="${SWAPDIR}/${index}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${index}.m4a.txt"
			nThreads=$( getNumberOfAvailableThreads $index )
			if [ -z "$sourceCoverArtFile" ]; then
				for f in "${SWAPDIR}/picture-${index}-"*_*; do
					if [ ! -e "$f" ]; then continue; fi
					picType="${f#*_}"; picType="${picType%.*}"
					case $picType in
						3) sourceCoverArtFile="$f" ; break ;;
					esac
				done
			fi
			if [ -n "$sourceCoverArtFile" -a -e "$sourceCoverArtFile" ]; then
				printf -- "`tagline`\x00%s\x00%s" "$encodedFile" | xargs -0 ffmpeg -i "$wavFile" -threads ${nThreads} -i "$sourceCoverArtFile" -map 0:a -map 1 -codec copy -metadata:s:v title="Album cover" -metadata:s:v comment="Cover (front)" -disposition:v attached_pic -c:a alac >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			else
				printf -- "`tagline`\x00%s\x00%s" "$encodedFile" | xargs -0 ffmpeg -i "$wavFile" -threads ${nThreads} -c:a alac >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			fi
			;;

		FLAC)
			destExtension='flac'; encodedFile="${SWAPDIR}/${index}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${index}.vc.txt" kfm=''
			# Kohlrabi is a very cool dude
			if [ $keepWavMetadata = true ]; then kfm='--keep-foreign-metadata' ; fi
			if [ $tagCompressionSetting = true ]; then compressionTag="ENCODING=$Self_Name $Self_Version / FLAC $flacVersion / -$compression_FLAC"; fi
			nThreads=$( getNumberOfAvailableThreads $index $Flac_Max_Threads )
			printf -- "-s`tagline -T`\x00%s" "$wavFile" | xargs -0 flac -j $nThreads -P 4096 $kfm -${compression_FLAC} -o "$encodedFile" >/dev/null 2>> "$errorLogFile" &&
			importArtworkIntoFLAC || ec=$Ex_Ko
			;;

		MonkeysAudio)
			destExtension='ape'; encodedFile="${SWAPDIR}/${index}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${index}.ape.txt"
			nThreads=$( getNumberOfAvailableThreads $index )
			mac "$wavFile" "$encodedFile" -c${compression_MonkeysAudio}000 -threads=${nThreads} >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			if [ $ec -eq $Ex_Ok -a -f "$destTagFile" ]; then
				if [ $tagCompressionSetting = true ]; then compressionTag="Encoding=$Self_Name $Self_Version / Monkey's Audio $apeVersion / -c${compression_MonkeysAudio}000"; fi
				printf -- "-R`tagline -t`\x00%s" "$encodedFile" | xargs -0 APEv2 -z >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				importBinariesIntoAPEv2 || ec=$Ex_Ko
				importArtworkIntoAPEv2 || ec=$Ex_Ko
			fi
			;;

		WavPack)
			destExtension='wv'; encodedFile="${SWAPDIR}/${index}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${index}.ape.txt" kfm='-r'
			if [ -e "${destFile}c" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${destDir}" "$Self_Name -c wv: correction files are present. Please delete them and try again." ; ec=$Ex_Ko
			else
				if [ $keepWavMetadata = true ]; then kfm=''; fi
				nThreads=$( getNumberOfAvailableThreads $index $WavPack_Max_Threads )
				if [ $tagCompressionSetting = true ]; then compressionTag="Encoding=$Self_Name $Self_Version / WavPack $wavpackVersion / -$compression_WavPack"; fi
				printf -- "-q`tagline -w`\x00%s" "$wavFile" | xargs -0 wavpack --threads=$nThreads -m $kfm -${compression_WavPack} -o "$encodedFile" --no-utf8-convert >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				if [ $ec -eq $Ex_Ok -a -f "$destTagFile" ]; then
					importBinariesIntoAPEv2 || ec=$Ex_Ko
					importArtworkIntoAPEv2 || ec=$Ex_Ko
				fi
			fi
			;;

		WavPackHybrid)
			destExtension='wv'; encodedFile="${SWAPDIR}/${index}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${index}.ape.txt" kfm='-r'
			if [ $keepWavMetadata = true ]; then kfm=''; fi
			# WavPack Hybrid only supports multithreading for files with more than 2 channels
			nChannels=$( getNumberOfChannels "$wavFile" )
			if [ $nChannels -gt 2 ]; then
				nThreads=$( getNumberOfAvailableThreads $index $WavPack_Max_Threads )
			else
				nThreads=1
			fi
			if [ $tagCompressionSetting = true ]; then
				if [ "${average_bitrate_WavPackLossy%.*}" -lt 24 ]; then
					compressionTag="Encoding=$Self_Name $Self_Version / WavPack $wavpackVersion / -$compression_WavPack / $average_bitrate_WavPackLossy bits per sample (ABR)"
				else
					compressionTag="Encoding=$Self_Name $Self_Version / WavPack $wavpackVersion / -$compression_WavPack / $average_bitrate_WavPackLossy kbps (ABR)"
				fi
			fi
			printf -- "-q`tagline -w`\x00%s" "$wavFile" | xargs -0 wavpack --threads=$nThreads -m $kfm -o "$encodedFile" -c${compression_WavPack} -b${average_bitrate_WavPackLossy} --no-utf8-convert >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			if [ $ec -eq $Ex_Ok -a -f "$destTagFile" ]; then
				importBinariesIntoAPEv2 || ec=$Ex_Ko
				importArtworkIntoAPEv2 || ec=$Ex_Ko
			fi
			;;

		WavPackLossy)
			destExtension='wv'; encodedFile="${SWAPDIR}/${index}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${index}.ape.txt" kfm='-r'
			if [ -e "${destFile}c" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${destDir}" "$Self_Name -c wv: correction files are present. Please delete them and try again." ; ec=$Ex_Ko
			else
				if [ $keepWavMetadata = true ]; then kfm=''; fi
				# WavPack Lossy only supports multithreading for files with more than 2 channels
				nChannels=$( getNumberOfChannels "$wavFile" )
				if [ $nChannels -gt 2 ]; then
					nThreads=$( getNumberOfAvailableThreads $index $WavPack_Max_Threads )
				else
					nThreads=1
				fi
				if [ $tagCompressionSetting = true ]; then
					if [ -z "$compression_WavPack" ]; then
						compressionTag="Encoding=$Self_Name $Self_Version / WavPack $wavpackVersion / default / $average_bitrate_WavPackLossy bits per sample (ABR)"
					else
						compressionTag="Encoding=$Self_Name $Self_Version / WavPack $wavpackVersion / -$compression_WavPack / $average_bitrate_WavPackLossy kbps (ABR)"
					fi
				fi
				printf -- "-q`tagline -w`\x00%s" "$wavFile" | xargs -0 wavpack --threads=$nThreads -m $kfm -o "$encodedFile" -$compression_WavPack -b${average_bitrate_WavPackLossy} --no-utf8-convert >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				if [ $ec -eq $Ex_Ok -a -f "$destTagFile" ]; then
					importBinariesIntoAPEv2 || ec=$Ex_Ko
					importArtworkIntoAPEv2 || ec=$Ex_Ko
				fi
			fi
			;;

		lossyFLAC)
			destExtension='lossy.flac'; encodedFile="${SWAPDIR}/${index}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${index}.vc.txt"
			if [ $tagCompressionSetting = true ]; then compressionTag="ENCODING=$Self_Name $Self_Version / lossyWAV $lossywavVersion / -q $compression_lossyWAV"; fi
			nThreads=$( getNumberOfAvailableThreads $index $Flac_Max_Threads )
			printf -- "--totally-silent`tagline -T`\x00%s" "$lossywavFile" | xargs -0 flac -j $nThreads -P 4096 -5 -b 512 --keep-foreign-metadata -o "$encodedFile" >/dev/null 2>> "$errorLogFile" &&
			importArtworkIntoFLAC || ec=$Ex_Ko
			;;

		lossyWV)
			destExtension='lossy.wv'; encodedFile="${SWAPDIR}/${index}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${index}.ape.txt"
			if [ $tagCompressionSetting = true ]; then compressionTag="Encoding=$Self_Name $Self_Version / lossyWAV $lossywavVersion / -q $compression_lossyWAV"; fi
			# Using --merge-blocks for encoding lossyWV can only use a single thread
			printf -- "-q`tagline -w`\x00%s" "$lossywavFile" | xargs -0 wavpack -m -o "$encodedFile" --blocksize=512 --merge-blocks --no-utf8-convert >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			if [ $ec -eq $Ex_Ok -a -f "$destTagFile" ]; then
				importBinariesIntoAPEv2 || ec=$Ex_Ko
				importArtworkIntoAPEv2 || ec=$Ex_Ko
			fi
			;;

		MP3)
			destExtension='mp3'; encodedFile="${SWAPDIR}/${index}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${index}.mp3.txt"
			if [ "$compression_MP3" = '320' ]; then
				MP3_MODE='CBR' bitrate_MP3=320
			fi
			if [ "$MP3_MODE" = 'VBR' ]; then
				lame -S -V $compression_MP3 --noreplaygain --id3v2-only --pad-id3v2-size $ID3Padding --ignore-tag-errors -o "$wavFile" "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			elif [ "$MP3_MODE" = 'ABR' ]; then
				lame -S --abr $average_bitrate_MP3 --noreplaygain --id3v2-only --pad-id3v2-size $ID3Padding --ignore-tag-errors -o "$wavFile" "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			else
				if [ $compression_MP3 -eq "insane" ]; then
					lame -S --preset insane --noreplaygain --id3v2-only --pad-id3v2-size $ID3Padding --ignore-tag-errors -o "$wavFile" "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				else
					lame -S -b $bitrate_MP3 --cbr --noreplaygain --id3v2-only --pad-id3v2-size $ID3Padding --ignore-tag-errors -o "$wavFile" "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				fi
			fi
			if [ $ec -ne $Ex_Ko ]; then
				printf -- "`tagline`" | xargs -0 eyeD3 --quiet --to-v2.4 --force-update --encoding 'utf8' "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				importArtworkIntoMP3 || ec=$Ex_Ko
			fi
			;;

		AAC)
			destExtension='m4a'; encodedFile="${SWAPDIR}/${index}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${index}.m4a.txt" aaclibs=("aac_at" "libfdk_aac" "aac") aaclib=""
			if [ -z "$sourceCoverArtFile" ]; then
				for f in "${SWAPDIR}/picture-${index}-"*_*; do
					if [ ! -e "$f" ]; then continue; fi
					picType="${f#*_}"; picType="${picType%.*}"
					case $picType in
						3) sourceCoverArtFile="$f" ; break ;;
					esac
				done
			fi

			# https://trac.ffmpeg.org/wiki/Encode/AAC
			for aaclib in "${aaclibs[@]}"; do
				case "$aaclib" in
					aac_at)
						if [ "$AAC_MODE" = "ABR" -a -n "$average_bitrate_AAC" ]; then
							compression_param="-aac_at_mode abr -b:a" quality_arg="${average_bitrate_AAC}k"
						else
							compression_param="-b:a" quality_arg="${bitrate_AAC}k"
						fi
						# debug "aaclib [$aaclib] compression_param[$compression_param] quality_arg[$quality_arg]"
						if [ -n "$sourceCoverArtFile" -a -e "$sourceCoverArtFile" ]; then
							printf -- "`tagline`\x00%s\x00%s" "$encodedFile" | xargs -0 ffmpeg -i "$wavFile" -i "$sourceCoverArtFile" -map 0:a -map 1 -codec copy -metadata:s:v title="Album cover" -metadata:s:v comment="Cover (front)" -disposition:v attached_pic -c:a $aaclib $compression_param $quality_arg >/dev/null 2>> "$errorLogFile"; ec=$?
						else
							printf -- "`tagline`\x00%s\x00%s" "$encodedFile" | xargs -0 ffmpeg -i "$wavFile" -c:a $aaclib $compression_param $quality_arg >/dev/null 2>> "$errorLogFile"; ec=$?
						fi
						if [ $ec -ne $Ex_Ko ]; then ec=$Ex_Ok; break; fi
						;;

					libfdk_aac)
						compression_param="-b:a" quality_arg="${bitrate_AAC}k"
						# debug "aaclib [$aaclib] compression_param[$compression_param] quality_arg[$quality_arg]"
						if [ -n "$sourceCoverArtFile" -a -e "$sourceCoverArtFile" ]; then
							printf -- "`tagline`\x00%s\x00%s" "$encodedFile" | xargs -0 ffmpeg -i "$wavFile" -i "$sourceCoverArtFile" -map 0:a -map 1 -codec copy -metadata:s:v title="Album cover" -metadata:s:v comment="Cover (front)" -disposition:v attached_pic -c:a $aaclib $compression_param $quality_arg >/dev/null 2>> "$errorLogFile"; ec=$?
						else
							printf -- "`tagline`\x00%s\x00%s" "$encodedFile" | xargs -0 ffmpeg -i "$wavFile" -c:a $aaclib $compression_param $quality_arg >/dev/null 2>> "$errorLogFile"; ec=$?
						fi
						if [ $ec -ne $Ex_Ko ]; then ec=$Ex_Ok; break; fi
						;;

					aac)
						if [ "$AAC_MODE" != "CBR" ]; then
							if [ -z "$average_bitrate_AAC" -o "$average_bitrate_AAC" != "$bitrate_AAC" ]; then
								bitrate_AAC="$average_bitrate_AAC"
							fi
						fi
						compression_param="-b:a" quality_arg="${bitrate_AAC}k"
						# debug "aaclib [$aaclib] compression_param[$compression_param] quality_arg[$quality_arg]"
						if [ -n "$sourceCoverArtFile" -a -e "$sourceCoverArtFile" ]; then
							printf -- "`tagline`\x00%s\x00%s" "$encodedFile" | xargs -0 ffmpeg -i "$wavFile" -i "$sourceCoverArtFile" -map 0:a -map 1 -codec copy -metadata:s:v title="Album cover" -metadata:s:v comment="Cover (front)" -disposition:v attached_pic -c:a $aaclib $compression_param $quality_arg >/dev/null 2>> "$errorLogFile"; ec=$?
						else
							printf -- "`tagline`\x00%s\x00%s" "$encodedFile" | xargs -0 ffmpeg -i "$wavFile" -c:a $aaclib $compression_param $quality_arg >/dev/null 2>> "$errorLogFile"; ec=$?
						fi
						if [ $ec -ne $Ex_Ko ]; then ec=$Ex_Ok; break; fi
						;;
				esac
				if [ $ec -eq $Ex_Ok ]; then break; fi
			done
			;;

		OggVorbis)
			destExtension='ogg'; encodedFile="${SWAPDIR}/${index}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${index}.vc.txt"
			if [ "$OggVorbis_MODE" = 'VBR' ]; then
				if [ $tagCompressionSetting = true ]; then compressionTag="ENCODING=$Self_Name $Self_Version / oggenc $oggencVersion / -q $compression_OggVorbis"; fi
				printf -- "-Q`tagline -c`\x00%s" "$wavFile" | xargs -0 oggenc -q $compression_OggVorbis -o "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			elif [ "$OggVorbis_MODE" = 'ABR' ]; then
				if [ $tagCompressionSetting = true ]; then compressionTag="ENCODING=$Self_Name $Self_Version / oggenc $oggencVersion / $average_bitrate_OggVorbis kbps (ABR)"; fi
				printf -- "-Q`tagline -c`\x00%s" "$wavFile" | xargs -0 oggenc --managed -b $average_bitrate_OggVorbis -o "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			else
				if [ $tagCompressionSetting = true ]; then compressionTag="ENCODING=$Self_Name $Self_Version / oggenc $oggencVersion / $bitrate_OggVorbis kbps (CBR)"; fi
				printf -- "-Q`tagline -c`\x00%s" "$wavFile" | xargs -0 oggenc --managed -b $bitrate_OggVorbis -m $bitrate_OggVorbis -M $bitrate_OggVorbis -o "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			fi
			;;

		Opus)
			destExtension='opus'; encodedFile="${SWAPDIR}/${index}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${index}.vc.txt"
			if [ "$Opus_MODE" = 'VBR' ]; then
				if [ $tagCompressionSetting = true ]; then compressionTag="ENCODING=$Self_Name $Self_Version / $opusVersion / $compression_Opus kbps (VBR)"; fi
				printf -- "--quiet`tagline --comment`\x00%s`genOpusArtworkCommandLine`\x00%s" "$wavFile" "$encodedFile" | xargs -0 opusenc --vbr --bitrate $compression_Opus >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			elif [ "$Opus_MODE" = 'ABR' ]; then
				if [ $tagCompressionSetting = true ]; then compressionTag="ENCODING=$Self_Name $Self_Version / $opusVersion / $average_bitrate_Opus kbps (ABR)"; fi
				printf -- "--quiet`tagline --comment`\x00%s`genOpusArtworkCommandLine`\x00%s" "$wavFile" "$encodedFile" | xargs -0 opusenc --cvbr --bitrate $average_bitrate_Opus >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			else
				if [ $tagCompressionSetting = true ]; then compressionTag="ENCODING=$Self_Name $Self_Version / $opusVersion / $bitrate_Opus kbps (CBR)"; fi
				printf -- "--quiet`tagline --comment`\x00%s`genOpusArtworkCommandLine`\x00%s" "$wavFile" "$encodedFile" | xargs -0 opusenc --hard-cbr --bitrate $bitrate_Opus >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			fi
			;;
	esac

	if [ $copyPath = "true" ]; then
		if ! mkdir -p "$destPath" >/dev/null 2>&1 ; then
			ec=$Ex_Ko
		fi
		if [ -n "$destLinkPath" ]; then
			if ! mkdir -p "$destLinkPath" >/dev/null 2>&1 ; then
				ec=$Ex_Ko
			fi
		fi
	fi

	if [ "$outputCodec" = 'WAV' ]; then
		statusInfo='decoding'
	else
		statusInfo='encoding'
	fi

	if [ $ec -eq $Ex_Ok ]; then
		if [ -e "$encodedFile" ]; then
			chmod 0644 "$encodedFile"
			if [ -e "${encodedFile}c" ]; then # WavPack Hybrid correction files
				chmod 0644 "${encodedFile}c"
			fi
			if [ "$outputCodecs" = 'WAV' ]; then
				mv "$encodedFile" "$destFile" >/dev/null 2>> "$errorLogFile"
			elif [ -L "$encodedFile" -o "$outputCodec" = 'WAV' ]; then
				cp "$encodedFile" "$destFile" >/dev/null 2>> "$errorLogFile"
				if [ -e "${encodedFile}c" ]; then
					cp "${encodedFile}c" "${destFile}c" >/dev/null 2>> "$errorLogFile"
				fi
			else
				mv "$encodedFile" "$destFile" >/dev/null 2>> "$errorLogFile"
				if [ -e "${encodedFile}c" ]; then  # WavPack Hybrid correction files
					mv "${encodedFile}c" "${destFile}c" >/dev/null 2>> "$errorLogFile"
				fi
			fi

			if [ "$outputCodec" = "WavPackHybrid" -a -n "$destLinkPath" ]; then
				if [ -e "$destLinkFile" ]; then # delete old link for consistency``
					rm -f "$destLinkFile" >/dev/null 2>> "$errorLogFile"
				fi
				if [ -f "$destFile" ]; then
					ln -f "$destFile" "$destLinkPath" >/dev/null 2>> "$errorLogFile"
				fi
			fi

			case $outputCodec in
				WAV|AIFF|CAF) printMessage 'success' "$statusInfo" "file:${destFile}" $p "outputCodec:WAV" "threads:$nDecodingThreads" ;;
				*) printMessage 'success' "$statusInfo" "file:${destFile}" $p "outputCodec:${outputCodec}" "threads:$nThreads" ;;
			esac
		fi
	else
		rm -f "$encodedFile" >/dev/null 2>&1 # in case it exists
		printMessage 'error' "$statusInfo" "file:${sourceFile}" $p
	fi

	return $ec
}

cleanUpCopyLockFile () {
	local copyLockFile="$1" pid

	if [ -f "${copyLockFile}.lock" ]; then
		pid="$( cat "${copyLockFile}.lock" )"
		if [ -n "$pid" ]; then
			if ! isProcessRunning $pid ; then
				echo '' > "${copyLockFile}.lock" 2>/dev/null
				mv "${copyLockFile}.lock" "$copyLockFile" >/dev/null 2>&1
			fi
		fi
	fi
}

prepareSource () {
	local sourcePath ec=$Ex_Ok copyLockFile copyDone=false cptimer1 cptimer2 cpseconds attemptNumber=0

	if [ $preloadSources = true -a $touchFiles = false ]; then
		if [ "$OS" = 'Linux' ]; then
			copyLockFile="${Self_Io_Dir}/$( stat -c '%d' "$sourceFile" 2>> "$errorLogFile" )"
		else
			copyLockFile="${Self_Io_Dir}/$( stat -f '%d' "$sourceFile" 2>> "$errorLogFile" )"
		fi
		until test $copyDone = true; do
			# if test -f "$copyLockFile" && mv "$copyLockFile" "${copyLockFile}.lock" >/dev/null 2>&1; then
			if getAndRenameLock "$copyLockFile" "${copyLockFile}.lock"; then
				touch "${instanceDir}/ioLockFiles/${copyLockFile##*/}"
				echo "$$" > "${copyLockFile}.lock"

				if [ $gnudate = true ]; then
					cptimer1="$( $datecmd '+%s.%N' )"
				fi

				cp "$sourceFile" "$copyFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				if [ -e "${sourceFile}c" ]; then # WavPack correction file
					cp "${sourceFile}c" "${copyFile}c" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				fi

				echo '' > "${copyLockFile}.lock" 2>/dev/null
				mv "${copyLockFile}.lock" "$copyLockFile" >/dev/null 2>&1 &&
				rm -f "${instanceDir}/ioLockFiles/${copyLockFile##*/}" >/dev/null 2>&1
				copyDone=true

				if [ -n "$cptimer1" ]; then
					if [ $gnudate = true ]; then
						cptimer2="$( $datecmd '+%s.%N' )"
					fi
					if [ -n "$cptimer2" ]; then
						cpseconds="$( printf 'scale=6; %.6f - %.6f\n' "$cptimer2" "$cptimer1" | bc )"
						echo -n " + $cpseconds" >> "${TDIR}/readTimes"
					fi
				fi
			else
				if [ $attemptNumber -ge 100 ]; then
					cleanUpCopyLockFile "$copyLockFile"
					n=0
				else
					sleep 0.1
					((n++))
				fi
			fi
		done
	else
		if [ "${sourceFile:0:1}" = '/' ]; then # sourceFile is an absolute path
			sourcePath="$sourceFile"
		else # sourceFile is a relative path; prepend current directory
			sourcePath="${PWD}/${sourceFile}"
		fi
		if [ -n "$copyFile" ]; then
			if [ ! -h "$copyFile" ]; then
				ln -s "$sourcePath" "$copyFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			fi

			if [ -e "${sourcePath}c" ]; then # WavPack correction file
				if [ ! -h "${copyFile}c" ]; then
					ln -s "${sourcePath}c" "${copyFile}c" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				fi
			fi
		fi
	fi

	if [ $ec -ne $Ex_Ok ]; then
		rm -f "$copyFile" "${copyFile}c" >/dev/null 2>&1
	fi
	return $ec
}

addTranscodingErrorFile () {
	echo "$1" >> "${TDIR}/transcodingErrorFiles"
}

transcode () {
	local ec=$Ex_Ok lastCodec="${outputCodecs##* }" allDone=false copyDone=false encodingDone=false lsec=0
	local milliseconds index nDecodingThreads=1

	until test $allDone = true; do
		allDone=true
		while read milliseconds index; do
			getFileProps "${sourceFiles[$index]}"
			copyFile="${SWAPDIR}/${index}.${sourceFilename}"

			transcodingLockFile="${TDIR}/${index}"
			wasProcessedFile="${TDIR}/WAS_PROCESSED.${index}"
			decodingLockFile="${TDIR}/DECODING_${index}"
			wavFile="${SWAPDIR}/${index}.wav"
			resampledWavFile="${SWAPDIR}/${index}_resampled.wav"
			lossywavFile="${SWAPDIR}/${index}.lossy.wav"
			wavProcessedStatusFile="${TDIR}/${index}.wavProcessed"
			sourceTagFile="${TDIR}/${index}.txt"
			apeBinariesDir="${TDIR}/${index}.apeBinariesDir"
			sourceCRC32File="${TDIR}/${index}.sourceCRC32"
			sourceMD5File="${TDIR}/${index}.sourceMD5"
			sourceSHA1File="${TDIR}/${index}.sourceSHA1"
			sourceSHA256File="${TDIR}/${index}.sourceSHA256"
			sourceSHA512File="${TDIR}/${index}.sourceSHA512"
			losslessCRC32File="${TDIR}/${index}.losslessCRC32"
			losslessMD5File="${TDIR}/${index}.losslessMD5"
			losslessSHA1File="${TDIR}/${index}.losslessSHA1"
			losslessSHA256File="${TDIR}/${index}.losslessSHA256"
			losslessSHA512File="${TDIR}/${index}.losslessSHA512"
			lossywavCRC32File="${TDIR}/${index}.lossywavCRC32"
			lossywavMD5File="${TDIR}/${index}.lossywavMD5"
			lossywavSHA1File="${TDIR}/${index}.lossywavSHA1"
			lossywavSHA256File="${TDIR}/${index}.lossywavSHA256"
			lossywavSHA512File="${TDIR}/${index}.lossywavSHA512"

			# if test -e "$transcodingLockFile" && mv "$transcodingLockFile" "$decodingLockFile" 2>/dev/null; then
			if getAndRenameLock "$transcodingLockFile" "$decodingLockFile"; then
				allDone=false
				prepareSource &&
				decode || ec=$Ex_Ko
				if [ -n "$nThreads" ]; then
					nDecodingThreads=$nThreads
				else
					nDecodingThreads=1
				fi
				if [ $ec -ne $Ex_Ok ]; then addTranscodingErrorFile "$sourceFile" ; fi
				rm -f "$decodingLockFile" >/dev/null 2>&1
			elif [ -e "$decodingLockFile" ]; then # can't do anything for this track yet, gotta wait for it to be decoded
				allDone=false
				continue # skip to next track
			fi

			lossywavLockFile="${TDIR}/lossyWAV_${index}"
			lossywavEncodingLockFile="${lossywavLockFile}_encoding"
			if [ $nLossyWAV -ge 1 ]; then
				# if test -e "$lossywavLockFile" && mv "$lossywavLockFile" "$lossywavEncodingLockFile" 2>/dev/null ; then
				if getAndRenameLock "$lossywavLockFile" "$lossywavEncodingLockFile"; then
					allDone=false
					encodeLossyWAV || ec=$Ex_Ko
					if [ $ec -ne $Ex_Ok ]; then addTranscodingErrorFile "$sourceFile" ; fi
					rm -f "$lossywavEncodingLockFile" "${lossywavLockFile}_WAV_NEEDED"
					ls "${TDIR}/"*"_${index}_WAV_NEEDED" >/dev/null 2>&1 || rm -f "$wavFile"
					ls "${TDIR}/"*"_${index}_LOSSYWAV_NEEDED" >/dev/null 2>&1 || rm -f "$lossywavFile"
				fi
			fi

			for outputCodec in $outputCodecs; do
				test "$outputCodec" = 'lossyWAV' && continue
				if [ "$outputCodec" = 'lossyFLAC' -o "$outputCodec" = 'lossyWV' ]; then
					if [ -e "$lossywavEncodingLockFile" ]; then # lossyWAV encoding in progress, skip to next codec
						allDone=false
						continue
					fi
				fi
				encodingLockFile="${TDIR}/${outputCodec}_${index}"
				# if test -e "$encodingLockFile" && unlink "$encodingLockFile" 2>/dev/null; then
				if test -e "$encodingLockFile" && getLock "$encodingLockFile"; then
					allDone=false
					encode $nDecodingThreads || ec=$Ex_Ko
					if [ $ec -ne $Ex_Ok ]; then addTranscodingErrorFile "$sourceFile" ; fi
					rm -f "${encodingLockFile}_WAV_NEEDED"
					ls "${TDIR}/"*"_${index}_WAV_NEEDED" >/dev/null 2>&1 || rm -f "$wavFile"
					if [ "$outputCodec" = 'lossyFLAC' -o "$outputCodec" = 'lossyWV' ]; then
						rm -f "${encodingLockFile}_LOSSYWAV_NEEDED"
						ls "${TDIR}/"*"_${index}_LOSSYWAV_NEEDED" >/dev/null 2>&1 || rm -f "$lossywavFile"
					fi

					copyOrLinkOtherFiles "$outputCodec"
					if [ "$outputCodec" = "WavPackHybrid" -a -d "$destLinkPath" ]; then
						copyOrLinkOtherFiles "WavPackLossy"
					fi

					touch "$wasProcessedFile"
				fi
			done

			# FIXME: this mysteriously causes some random picture not to be copied (race condition?)
			# if ! ls "${TDIR}/"*"_${index}_LOSSYWAV_NEEDED" >/dev/null 2>&1 ; then
			# 	if ! ls "${TDIR}/"*"_${index}_WAV_NEEDED" >/dev/null 2>&1 ; then
			# 		ls "${SWAPDIR}/picture-${index}"* >/dev/null 2>&1 &&
			# 		rm -f "${SWAPDIR}/picture-${index}"* >/dev/null 2>&1
			# 		if [ -e "$apeBinariesDir" ]; then
			# 			rm -rf "$apeBinariesDir"
			# 		fi
			# 	fi
			# fi
		chmod u+rwX "$destPath" "${destPath}"/* 2>> "$errorLogFile" # FIXME chmod u=rw,go=r
		done < "${TDIR}/millisecondsAndFileNumbers"
		sleep 0.1 # make sure idling processes don't hog the CPU
	done

	rm -f "${instanceDir}/process.${p}"
	return $ec
}

compareHashes () {
	local hashvalA='' hashvalB=''

	case "$testHashType" in
		SHA512) hashvalA="$hashSHA512"; hashvalB="$( computeSHA "$wavFile" 'SHA512' )" ;;
		SHA256) hashvalA="$hashSHA256"; hashvalB="$( computeSHA "$wavFile" 'SHA256' )" ;;
		SHA1) hashvalA="$hashSHA1"; hashvalB="$( computeSHA "$wavFile" 'SHA1' )" ;;
		MD5) hashvalA="$hashMD5"; hashvalB="$( computeMD5 "$wavFile" )" ;;
		CRC32) hashvalA="$hashCRC32"; hashvalB="$( computeCRC32 "$wavFile" )" ;;
	esac

	if [ -z "$hashvalA" -o -z "$hashvalB" ]; then
		return $Ex_Data_Err
	elif [ "$hashvalA" = "$hashvalB" ]; then
		return $Ex_Ok
	else
		return $Ex_Ko
	fi
}

checkHashAvailability () {
	local hashtype="$1" hashval="$2"

	test -z "$hashval" && return $Ex_Data_Err
	which 'sox' >/dev/null 2>&1 || return $Ex_Os_File

	case "$hashtype" in
		SHA512)
			if [ "$OS" = 'Linux' ]; then
				which 'sha512sum' >/dev/null 2>&1 || return $Ex_Os_File
			else
				which 'shasum' >/dev/null 2>&1 || return $Ex_Os_File
			fi
			;;

		SHA256)
			if [ "$OS" = 'Linux' ]; then
				which 'sha256sum' >/dev/null 2>&1 || return $Ex_Os_File
			else
				which 'shasum' >/dev/null 2>&1 || return $Ex_Os_File
			fi
			;;

		SHA1)
			if [ "$OS" = 'Linux' ]; then
				which 'sha1sum' >/dev/null 2>&1 || return $Ex_Os_File
			else
				which 'shasum' >/dev/null 2>&1 || return $Ex_Os_File
			fi
			;;

		MD5)
			if [ "$OS" = 'Linux' ]; then
				which 'md5sum' >/dev/null 2>&1 || return $Ex_Os_File
			else
				which 'md5' >/dev/null 2>&1 || return $Ex_Os_File
			fi
			;;

		CRC32)
			which 'cksfv' >/dev/null 2>&1 || return $Ex_Os_File
			;;
	esac

	return $Ex_Ok
}

getSuitableHash () {
	local errType=$Ex_Data_Err

	if [ -z "$hashtags" ]; then
		return $Ex_Data_Err
	fi

	checkHashAvailability 'SHA512' "$hashSHA512"; ec=$?
	if [ $ec -eq $Ex_Ok ]; then
		testHashType='SHA512'
		return $Ex_Ok
	elif [ $ec -eq $Ex_Os_File ]; then
		errType=$Ex_Os_File
	fi

	checkHashAvailability 'SHA256' "$hashSHA256"; ec=$?
	if [ $ec -eq $Ex_Ok ]; then
		testHashType='SHA256'
		return $Ex_Ok
	elif [ $ec -eq $Ex_Os_File ]; then
		errType=$Ex_Os_File
	fi


	checkHashAvailability 'SHA1' "$hashSHA1"; ec=$?
	if [ $ec -eq $Ex_Ok ]; then
		testHashType='SHA1'
		return $Ex_Ok
	elif [ $ec -eq $Ex_Os_File ]; then
		errType=$Ex_Os_File
	fi

	checkHashAvailability 'MD5' "$hashMD5"; ec=$?
	if [ $ec -eq $Ex_Ok ]; then
		testHashType='MD5'
		return $Ex_Ok
	elif [ $ec -eq $Ex_Os_File ]; then
		errType=$Ex_Os_File
	fi

	checkHashAvailability 'CRC32' "$hashCRC32"; ec=$?
	if [ $ec -eq $Ex_Ok ]; then
		testHashType='CRC32'
		return $Ex_Ok
	elif [ $ec -eq $Ex_Os_File ]; then
		errType=$Ex_Os_File
	fi

	return $errType
}

getHashTags () {
	hashtags='' hashSHA512='' hashSHA256='' hashSHA1='' hashMD5='' hashCRC32=''
	if [ ! -e "$sourceTagFile" ]; then return $Ex_Data_Err; fi

	if [ $gnused = true ]; then
		$sedcmd -i'' -e 's@crc=@CRC32=@i' "$sourceTagFile" >/dev/null 2>&1
	else
		$sedcmd -i '' -e 's@crc=@CRC32=@i' "$sourceTagFile" >/dev/null 2>&1
	fi
	hashtags="$( grep -iE '^SHA512=|^SHA256=|^SHA1=|^MD5=|^CRC32=' "$sourceTagFile" 2>/dev/null | sort -u 2>/dev/null )"
	if [ -z "$hashtags" ]; then
		return $Ex_Data_Err
	fi

	hashSHA512="$( echo "$hashtags" | grep -Fi 'SHA512=' 2>/dev/null | cut -d '=' -f 2 2>/dev/null )"
	hashSHA256="$( echo "$hashtags" | grep -Fi 'SHA256=' 2>/dev/null | cut -d '=' -f 2 2>/dev/null )"
	hashSHA1="$( echo "$hashtags" | grep -Fi 'SHA1=' 2>/dev/null | cut -d '=' -f 2 2>/dev/null )"
	hashMD5="$( echo "$hashtags" | grep -Fi 'MD5=' 2>/dev/null | cut -d '=' -f 2 2>/dev/null )"
	hashCRC32="$( echo "$hashtags" | grep -Fi 'CRC32=' 2>/dev/null | cut -d '=' -f 2 2>/dev/null )"

	return $Ex_Ok
}

testFile () {
	local ec=$Ex_Ok nThreads=1

	if [ -e "$copyFile" ]; then
		case "$copyFile" in
			*.flac)
				flac -st "$copyFile" >/dev/null 2>&1; ec=$?
				;;

			*.wv)
				nThreads=$( getNumberOfAvailableThreads $index $WavPack_Max_Threads )
				wvunpack --threads=$nThreads -qmv "$copyFile" >/dev/null 2>&1; ec=$?
				;;

			*.ape)
				nThreads=$( getNumberOfAvailableThreads $index )
				mac "$copyFile" -threads=$nThreads -V >/dev/null 2>&1; ec=$?
				;;

			*) printMessage 'warning' 'testing' 'unsupported' "file:${sourceFile}" $p 'unsupported format' ; return $Ex_Ko ;;
		esac
	else
		ec=$Ex_Ko
	fi

	if [ -e "$wavFile" ]; then rm -f "$wavFile"; fi
	if [ -e "$copyFile" ]; then rm -f "$copyFile" "${copyFile}c" >/dev/null 2>&1; fi

	if [ $ec -eq $Ex_Ok ]; then
		printMessage 'success' 'testing' $p "threads:$nThreads" "file:${sourceFile}"
	else
		printMessage 'error' 'testing' $p "file:${sourceFile}"
	fi
	return $ec
}

getLock () {
	local lockFile="$1"
	if [ "$OS" = 'Darwin' ]; then
		lockf -s -n -t 1 "$lockFile" test -e "$lockFile" &>/dev/null
	else
		unlink "$lockFile" 2>/dev/null # FIXME LOCKING
	fi
}

getAndRenameLock () {
	local lockFileOne="$1" lockFileTwo="$2"
	if [ "$OS" = 'Darwin' ]; then
		lockf -k -s -n -t 1 "$lockFileOne" mv "$lockFileOne" "$lockFileTwo" &>/dev/null
	else
		test -e "$lockFileOne" && mv "$lockFileTwo" 2>/dev/null  # FIXME LOCKING
	fi
}

testFiles () {
	local ec=$Ex_Ok milliseconds index
	while read milliseconds index; do
		sourceFile="${sourceFiles[$index]}"
		sourceFilename="${sourceFile##*/}"
		copyFile="${SWAPDIR}/${index}.${sourceFilename}"
		wavFile="${SWAPDIR}/${index}.wav"
		sourceTagFile="${TDIR}/${index}.txt"
		testingLockFile="${TDIR}/${index}"
		wasProcessedFile="${TDIR}/WAS_PROCESSED.${index}"

		if getLock "$testingLockFile"; then
			prepareSource &&
			testFile || ec=$Ex_Ko
			if [ -e "$wavFile" ]; then rm -f "$wavFile" >/dev/null 2>&1; fi
			if [ -e "$copyFile" ]; then rm -f "$copyFile" "${copyFile}c" >/dev/null 2>&1; fi
			touch "$wasProcessedFile"
		fi
	done < "${TDIR}/millisecondsAndFileNumbers"

	rm -f "${instanceDir}/process.${p}"
	return $ec
}

getInternalMD5 () {
	local file="$1"

	sourceMD5=''
	case "$file" in
		*.flac) sourceMD5="$( metaflac --show-md5sum "$file" 2>/dev/null )" ;;

		*.wv)
			sourceMD5="$( wvunpack -f "$file" 2>/dev/null | cut -d ';' -f 7 )"
			;;
	esac
}

computeHash () {
	local ec=$Ex_Ok ereg nThreads=1

	if [ -e "$copyFile" ]; then
		sourceMD5=''
		case "$copyFile" in
			*.flac)
				metaflac --no-utf8-convert --export-tags-to="$sourceTagFile" "$copyFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				if [ $ec -eq $Ex_Ok ]; then
					getInternalMD5 "$copyFile"
					flac -s -d -o "$wavFile" "$copyFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				fi
				;;

			*.wv)
				touch "$sourceTagFile"
				if [ $ec -eq $Ex_Ok ]; then
					getInternalMD5 "$copyFile"
					nThreads=$( getNumberOfAvailableThreads $index $WavPack_Max_Threads )
					wvunpack -q -m --threads=$nThreads -o "$wavFile" "$copyFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				fi
				;;

			*.ape)
				touch "$sourceTagFile"
				if [ $ec -eq $Ex_Ok ]; then
					nThreads=$( getNumberOfAvailableThreads $index )
					mac "$copyFile" "$wavFile" -d -threads=$nThreads >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				fi
				;;

			*) printMessage 'warning' 'hashing' 'unsupported' "file:${sourceFile}" $p 'unsupported format' ; return $Ex_Ko ;;
		esac

		if [ -e "$copyFile" ]; then rm -f "$copyFile" "${copyFile}c" >/dev/null 2>&1; fi

		if [ $ec -eq $Ex_Ok ]; then
			processSourceTagFile
			ereg=""
			for h in $hashes; do
				ereg="${ereg}|^${h}="
				if [ "$h" = 'CRC32' ]; then
					ereg="${ereg}|^crc="
				fi
			done
			# filter out existing hashes
			grep -viE "${ereg:1}" "$sourceTagFile" > "${sourceTagFile}.tmp"
			mv "${sourceTagFile}.tmp" "$sourceTagFile"

			for h in $hashes; do
				case "$h" in
					CRC32)
						{
						hline="$( computeCRC32 "$wavFile" )"
						test -n "$hline" && echo "CRC32=$hline" >> "$sourceTagFile"
						test -n "$hline" && printMessage 'info' "$h" "${h}=${hline}" "file:${sourceFile}" $p
						} & ;;

					MD5)
						{
						hline="$( computeMD5 "$wavFile" )"
						test -n "$hline" && printMessage 'info' "$h" "${h}=${hline}" "file:${sourceFile}" $p
						if [ -n "$hline" ]; then
							echo "MD5=${hline}" >> "$sourceTagFile"
							if [ -n "$sourceMD5" -a "$sourceMD5" != "$hline" ]; then
								printMessage 'warning' 'hashing' 'bad_internal_hash' $p "file:${sourceFile}" 'internal MD5 hash is incorrect (possible bug in the codec)!'
								printMessage 'info' 'hashing' 'stderr' 'Please file a bug report: https://github.com/gcocatre/caudec/issues'
							fi
						fi
						} & ;;

					SHA1|SHA256|SHA512)
						{
						hline="$( computeSHA "$wavFile" "$h" )"
						test -n "$hline" && echo "${h}=${hline}" >> "$sourceTagFile"
						test -n "$hline" && printMessage 'info' "$h" "${h}=${hline}" "file:${sourceFile}" $p
						} & ;;
				esac
			done
			wait
		fi

		if [ -e "$wavFile" ]; then rm -f "$wavFile" >/dev/null 2>&1; fi

		if [ $ec -eq $Ex_Ok ]; then
			case "$copyFile" in
				*.flac)
					destTagFile="${TDIR}/${index}.vc.txt" outputCodec="FLAC"
					cp "$sourceTagFile" "$destTagFile" >/dev/null 2>&1 &&
					printf -- "--no-utf8-convert`tagline --set-tag`\x00%s" "$sourceFile" | xargs -0 metaflac --remove-all-tags >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
					;;

				*.wv|*.ape)
					destTagFile="${TDIR}/${index}.ape.txt" outputCodec="WavPack"
					cp "$sourceTagFile" "$destTagFile" >/dev/null 2>&1 &&
					printf -- "-z`tagline -t`\x00%s" "$sourceFile" | xargs -0 APEv2 >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
					;;
			esac
		fi
	else
		ec=$Ex_Ko
	fi

	if [ $ec -eq $Ex_Ok ]; then
		printMessage 'success' 'hashing' $p "threads:$nThreads" "file:${sourceFile}"
	else
		printMessage 'error' 'decoding' $p "file:${sourceFile}"
	fi
	return $ec
}

computeHashes () {
	local ec=$Ex_Ok index

	for ((index=0; index < ${#sourceFiles[@]}; index++)); do
		sourceFile="${sourceFiles[$index]}"
		sourceFilename="${sourceFile##*/}"
		sourceTagFile="${TDIR}/${index}.txt"
		sourceMD5File="${TDIR}/${index}.md5"
		copyFile="${SWAPDIR}/${index}.${sourceFilename}"
		wavFile="${SWAPDIR}/${index}.wav"
		hashingLockFile="${TDIR}/${index}"
		wasProcessedFile="${TDIR}/WAS_PROCESSED.${index}"

		if getLock "$hashingLockFile"; then
			prepareSource || ec=$Ex_Ko
			if [ $ec -eq $Ex_Ok ]; then
				computeHash || ec=$Ex_Ko
			fi
			if [ -e "$wavFile" ]; then rm -f "$wavFile" >/dev/null 2>&1; fi
			if [ -e "$copyFile" ]; then rm -f "$copyFile" "${copyFile}c" >/dev/null 2>&1; fi
			touch "$wasProcessedFile"
		fi
	done

	rm -f "${instanceDir}/process.${p}"
	return $ec
}

saveReplaygainToMP3 () {
	local ec=$Ex_Ok

	if [ $computeAudioPeaks = true -a -n "$peakDbfs" ]; then
		eyeD3 --quiet --to-v2.4 \
			--user-text-frame="REPLAYGAIN_${gainType}_GAIN:${gain} dB" \
			--user-text-frame="REPLAYGAIN_${gainType}_PEAK:${peak}" \
			--user-text-frame="AUDIO_${gainType}_PEAK:${peakDbfs} dBFS" \
			"$destFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
	else
		eyeD3 --quiet --to-v2.4 \
			--user-text-frame="REPLAYGAIN_${gainType}_GAIN:${gain} dB" \
			--user-text-frame="REPLAYGAIN_${gainType}_PEAK:${peak}" \
			"$destFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
	fi

	return $ec
}

saveGain () {
	local gainType="$1" gainTypeText ec=$Ex_Ok gain peak peakDbfs uGain mp3GainSteps

	if [ "$gainType" = 'TRACK' ]; then
		gain="$trackGain" peak="$trackPeak" uGain="$trackGain"
	else
		gain="$albumGain" peak="$albumPeak" uGain="$albumGain"
	fi

	if [ "${gain:0:1}" != '-' ]; then
		gain="+${gain}"
	fi

	if [ $computeAudioPeaks = true ]; then
		peakDbfs="$( computeGainFromPeak "$peak" )"
		if [ -n "$peakDbfs" -a "${peakDbfs:0:1}" != '-' -a "$peakDbfs" != "0.00" ]; then
			peakDbfs="+${peakDbfs}"
		fi
	fi

	case "$destFile" in
		*.flac)
			if [ "$gainType" = 'ALBUM' ]; then
				if [ $computeAudioPeaks = true -a -n "$peakDbfs" ]; then
					metaflac \
						--remove-tag="REPLAYGAIN_ALBUM_GAIN" \
						--remove-tag="REPLAYGAIN_ALBUM_PEAK" \
						--remove-tag="AUDIO_ALBUM_PEAK" \
						--set-tag="REPLAYGAIN_ALBUM_GAIN=${gain} dB" \
						--set-tag="REPLAYGAIN_ALBUM_PEAK=${peak}" \
						--set-tag="AUDIO_ALBUM_PEAK=${peakDbfs} dBFS" \
						"$destFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				else
					metaflac \
						--remove-tag="REPLAYGAIN_ALBUM_GAIN" \
						--remove-tag="REPLAYGAIN_ALBUM_PEAK" \
						--set-tag="REPLAYGAIN_ALBUM_GAIN=${gain} dB" \
						--set-tag="REPLAYGAIN_ALBUM_PEAK=${peak}" \
						"$destFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				fi
			else
				if [ $computeAudioPeaks = true -a -n "$peakDbfs" ]; then
					metaflac \
						--remove-tag="AUDIO_TRACK_PEAK" \
						--set-tag="AUDIO_TRACK_PEAK=${peakDbfs} dBFS" \
						"$destFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				fi
			fi
			;;

		*.wv)
			if [ "$gainType" = 'ALBUM' ]; then
				if [ $computeAudioPeaks = true -a -n "$peakDbfs" ]; then
					wvtag \
						-w "replaygain_album_gain=" \
						-w "replaygain_album_peak=" \
						-w "audio_album_peak=" \
						-w "replaygain_album_gain=${gain} dB" \
						-w "replaygain_album_peak=${peak}" \
						-w "audio_album_peak=${peakDbfs} dBFS" \
						"$destFile" 1>/dev/null 2>/dev/null || ec=$Ex_Ko
				else
					wvtag \
						-w "replaygain_album_gain=" \
						-w "replaygain_album_peak=" \
						-w "replaygain_album_gain=${gain} dB" \
						-w "replaygain_album_peak=${peak}" \
						"$destFile" 1>/dev/null 2>/dev/null || ec=$Ex_Ko
				fi
			else
				if [ $computeAudioPeaks = true -a -n "$peakDbfs" ]; then
					wvtag \
						-w "audio_track_peak=" \
						-w "audio_track_peak=${peakDbfs} dBFS" \
						"$destFile" 1>/dev/null 2>/dev/null || ec=$Ex_Ko
				fi
			fi
			;;

		*.ogg)
			if [ "$gainType" = 'ALBUM' ]; then
				if [ $computeAudioPeaks = true -a -n "$peakDbfs" ]; then
					vorbiscomment -a \
						-d "REPLAYGAIN_ALBUM_PEAK" \
						-d "REPLAYGAIN_ALBUM_GAIN" \
						-d "AUDIO_ALBUM_PEAK" \
						-t "REPLAYGAIN_ALBUM_PEAK=${peak}" \
						-t "REPLAYGAIN_ALBUM_GAIN=${gain} dB" \
						-t "AUDIO_ALBUM_PEAK=${peakDbfs} dBFS" \
						"$destFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				else
					vorbiscomment -a \
						-d "REPLAYGAIN_ALBUM_PEAK" \
						-d "REPLAYGAIN_ALBUM_GAIN" \
						-t "REPLAYGAIN_ALBUM_PEAK=${peak}" \
						-t "REPLAYGAIN_ALBUM_GAIN=${gain} dB" \
						"$destFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				fi
			else
				if [ $computeAudioPeaks = true -a -n "$peakDbfs" ]; then
					vorbiscomment -a \
						-d "AUDIO_TRACK_PEAK" \
						-t "AUDIO_TRACK_PEAK=${peakDbfs} dBFS" \
						"$destFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				fi
			fi
			;;

		*.mp3)
			if [ $applyGain = true ]; then
				mp3GainSteps="$( echo "scale=3; $uGain / 1.5" | bc )" # MP3 gain steps are 1.5dB
				mp3GainSteps="$( printf '%.0f' "$mp3GainSteps" )"
				mp3gain -s d "$destFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				mp3gain -c -g "$mp3GainSteps" "$destFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
			else
				mp3gain -s d "$destFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				saveReplaygainToMP3 || ec=$Ex_Ko
			fi
			;;

		*) ec=$Ex_Ko ;;
	esac

	return $ec
}

getFileMilliseconds () {
	local file="$1" ec=$Ex_Ok seconds line samplingRate bitDepth format nChannels channelMask nSamples rest

	case "$file" in
		*.wv)
				line="$( wvunpack -f "$file" 2>/dev/null )"
				OIFS="$IFS"
				IFS=";"
				read samplingRate bitDepth format nChannels channelMask nSamples rest <<< "$line"
				seconds="$( echo "scale=3; $nSamples / $samplingRate" | bc )"
				IFS="$OIFS"
			;;

		*.ape|*.m4a)
			seconds="$( ffprobe -print_format 'default' -show_streams -select_streams 'a:0' "$file" 2>/dev/null | grep -F 'duration=' 2>/dev/null | cut -d '=' -f 2 | tr -cd '0-9.' )"
			;;

		*) seconds="$( soxi -D "$file" )" ;;
	esac

	if [ -n "$seconds" -a "$seconds" != "0" ]; then
		printf "%.0f" "$( echo "scale=3; ($seconds * 1000) / 1" | bc 2>/dev/null )" 2>/dev/null
	else
		ec=$Ex_Ko
		echo 1
	fi

	return $ec
}

getMillisecondsByFileIndex () {
	local index="$1" fileIndex

	read trackMilliseconds fileIndex < "${TDIR}/inputMilliseconds_${index}"
	if [ -n "$trackMilliseconds" ]; then
		echo $trackMilliseconds
	else
		echo 1
		return $Ex_Ko
	fi

	return $Ex_Ok
}

computeGainFromPeak () {
	local decimalPeak="$1"
	printf "%.2f" "$( echo "scale=10; 20 * l(${decimalPeak}) / l(10)" | bc -l 2>> "$errorLogFile" )"
}

computeTrackGain () {
	local ec=$Ex_Ok line nLines=0 decimals trackGain trackPeak albumGain destTagFile clippingPreventionParam=""

	if [ -e "$sourceFile" ]; then
		case "$sourceFile" in
			*.flac)
				metaflac --add-replay-gain "$sourceFile" >/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
				if [ $ec -eq $Ex_Ok ]; then
					trackGain="$( metaflac --show-tag="REPLAYGAIN_TRACK_GAIN" "$sourceFile" 2>> "$errorLogFile" | cut -d '=' -f 2 | cut -d ' ' -f 1 | tr -d '+' )"
					trackPeak="$( metaflac --show-tag="REPLAYGAIN_TRACK_PEAK" "$sourceFile" 2>> "$errorLogFile" | cut -d '=' -f 2 )"
				fi
				if [ -n "$trackGain" -a -n "$trackPeak" ]; then
					echo "$trackGain" > "$trackGainFile"
					echo "$trackPeak" > "$trackPeakFile"
				else
					ec=$Ex_Ko
				fi
				;;

			*.wv)
				wvgain -c "$sourceFile" >/dev/null 2>/dev/null || ec=$Ex_Ko
				wvgain -q -t "$sourceFile" >/dev/null 2>/dev/null || ec=$Ex_Ko
				if [ $ec -eq $Ex_Ok ]; then
					trackGain="$( wvtag -x "replaygain_track_gain" "$sourceFile" 2>/dev/null | cut -d '=' -f 2 | cut -d ' ' -f 1 | tr -d '+' )"
					trackPeak="$( wvtag -x "replaygain_track_peak" "$sourceFile" 2>/dev/null | cut -d '=' -f 2 )"
				fi
				if [ -n "$trackGain" -a -n "$trackPeak" ]; then
					echo "$trackGain" > "$trackGainFile"
					echo "$trackPeak" > "$trackPeakFile"
				else
					ec=$Ex_Ko
				fi
				;;

			*.ogg)
				vorbisgain -c "$sourceFile" 1>/dev/null 2>> "$errorLogFile"
				vorbisgain "$sourceFile" 1>/dev/null 2>/dev/null || ec=$Ex_Ko
				if [ $ec -eq $Ex_Ok ]; then
					trackGain="$( vorbiscomment -l "$sourceFile" 2>/dev/null | grep -iE '^replaygain_track_gain=' 2>> "$errorLogFile" | cut -d '=' -f 2 | cut -d ' ' -f 1 | tr -d '+' )"
					trackPeak="$( vorbiscomment -l "$sourceFile" 2>/dev/null | grep -iE '^replaygain_track_peak=' 2>> "$errorLogFile" | cut -d '=' -f 2 )"
				fi
				if [ -n "$trackGain" -a -n "$trackPeak" ]; then
					echo "$trackGain" > "$trackGainFile"
					echo "$trackPeak" > "$trackPeakFile"
				else
					ec=$Ex_Ko
				fi
				;;

			*.opus) break ;;

			*.mp3)
				mp3gain -u "$sourceFile" 1>/dev/null 2>/dev/null
				mp3gain -s d "$sourceFile" >/dev/null 2>/dev/null
				if [ $preventClipping = true ]; then
					clippingPreventionParam="-k"
				fi
				line="$( mp3gain -e $clippingPreventionParam -o -T -q "$sourceFile" 2>> "$errorLogFile" | grep -Fv 'MP3 gain' | tr '\t' '|' | tr -d '+' | cut -d '|' -f 3-4 )" ; ec=$?
				if [ $ec -eq $Ex_Ok -a -n "$line" ]; then
					trackGain="${line%|*}"
					decimals="${trackGain#*.}"
					trackGain="${trackGain%.*}.${decimals:0:2}"
					trackPeak="${line#*|}"; trackPeak="${trackPeak%.*}"
					trackPeak="$( echo "scale=8; $trackPeak / 32767" | bc )"
					if [ "${trackPeak:0:1}" = '.' ]; then
						trackPeak="0${trackPeak}"
					fi
					if [ -n "$trackGain" -a -n "$trackPeak" ]; then
						echo "$trackGain" > "$trackGainFile"
						echo "$trackPeak" > "$trackPeakFile"
					else
						ec=$Ex_Ko
					fi
				else
					ec=$Ex_Ko
				fi
				;;

			*) printMessage 'warning' 'track_gain' 'unsupported' "file:${sourceFile}" $p 'unsupported format' ; return $Ex_Ko ;;
		esac
	else
		ec=$Ex_Ko
	fi

	if [ "$sourceFileExt" != "opus" ]; then
		if [ $ec -eq $Ex_Ok ]; then
			if [ $applyGain = false -o "$applyGainType" = "TRACK" ]; then
				saveGain 'TRACK' || ec=$Ex_Ko
			fi
		fi

		if [ $ec -eq $Ex_Ok ]; then
			if [ $verbose = true ]; then
				if [ "${trackGain:0:1}" != '-' -a "${trackGain:0:1}" != '+' ]; then
					trackGain="+${trackGain}"
				fi
				printMessage 'success' 'track_gain' $p "$trackGain dB" "file:${sourceFile}"
			fi
		else
			printMessage 'error' 'track_gain' "file:${sourceFile}" $p
		fi
	fi
	return $ec
}

computeTrackGains () {
	local ec=$Ex_Ok milliseconds index

	while read milliseconds index; do
		sourceFile="${sourceFiles[$index]}"
		destFile="$sourceFile"
		sourceFilename="${sourceFile##*/}"
		sourceFileExt="${sourceFile##*.}"
		gainLockFile="${TDIR}/${index}"
		wasProcessedFile="${TDIR}/WAS_PROCESSED.${index}"
		trackGainFile="${TDIR}/${index}.trackgain"
		trackPeakFile="${TDIR}/${index}.trackpeak"

		if getLock "$gainLockFile"; then
			computeTrackGain || ec=$Ex_Ko
			touch "$wasProcessedFile"
		fi
	done < "${TDIR}/millisecondsAndFileNumbers"

	rm -f "${instanceDir}/process.${p}"
	return $ec
}

computeAlbumGain () {
	# This is a very fast way of computing the album gain, but it is also less precise than the official implementation.
	# A comparison between gains on 754 albums revealed max differences ranging from -2.06 dB to +1.50 dB.
	# PINK_REF="64.82" is from flac/src/share/replaygain_analysis/replaygain_analysis.c
	local ec=$Ex_Ok PINK_REF_COMPLEMENT="35.18" index processIndex secondsIndex rank trackGain trackSeconds=1 increment=0
	local trackGainFile trackPeakFile albumPeak albumAudioPeak albumGain

	for ((index=0; index < ${#sourceFiles[@]}; index++)); do
		trackGainFile="${TDIR}/${index}.trackgain"
		trackPeakFile="${TDIR}/${index}.trackpeak"
		trackGain="$( cat "$trackGainFile" )"
		trackMilliseconds="$( getMillisecondsByFileIndex "$index" )"
		trackSeconds="$( printf "%.0f" "$( echo "scale=3; $trackMilliseconds / 1000" | bc )" )"
		if [ -z "$trackSeconds" ]; then
			trackSeconds=1
		fi
		for (( secondsIndex=0; secondsIndex < trackSeconds; secondsIndex++ )); do
			echo "$trackGain" >> "${TDIR}/trackgains"
			((increment++))
		done
		cat "$trackPeakFile" >> "${TDIR}/trackpeaks" 2>/dev/null
	done

	albumPeak="$( sort -n "${TDIR}/trackpeaks" 2>/dev/null | tail -n 1 )"
	if [ -z "$albumPeak" ]; then
		return $Ex_Ko
	fi

	if [ $applyGain = true -a "$applyGainType" = 'ALBUM_PEAK' ]; then
		albumGain="$( computeGainFromPeak "$albumPeak" )"
		if [ "${albumGain:0:1}" = '-' ]; then
			albumGain="${albumGain:1}"
			if [ "${peakReference:0:1}" = '-' ]; then
				albumGain="$( printf "%.2f" "$( echo "scale=3; ($albumGain + $peakReference) / 1" | bc 2>> "$errorLogFile" )" )"
			fi
		elif [ "${peakReference:0:1}" = '-' ]; then
			albumGain="$peakReference"
		else
			albumGain="-0"
		fi
	else
		sort -n "${TDIR}/trackgains" > "${TDIR}/trackgains.tmp" 2>/dev/null
		mv "${TDIR}/trackgains.tmp" "${TDIR}/trackgains"

		# By using PINK_REF_COMPLEMENT instead of PINK_REF, running 'head' MIGHT be slightly faster than
		# running 'tail' with PINK_REF because 'head' will output fewer lines than 'tail'.
		rank="$( printf "%.0f" "$( echo "scale=5; ((${PINK_REF_COMPLEMENT} / 100) * $increment + (1 / 2)) / 1" | bc 2>> "$errorLogFile" )" )"
		albumGain="$( head -n $rank "${TDIR}/trackgains" 2>/dev/null | tail -n 1 )"
		if [ -z "$albumGain" ]; then
			printMessage 'error' 'album_gain' "Album gain"
			return $Ex_Ko
		elif [ $applyGain = true -a "$applyGainType" = 'ALBUM' -a -n "$preamp" ]; then
			if [ "${preamp:0:1}" = '-' ]; then
				albumGain="$( printf "%.2f" "$( echo "scale=3; ($albumGain - ${preamp:1}) / 1" | bc 2>> "$errorLogFile" )" )"
			elif [ "${preamp:0:1}" = '+' ]; then
				albumGain="$( printf "%.2f" "$( echo "scale=3; ($albumGain + ${preamp:1}) / 1" | bc 2>> "$errorLogFile" )" )"
			fi
		fi
	fi

	for ((index=0, processIndex=0; index < ${#sourceFiles[@]}; index++, processIndex++)); do
		if [ $processIndex -lt $nProcesses ]; then
			destFile="${sourceFiles[$index]}"
			saveGain 'ALBUM' &
		else
			wait
			processIndex=0
			destFile="${sourceFiles[$index]}"
			saveGain 'ALBUM' &
		fi
	done
	wait

	if [ "${albumGain:0:1}" != '-' ]; then
		albumGain="+${albumGain}"
	fi
	printMessage 'success' 'album_gain' "${albumGain} dB" "Album gain: $albumGain dB"

	return $ec
}

# https://github.com/FrancisRussell/zoog
computeOpusAlbumGain () {
	local ec=$Ex_Ok list sourceFile albumPlaybackGain trackPlaybackGain trackDecibels signedTrackGain signedAlbumGain

	for sourceFile in "${sourceFiles[@]}"; do
		if [ -z "$list" ]; then
			list="$sourceFile"
		else
			list="${list}\x00${sourceFile}"
		fi
	done
	echo -en "$list" | xargs -0 opusgain -j $nProcesses -a -p rg 1>/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
	if [ $ec -ne $Ex_Ko ]; then
		# opusgain changes the rights on the files it touches, to u=rw,go=
		chmod u=rw,go=r "${sourceFiles[@]}" 1>/dev/null 2>> "$errorLogFile"

		albumPlaybackGain="$( opusinfo "$sourceFile" 2>> "$errorLogFile" | grep -F "Playback gain: " | cut -d ':' -f 2 | cut -d ' ' -f 2 )"
		albumPlaybackGain="$( printf "%.2f" "$albumPlaybackGain" )"
		for sourceFile in "${sourceFiles[@]}"; do
			trackPlaybackGain="$( opusinfo "$sourceFile" | grep -F "R128_TRACK_GAIN=" | cut -d '=' -f 2 | cut -d ' ' -f 1 )"
			trackPlaybackGain="${trackPlaybackGain#+*}"
			trackDecibels="$( echo "scale=3; ($albumPlaybackGain + ($trackPlaybackGain / 256) + 5) / 1" | bc 2>> "$errorLogFile" )"
			trackDecibels="$( printf "%.2f" "$trackDecibels" )"
			signedTrackGain="$trackDecibels"
			if [ "${signedTrackGain:0:1}" != '-' -a "${signedTrackGain:0:1}" != '+' ]; then
				signedTrackGain="+${signedTrackGain}"
			fi
			printMessage 'success' 'track_gain' 0 "$signedTrackGain dB" "file:${sourceFile}"
		done
		signedAlbumGain="$albumPlaybackGain"
		if [ "${signedAlbumGain:0:1}" != '-' -a "${signedAlbumGain:0:1}" != '+' ]; then
			signedAlbumGain="+${signedAlbumGain}"
		fi
		printMessage 'success' 'album_gain' "$signedAlbumGain dB"
	else
		printMessage 'error' 'album_gain' "Album gain"
	fi

	return $ec
}

reverseOpusTrackGains () {
	local ec=$Ex_Ok list sourceFile

	for sourceFile in "${sourceFiles[@]}"; do
		if [ -z "$list" ]; then
			list="$sourceFile"
		else
			list="${list}\x00${sourceFile}"
		fi
	done

	echo -en "$list" | xargs -0 opusgain -j $nProcesses -p 'original' 1>/dev/null 2>> "$errorLogFile" &&
	echo -en "$list" | xargs -0 opusgain -j $nProcesses -c 1>/dev/null 2>> "$errorLogFile" || ec=$Ex_Ko
	if [ $ec -ne $Ex_Ko ]; then
		# opusgain changes the rights on the files it touches, to u=rw,go=
		chmod u=rw,go=r "${sourceFiles[@]}" 1>/dev/null 2>> "$errorLogFile"

		for sourceFile in "${sourceFiles[@]}"; do
			printMessage 'success' 'track_gain' 0 "-0 dB" "file:${sourceFile}"
		done
	else
		printMessage 'error' 'track_gain' "Track gain"
	fi

	return $ec
}

reverseTrackGain () {
	local ec=$Ex_Ok

	if [ -e "$sourceFile" ]; then
		case "$sourceFile" in
			*.flac) metaflac \
				--remove-tag="REPLAYGAIN_REFERENCE_LOUDNESS" \
				--remove-tag="REPLAYGAIN_TRACK_GAIN" \
				--remove-tag="REPLAYGAIN_TRACK_PEAK" \
				--remove-tag="REPLAYGAIN_ALBUM_GAIN" \
				--remove-tag="REPLAYGAIN_ALBUM_PEAK" \
				--remove-tag="AUDIO_TRACK_PEAK" \
				--remove-tag="AUDIO_ALBUM_PEAK" \
				"$sourceFile" 1>/dev/null 2>/dev/null ; ec=$? ;;

			*.wv) wvtag \
				-w "replaygain_reference_loudness=" \
				-w "replaygain_track_gain=" \
				-w "replaygain_track_peak=" \
				-w "replaygain_album_gain=" \
				-w "replaygain_album_peak=" \
				-w "audio_track_peak=" \
				-w "audio_album_peak=" \
				"$sourceFile" 1>/dev/null 2>/dev/null ; ec=$?
				;;

			*.ape) APEv2 -z \
				-r "Replaygain_Reference_Loudness" \
				-r "Replaygain_Track_Gain" \
				-r "Replaygain_Track_Peak" \
				-r "Replaygain_Album_Gain" \
				-r "Replaygain_Album_Peak" \
				-r "Audio_Track_Peak" \
				-r "Audio_Album_Peak" \
				"$sourceFile" 1>/dev/null 2>/dev/null ; ec=$?
				;;

			*.ogg) vorbiscomment \
				-d "REPLAYGAIN_REFERENCE_LOUDNESS" \
				-d "REPLAYGAIN_TRACK_PEAK" \
				-d "REPLAYGAIN_TRACK_GAIN" \
				-d "REPLAYGAIN_ALBUM_PEAK" \
				-d "REPLAYGAIN_ALBUM_GAIN" \
				-d "AUDIO_TRACK_PEAK" \
				-d "AUDIO_ALBUM_PEAK" \
				"$sourceFile" 1>/dev/null 2>/dev/null; ec=$?
				;;

			*.mp3)
				mp3gain -u "$sourceFile" 1>/dev/null 2>/dev/null ; ec=$?
				if [ $ec -eq $Ex_Ok ]; then
					mp3gain -s d "$sourceFile" >/dev/null 2>> "$errorLogFile"
				fi
				;;

			*) printMessage 'warning' 'track_gain' 'unsupported' "file:${sourceFile}" $p 'unsupported format' ; return $Ex_Ko ;;
		esac
	else
		ec=$Ex_Ko
	fi

	if [ $ec -eq $Ex_Ok ]; then
		if [ $verbose = true ]; then
			printMessage 'success' 'track_gain' $p "-0 dB" "file:${sourceFile}"
		fi
	else
		printMessage 'error' 'track_gain' "file:${sourceFile}" $p
	fi
	return $ec
}

reverseTrackGains () {
	local ec=$Ex_Ok milliseconds index

	while read milliseconds index; do
		sourceFile="${sourceFiles[$index]}"
		gainLockFile="${TDIR}/${index}"

		if getLock "$gainLockFile"; then
			reverseTrackGain || ec=$Ex_Ko
		fi
	done < "${TDIR}/millisecondsAndFileNumbers"

	rm -f "${instanceDir}/process.${p}"
	return $ec
}

echoTouchString () {
  local trackDate="$1" hours="$2" minutes="$3" seconds="$4"
  if [ ${#hours} -lt 2 ]; then hours="0${hours}"; fi
  if [ ${#minutes} -lt 2 ]; then minutes="0${minutes}"; fi
  if [ ${#seconds} -lt 2 ]; then seconds="0${seconds}"; fi
  echo "${trackDate}${hours}${minutes}.${seconds}"
}

getTouchString () {
  local trackDate="$1" totalSeconds="$2" str="" fDays fHours fMinutes fSeconds fMilliseconds=0

  fSeconds=$totalSeconds
  fDays="$( echo "scale=0; $fSeconds / 86400" | bc )"
  fSeconds="$( echo "$fSeconds - ($fDays * 86400)" | bc )"
  fHours="$( echo "scale=0; $fSeconds / 3600" | bc )"
  fSeconds="$( echo "$fSeconds - ($fHours * 3600)" | bc )"
  fMinutes="$( echo "scale=0; $fSeconds / 60" | bc )"
  fSeconds="$( echo "scale=0; ($fSeconds - ($fMinutes * 60)) / 1" | bc )" # divide by 1 because "scale" only works on divisions
  fMilliseconds="$( echo "$totalSeconds" | cut -d "." -f 2 )"

	if [ "$fMilliseconds" == "" ]; then fMilliseconds=0; fi
  if [ $fMilliseconds -ge 500 ]; then
    fSeconds="$( echo "$fSeconds + 1" | bc )"
  fi

  echoTouchString $trackDate $fHours $fMinutes $fSeconds
}

computeTrackDateTime () {
	local ec=$Ex_Ok trackYear trackMonth trackDay

	case "$sourceFile" in
		*.flac|*ogg|*.m4a|*.wv|*.ape|*.opus|*.mp3)
			case "$sourceFile" in
				*.flac) date=$( metaflac --no-filename --show-tag=date "$sourceFile" | tr -cd "[:digit:]-" ) ;;
				*.ogg) date=$( vorbiscomment "$sourceFile" | grep -iF "date=" | tr -cd "[:digit:]-" ) ;;
				*.m4a) date=$( ffprobe -show_format -print_format flat "$sourceFile" 2>/dev/null | grep -iE '^format.tags.date' | cut -d '.' -f 3- | tr -cd "[:digit:]-" ) ;;
				*.wv) date=$( wvtag -x Year "$sourceFile" 2>/dev/null | tr -cd "[:digit:]-" ) ;;
				*.ape) date=$( APEv2 -z "$sourceFile" 2>/dev/null | grep -iF year= | tr -cd "[:digit:]-" ) ;;
				*.opus) date=$( opusinfo "$sourceFile" | grep -iF "date=" | tr -cd "[:digit:]-" ) ;;
				*.mp3) date=$( ffmpeg -i "$sourceFile" -f ffmetadata - 2>/dev/null | grep -iE "^(date|TDOR|TDRC|TDRL)=[0-9]{4}" | head -n 1 | tr -cd "[:digit:]-" ) ;;
			esac
			if [ ${#date} -eq 4 ]; then
				trackYear="$date"
				trackMonth="01"
				trackDay="01"
			elif [ ${#date} -eq 7 ]; then
				trackYear=$( echo "$date" | cut -d "-" -f 1 )
				trackMonth=$( echo "$date" | cut -d "-" -f 2 )
				trackDay="01"
			elif [ ${#date} -eq 10 ]; then
				trackYear=$( echo "$date" | cut -d "-" -f 1 )
				trackMonth=$( echo "$date" | cut -d "-" -f 2 )
				trackDay=$( echo "$date" | cut -d "-" -f 3 )
			else
				trackYear="$( $datecmd "+%Y" )"
				trackMonth="$( $datecmd "+%m" )"
				trackDay="$( $datecmd "+%d" )"
			fi

			echo "${trackYear}${trackMonth}${trackDay}" > "$sourceTagFile"
			;;

		*) continue ;;
	esac

	if [ $ec -eq $Ex_Ok ]; then
		printMessage 'success' 'touch_file' $p "dateTime:${trackYear}-${trackMonth}-${trackDay}" "file:${sourceFile}"
	else
		printMessage 'error' 'touch_file' $p "dateTime:${trackYear}-${trackMonth}-${trackDay}" "file:${sourceFile}"
	fi

	return $ec
}

computeTrackDateTimes () {
	local ec=$Ex_Ok index

	for ((index=0; index < ${#sourceFiles[@]}; index++)); do
		sourceFile="${sourceFiles[$index]}"
		sourceFilename="${sourceFile##*/}"
		sourceTagFile="${TDIR}/${index}.txt"
		touchLockFile="${TDIR}/${index}"
		wasProcessedFile="${TDIR}/WAS_PROCESSED.${index}"

		if getLock "$touchLockFile"; then
			prepareSource &&
			computeTrackDateTime || ec=$Ex_Ko
			touch "$wasProcessedFile"
		fi
	done

	rm -f "${instanceDir}/process.${p}"
	return $ec
}

touchAllFiles () {
	local ec=$Ex_Ok index audioFileIndex otherFileIndex dirIndex
	local trackDate albumSeconds discSeconds trackMilliseconds discHours discMinutes discSeconds
	local defaultTrackDate lastDir="" curDir artistDir albumDir albumLinkDir albumPath dirPath inode linkedFile linkPath
	local touchString discDirs linkedDiscDirs audioFiles otherFiles otherFile audioFile sourceFile sourceTagFile

	trackDate="$( $datecmd "+%Ymd" )"
	defaultTrackDate="$trackDate"
	albumSeconds=0

	discDirs=()
	linkedDiscDirs=()
	audioFiles=()
	otherFiles=()

	for ((index=0, dirIndex=0; index < ${#sourceFiles[@]}; index++)); do
		sourceFile="${sourceFiles[$index]}"
		sourceDirname="$( dirname "$sourceFile" )"
		curDir="$( readlink -f "$sourceDirname" )"
		if [ "$curDir" != "$lastDir" ]; then
			discDirs[$dirIndex]="$curDir"
			dirIndex=$(( dirIndex + 1 ))
			lastDir="$curDir"
		fi
	done

	for ((dirIndex=0; dirIndex < ${#discDirs[@]}; dirIndex++)); do
		curDir="${discDirs[$dirIndex]}"
		trackMilliseconds=0
		touchString="${trackDate}0000.00"
		discSeconds=0
		linkPath=""

		for ((index=0, audioFileIndex=0, otherFileIndex=0; index < ${#sourceFiles[@]}; index++)); do
			sourceFile="${sourceFiles[$index]}"
			sourceDirname="$( dirname "$sourceFile" )"
			dirPath="$( readlink -f "$sourceDirname" )"
			if [ "$dirPath" != "$curDir" ]; then continue; fi
			case "$sourceFile" in
				*.flac|*ogg|*.m4a|*.wv|*.ape|*.mp3|*.opus) audioFiles[$audioFileIndex]="$sourceFile" ; audioFileIndex=$(( audioFileIndex + 1 )) ;;
				*.wvc) continue ;; # will be touched when the matching .wv file is touched
				*.aiff|*.caf) continue ;; # unsupported audio files
				*) otherFiles[$otherFileIndex]="$sourceFile" ; otherFileIndex=$(( otherFileIndex + 1 )) ;; # all non-audio files
			esac
		done

		for audioFile in "${audioFiles[@]}"; do
			audioFileDirname="$( dirname "$audioFile" )"
			dirPath="$( readlink -f "$audioFileDirname" )"
			if [ "$dirPath" != "$curDir" ]; then continue; fi
			if [ $gotLinkedDir = true -a -z "$linkPath" ]; then
				linkedDiscDirs[$dirIndex]=""
				inode="$( ls -i "$audioFile" 2>/dev/null | cut -d " " -f 1 2>/dev/null )"
				if [ -n "$inode" ]; then
					while read linkedFile; do
						if [ -z "$linkPath" ]; then
							linkPath="$( dirname "$linkedFile" )"
							linkedDiscDirs[$dirIndex]="$linkPath"
							break
						fi
					done < <( find "$linkDir" -inum "$inode" )
				fi
			else
				break
			fi
		done

		for ((index=0; index < ${#sourceFiles[@]}; index++)); do
			sourceFile="${sourceFiles[$index]}"
			sourceDirname="$( dirname "$sourceFile" )"
			dirPath="$( readlink -f "$sourceDirname" )"
			if [ "$dirPath" != "$curDir" ]; then continue; fi
			sourceTagFile="${TDIR}/${index}.txt"

			case "$sourceFile" in
				*.flac|*ogg|*m4a|*.wv|*.ape|*.mp3|*.opus)
					read trackDate < "$sourceTagFile"
					if [ -z "$trackDate" ]; then trackDate="$defaultTrackDate"; fi
					trackMilliseconds="$( getMillisecondsByFileIndex "$index" )"
					if [ -z "$trackMilliseconds" ]; then trackMilliseconds=0; fi
					;;

				*.wvc) continue ;;

				*) continue ;;
			esac

			touchString="$( getTouchString $trackDate $discSeconds )"
			touch -t "$touchString" "$sourceFile" || ec=$Ex_Io_Err
			if [ -e "${sourceFile}c" ]; then  # WavPack correction file
				touch -t "$touchString" "${sourceFile}c" || ec=$Ex_Io_Err
			fi
			trackMilliseconds="$( getMillisecondsByFileIndex "$index" )"
			discSeconds="$( echo "scale=3; ($discSeconds + ($trackMilliseconds / 1000)) / 1" | bc )"
			albumSeconds="$( echo "scale=3; ($albumSeconds + ($trackMilliseconds / 1000)) / 1" | bc )"
			# debug "trackMilliseconds=[$trackMilliseconds] discSeconds=[$discSeconds] albumSeconds[$albumSeconds]"
		done

		for otherFile in "${otherFiles[@]}"; do
			touchString="$( getTouchString $trackDate $discSeconds )"
			touch -t "$touchString" "$otherFile" 2>> "$errorLogFile" || ec=$Ex_Io_Err
		done

		if [ ! -w "$curDir" ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${curDir}" 'refusing to touch directory that is read-only.'
		else
			touchString="$( getTouchString $trackDate $discSeconds )"
			touch -t "$touchString" "$curDir" || ec=$Ex_Io_Err
		fi

		if [ -n "$linkPath" ]; then
			if [ ! -w "$linkPath" ]; then
				printMessage 'warning' 'usage' 'filesystem' "path:${linkPath}" 'refusing to touch directory that is read-only.'
			else
				touchString="$( getTouchString $trackDate $discSeconds )"
				touch -t "$touchString" "$linkPath" || ec=$Ex_Io_Err
			fi
		fi
	done

	if [ ${#discDirs[@]} -gt 1 ]; then
		for ((dirIndex=0; dirIndex < ${#discDirs[@]}; dirIndex++)); do
			curDir="${discDirs[$dirIndex]}"
			curLinkedDir="${linkedDiscDirs[$dirIndex]}"
			albumDir="$( dirname "$curDir" )"

			if [ ! -w "$albumDir" ]; then
				printMessage 'warning' 'usage' 'filesystem' "path:${albumDir}" 'refusing to touch directory that is read-only.'
			else
				touchString="$( getTouchString $trackDate $albumSeconds )"
				touch -t "$touchString" "$albumDir" || ec=$Ex_Io_Err
			fi

			if [ -n "$curLinkedDir" ]; then
				albumLinkDir="$( dirname "$curLinkedDir" )"
				if [ ! -w "$albumLinkDir" ]; then
					printMessage 'warning' 'usage' 'filesystem' "path:${albumLinkDir}" 'refusing to touch directory that is read-only.'
				else
					touchString="$( getTouchString $trackDate $albumSeconds )"
					touch -t "$touchString" "$albumLinkDir" || ec=$Ex_Io_Err
				fi
			fi
		done
	fi

	if [ $ec -eq $Ex_Ok ]; then
		touchString="$( getTouchString $trackDate $albumSeconds )"
		discHours="${touchString:8:2}"
		discMinutes="${touchString:10:2}"
		albumSeconds="${touchString:13:2}"
		printMessage 'success' 'touch_files' "albumTime:${discHours}:${discMinutes}:${albumSeconds}"
	else
		printMessage 'error' 'touch_files' "Album length"
	fi

	return $ec
}

getCodecExtension () {
	local codec="$1" ext

	case "$codec" in
		WAV)           ext='wav' ;;
		AIFF)          ext='aiff' ;;
		CAF)           ext='caf' ;;
		FLAC)          ext='flac' ;;
		WavPack)       ext='wv' ;;
		WavPackHybrid) ext='wv' ;;
		MonkeysAudio)  ext='ape' ;;
		WavPackLossy)  ext='wv' ;;
		lossyWAV)      ext='lossy.wav' ;;
		lossyFLAC)     ext='lossy.flac' ;;
		lossyWV)       ext='lossy.wv' ;;
		OggVorbis)     ext='ogg' ;;
		MP3)           ext='mp3' ;;
		AAC|ALAC)      ext='m4a' ;;
		Opus)          ext='opus' ;;
	esac

	echo "$ext"
}

getCodecFullName () {
	local codec="$1" codecFullName

	case "$codec" in
		WAV)           codecFullName='WAV' ;;
		AIFF)          codecFullName='AIFF' ;;
		CAF)           codecFullName='CAF' ;;
		FLAC)          codecFullName='FLAC' ;;
		ALAC)          codecFullName='ALAC' ;;
		WavPack)       codecFullName='WavPack' ;;
		WavPackHybrid) codecFullName='WavPack Hybrid' ;;
		MonkeysAudio)  codecFullName="Monkey's Audio" ;;
		WavPackLossy)  codecFullName='WavPack Lossy' ;;
		lossyWAV)      codecFullName='lossyWAV' ;;
		lossyFLAC)     codecFullName='lossyFLAC' ;;
		lossyWV)       codecFullName='lossyWV' ;;
		OggVorbis)     codecFullName='Ogg Vorbis' ;;
		MP3)           codecFullName='MP3' ;;
		AAC)           codecFullName='AAC' ;;
		Opus)          codecFullName='Opus' ;;
	esac

	echo "$codecFullName"
}

getFileProps () {
	local outputCodec="$2"

	sourceFile="$1"
	sourceFilename="${sourceFile##*/}"
	sourceDirname="$( dirname "$sourceFile" )"
	sourceBasename="${sourceFilename%.*}"
	if [ "$sourceBasename" != "${sourceBasename%.lossy}" ]; then
		sourceIsLossyWAV=true
	else
		sourceIsLossyWAV=false
	fi
	sourceBasename="${sourceBasename%.lossy}";
	sourceExtension="${sourceFilename##*.}"

	if [ -n "$outputCodec" ]; then
		destExtension="$( getCodecExtension "$outputCodec" )"
		outputCodecFullName="$( getCodecFullName "$outputCodec" )"
		destDir="$( getDestDir "$outputCodec" )"
		if [ "$outputCodec" = 'WAV' -a $sourceIsLossyWAV = true ]; then
			destExtension='lossy.wav'
		fi
		destFilename="${sourceBasename}.${destExtension}"

		sourceCoverArtFile=""
		coverArtFilename="$( getCodecCoverArtFile "$outputCodec" )"
		if [ -n "$coverArtFilename" ]; then
			sourceCoverArtFile="${sourceDirname}/${coverArtFilename}"
			if [ ! -e "$sourceCoverArtFile" ]; then
				sourceCoverArtFile=""
				# printMessage 'warning' 'usage' 'filesystem' "file:${coverArtFilename}" 'no such file.'
			elif [ ! -r "$sourceCoverArtFile" ]; then
				sourceCoverArtFile=""
				# printMessage 'warning' 'usage' 'filesystem' "file:${coverArtFilename}" 'cannot open file for reading (permission denied).'
			fi
		fi

		copyPath="$( copyPathOrNot "$outputCodec" )"
		if [ $copyPath = "true" ]; then
			destPath="${destDir}/${sourceDirname#/}"
			destFile="${destPath}/${destFilename}"
			if [ -n "$linkDir" ]; then
				destLinkPath="${linkDir}/${sourceDirname#/}"
				destLinkFile="${destLinkPath}/${destFilename}"
			fi
		else
			destPath="$destDir"
			destFile="${destDir}/${destFilename}"
			if [ -n "$linkDir" ]; then
				destLinkPath="$linkDir"
				destLinkFile="${linkDir}/${destFilename}"
			fi
		fi
	fi
}

printMachineStats () {
	local sourceCoverArtBytes audio_bytes_compressed=0 destExtension dest bcmd seconds slist
	local bytes_compressed duration=0 rate=''

	seconds="$( printf 'scale=6; %.6f - %.6f\n' "$time2" "$time1" | bc )"
	if [ "$seconds" = '0' ]; then seconds='1'; fi # prevent division by 0 situations

	while read fileMilliseconds index; do
		duration=$(( duration + fileMilliseconds ))
	done < "${TDIR}/millisecondsAndFileNumbers"

	if [ "$duration" != '0' ]; then
		duration="$( printf "%.0f" "$( echo "scale=3; $duration / 1000" | bc )" )"
		rate="$( echo "scale=1; $duration / $seconds" | bc )"
	fi

	if [ -z "$outputCodecs" ]; then
		if [ -n "$rate" ]; then
			printMessage 'info' "${rate}x"
		fi
		return
	fi

	if [ -n "$rate" ]; then
		printMessage 'info' "${rate}x"
	fi

	if [ "$outputCodecs" = 'WAV' ]; then return; fi

	bcmd=''
	for outputCodec in $outputCodecs; do
		for sourceFile in "${sourceFiles[@]}"; do
			getFileProps "$sourceFile" "$outputCodec"
			if [ -e "$destFile" ]; then
				bcmd="${bcmd}\x00${destFile//%/%%}"
				if [ -e "${destFile}c" ]; then # WavPack correction file
					bcmd="${bcmd}\x00${destFile//%/%%}c"
				fi
			fi
		done
	done

	if [ $gnustat = true ]; then
		bytes_compressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %s' | xargs -0 $statcmd -L --printf; echo; } | bc )"
	else
		bytes_compressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %z' | xargs -0 $statcmd -L -n -f; echo; } | bc )"
	fi

	for outputCodec in $outputCodecs; do
		bcmd=''
		for sourceFile in "${sourceFiles[@]}"; do
			getFileProps "$sourceFile" "$outputCodec"
			if [ -e "$destFile" ]; then
				bcmd="${bcmd}\x00${destFile//%/%%}"
				if [ -e "${destFile}c" ]; then # WavPack correction file
					bcmd="${bcmd}\x00${destFile//%/%%}c"
				fi
			fi
		done

		if [ $gnustat = true ]; then
			bytes_compressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %s' | xargs -0 $statcmd -L --printf; echo; } | bc )"
		else
			bytes_compressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %z' | xargs -0 $statcmd -L -n -f; echo; } | bc )"
		fi


		if [ $duration -gt 0 ]; then
			bitrate_compressed="$( echo "scale=0; ($bytes_compressed * 8) / ${duration}" | bc )"
			printMessage 'info' "bitrate_${outputCodec}" "${bitrate_compressed}bps"
		fi
	done

	return $Ex_Ok
}

printHumanStats () {
	local sourceFile sourceCoverArtBytes audio_bytes_compressed=0 destExtension dest bcmd seconds slist
	local bytes_wav bytes_compressed imbsec ombsec mib_compressed ratio duration='0' rate='' readDuration

	seconds="$( printf 'scale=6; %.6f - %.6f\n' "$time2" "$time1" | bc )"
	if [ "$seconds" = '0' ]; then seconds='1'; fi # prevent division by 0 situations

	while read fileMilliseconds index; do
		duration=$(( duration + fileMilliseconds ))
	done < "${TDIR}/millisecondsAndFileNumbers"

	if [ "$duration" != '0' ]; then
		duration="$( printf "%.0f" "$( echo "scale=3; $duration / 1000" | bc )" )"
		rate="$( echo "scale=1; $duration / $seconds" | bc )"
	fi
	printf "${Clr_B_Bk} * ${Clr_Rst}%.2f seconds" $seconds

	readDuration="$( { echo -n 'scale=6; ' ; cat "${TDIR}/readTimes" ; echo ; } | bc )"
	if [ "$readDuration" = '0' ]; then # prevent division by 0 situations
		if [ "$seconds" = '0' ]; then
			readDuration='1'
		else
			readDuration="$seconds"
		fi
	fi

	for sourceFile in "${sourceFiles[@]}"; do
		slist="${slist}\x00${sourceFile//%/%%}"
		if [ -e "${sourceFile}c" ]; then # WavPack correction file
			slist="${slist}\x00${sourceFile//%/%%}c"
		fi
	done

	if [ $gnustat = true ]; then
		bytes_source="$( { echo -n 'scale=0; 0'; printf "%s${slist}" ' + %s' | xargs -0 $statcmd -L --printf; echo; } | bc )"
	else
		bytes_source="$( { echo -n 'scale=0; 0'; printf "%s${slist}" ' + %z' | xargs -0 $statcmd -L -n -f; echo; } | bc )"
	fi
	imbsec="$( echo "scale=3; $bytes_source / ($readDuration * 1000000)" | bc )"

	if [ -z "$outputCodecs" ]; then
		if [ -z "$rate" ]; then
			printf ' (read: %.1f MB/s)\n' "$imbsec"
		else
			printf ' (read: %.1f MB/s, rate: %sx)\n' "$imbsec" "$rate"
		fi
		return
	fi

	bcmd=''
	for outputCodec in $outputCodecs; do
		for sourceFile in "${sourceFiles[@]}"; do
			getFileProps "$sourceFile" "$outputCodec"
			if [ -e "$destFile" ]; then
				bcmd="${bcmd}\x00${destFile//%/%%}"
				if [ -e "${destFile}c" ]; then # WavPack correction file
					bcmd="${bcmd}\x00${destFile//%/%%}c"
				fi
			fi
		done
	done

	if [ $gnustat = true ]; then
		bytes_compressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %s' | xargs -0 $statcmd -L --printf; echo; } | bc )"
	else
		bytes_compressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %z' | xargs -0 $statcmd -L -n -f; echo; } | bc )"
	fi
	ombsec="$( echo "scale=3; $bytes_compressed / ($seconds * 1000000)" | bc )"

	if [ -n "$rate" ]; then
		printf ' (read: %.1f MB/s, write: %.1f MB/s, rate: %sx)\n' "$imbsec" "$ombsec" "$rate"
	else
		printf ' (read: %.1f MB/s, write: %.1f MB/s)\n' "$imbsec" "$ombsec"
	fi

	if [ "$outputCodecs" = 'WAV' ]; then return; fi

	bytes_wav="$( { echo -n 'scale=0; 0' ; cat "${TDIR}/bytes" ; echo ; } | bc )"
	mib_source="$( echo "scale=3; $bytes_source / 1048576" | bc )"
	mib_uncompressed="$( echo "scale=3; $bytes_wav / 1048576" | bc )"
	ratio="$( echo "scale=3; $bytes_source * 100 / $bytes_wav" | bc )"

	if [ $duration -gt 0 ]; then
		bitrate_source="$( echo "scale=0; (${bytes_source} * 8) / ${duration} / 1000" | bc )"
	else
		bitrate_source='?'
	fi

	# each item is separated by 4 spaces
	printf '\n%-15s    %6.1f MiB    %5.1f%%' 'WAV:' "$mib_uncompressed" '100'
	printf '\n%-15s    %6.1f MiB    %5.1f%%    %4s kbps\n' 'Source:' "$mib_source" "$ratio" "$bitrate_source"

	for outputCodec in $outputCodecs; do
		bcmd=''
		for sourceFile in "${sourceFiles[@]}"; do
			getFileProps "$sourceFile" "$outputCodec"
			if [ -e "$destFile" ]; then
				bcmd="${bcmd}\x00${destFile//%/%%}"
				if [ -e "${destFile}c" ]; then # WavPack correction file
					bcmd="${bcmd}\x00${destFile//%/%%}c"
				fi
			fi
		done

		if [ $gnustat = true ]; then
			bytes_compressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %s' | xargs -0 $statcmd -L --printf; echo; } | bc )"
		else
			bytes_compressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %z' | xargs -0 $statcmd -L -n -f; echo; } | bc )"
		fi

		if [ $duration -gt 0 ]; then
			bitrate_compressed="$( echo "scale=0; (${bytes_compressed} * 8) / ${duration} / 1000" | bc )"
		else
			bitrate_compressed='?'
		fi

		mib_compressed="$( echo "scale=3; $bytes_compressed / 1048576" | bc )"
		ratio="$( echo "scale=3; $bytes_compressed * 100 / $bytes_wav" | bc )"

		# each item is separated by 4 spaces
		printf '%-15s    %6.1f MiB    %5.1f%%    %4s kbps\n' "${outputCodecFullName}:"	$mib_compressed "$ratio" "$bitrate_compressed"
	done

	return $Ex_Ok
}

setDestDir () {
	local outputCodec="$1" codecDestDir="$2" copyPath="$3" listOfCodecs codec

	if [ -z "$outputCodec" ]; then
		read -a listOfCodecs <<< "$allCodecsString"
	else
		read -a listOfCodecs <<< "$outputCodec"
	fi

	for codec in "${listOfCodecs[@]}"; do
		case "$codec" in
			WAV) dir_WAV="$codecDestDir" ;;
			AIFF) dir_AIFF="$codecDestDir" ;;
			CAF) dir_CAF="$codecDestDir" ;;
			FLAC) dir_FLAC="$codecDestDir" ;;
			ALAC) dir_ALAC="$codecDestDir" ;;
			WavPack) dir_WavPack="$codecDestDir" ;;
			WavPackHybrid) dir_WavPackHybrid="$codecDestDir" ;;

			WavPackLossy) dir_WavPackLossy="$codecDestDir" ;;
			MonkeysAudio) dir_MonkeysAudio="$codecDestDir" ;;
			lossyWAV) dir_lossyWAV="$codecDestDir" ;;
			lossyFLAC) dir_lossyFLAC="$codecDestDir" ;;
			lossyWV) dir_lossyWV="$codecDestDir" ;;
			MP3) dir_MP3="$codecDestDir" ;;
			AAC) dir_AAC="$codecDestDir" ;;
			OggVorbis) dir_OggVorbis="$codecDestDir" ;;
			Opus) dir_Opus="$codecDestDir" ;;
		esac
	done

	for codec in "${listOfCodecs[@]}"; do
		case "$codec" in
			WAV) copyPath_WAV="$copyPath" ;;
			AIFF) copyPath_AIFF="$copyPath" ;;
			CAF) copyPath_CAF="$copyPath" ;;
			FLAC) copyPath_FLAC="$copyPath" ;;
			ALAC) copyPath_ALAC="$copyPath" ;;
			WavPack) copyPath_WavPack="$copyPath" ;;
			WavPackHybrid) copyPath_WavPackHybrid="$copyPath" ;;

			WavPackLossy) copyPath_WavPackLossy="$copyPath" ;;
			MonkeysAudio) copyPath_MonkeysAudio="$copyPath" ;;
			lossyWAV) copyPath_lossyWAV="$copyPath" ;;
			lossyFLAC) copyPath_lossyFLAC="$copyPath" ;;
			lossyWV) copyPath_lossyWV="$copyPath" ;;
			MP3) copyPath_MP3="$copyPath" ;;
			AAC) copyPath_AAC="$copyPath" ;;
			OggVorbis) copyPath_OggVorbis="$copyPath" ;;
			Opus) copyPath_Opus="$copyPath" ;;
		esac
	done
}

getDestDir () {
	local outputCodec="$1" codecDestDir=""

	case "$outputCodec" in
		WAV) codecDestDir="$dir_WAV" ;;
		AIFF) codecDestDir="$dir_AIFF" ;;
		CAF) codecDestDir="$dir_CAF" ;;
		FLAC) codecDestDir="$dir_FLAC" ;;
		ALAC) codecDestDir="$dir_ALAC" ;;
		WavPack) codecDestDir="$dir_WavPack" ;;
		WavPackHybrid) codecDestDir="$dir_WavPackHybrid" ;;
		MonkeysAudio) codecDestDir="$dir_MonkeysAudio" ;;

		WavPackLossy) codecDestDir="$dir_WavPackLossy" ;;
		lossyWAV) codecDestDir="$dir_lossyWAV" ;;
		lossyFLAC) codecDestDir="$dir_lossyFLAC" ;;
		lossyWV) codecDestDir="$dir_lossyWV" ;;
		MP3) codecDestDir="$dir_MP3" ;;
		AAC) codecDestDir="$dir_AAC" ;;
		OggVorbis) codecDestDir="$dir_OggVorbis" ;;
		Opus) codecDestDir="$dir_Opus" ;;
	esac

	if [ -n "$codecDestDir" ]; then
		echo "$codecDestDir"
	else
		echo "$defaultDestDir"
	fi
}

copyPathOrNot () {
	local outputCodec="$1" copyPath

	case "$outputCodec" in
		WAV) copyPath="$copyPath_WAV" ;;
		AIFF) copyPath="$copyPath_AIFF" ;;
		CAF) copyPath="$copyPath_CAF" ;;
		FLAC) copyPath="$copyPath_FLAC" ;;
		ALAC) copyPath="$copyPath_ALAC" ;;
		WavPack) copyPath="$copyPath_WavPack" ;;
		WavPackHybrid) copyPath="$copyPath_WavPackHybrid" ;;

		WavPackLossy) copyPath="$copyPath_WavPackLossy" ;;
		MonkeysAudio) copyPath="$copyPath_MonkeysAudio" ;;
		lossyWAV) copyPath="$copyPath_lossyWAV" ;;
		lossyFLAC) copyPath="$copyPath_lossyFLAC" ;;
		lossyWV) copyPath="$copyPath_lossyWV" ;;
		MP3) copyPath="$copyPath_MP3" ;;
		AAC) copyPath="$copyPath_AAC" ;;
		OggVorbis) copyPath="$copyPath_OggVorbis" ;;
		Opus) copyPath="$copyPath_Opus" ;;
	esac

	if [ -n "$copyPath" ]; then
		echo "$copyPath"
	else
		echo "false"
	fi
}

setCodecOtherFiles () {
	local outputCodec="$1" pattern="$2" listOfCodecs codec

	case "$outputCodec" in
		default) read -a listOfCodecs <<< "$allCodecsString" ;;
		lossless) read -a listOfCodecs <<< "$losslessCodecsString" ;;
		lossy) read -a listOfCodecs <<< "$lossyCodecsString" ;;
		*) read -a listOfCodecs <<< "$outputCodec" ;;
	esac

	for codec in "${listOfCodecs[@]}"; do
		case "$codec" in
			WAV) copyOtherFiles_WAV="$pattern" ;;
			AIFF) copyOtherFiles_AIFF="$pattern" ;;
			CAF) copyOtherFiles_CAF="$pattern" ;;
			FLAC) copyOtherFiles_FLAC="$pattern" ;;
			ALAC) copyOtherFiles_ALAC="$pattern" ;;
			WavPack) copyOtherFiles_WavPack="$pattern" ;;
			WavPackHybrid) copyOtherFiles_WavPackHybrid="$pattern" ;;
			MonkeysAudio) copyOtherFiles_MonkeysAudio="$pattern" ;;

			WavPackLossy) copyOtherFiles_WavPackLossy="$pattern" ;;
			lossyWAV) copyOtherFiles_lossyWAV="$pattern" ;;
			lossyFLAC) copyOtherFiles_lossyFLAC="$pattern" ;;
			lossyWV) copyOtherFiles_lossyWV="$pattern" ;;
			MP3) copyOtherFiles_MP3="$pattern" ;;
			AAC) copyOtherFiles_AAC="$pattern" ;;
			OggVorbis) copyOtherFiles_OggVorbis="$pattern" ;;
			Opus) copyOtherFiles_Opus="$pattern" ;;
		esac
	done
}

getCodecOtherFiles () {
	local outputCodec="$1" otherFilesPattern=""

	case "$outputCodec" in
		WAV) otherFilesPattern="$copyOtherFiles_WAV" ;;
		AIFF) otherFilesPattern="$copyOtherFiles_AIFF" ;;
		CAF) otherFilesPattern="$copyOtherFiles_CAF" ;;
		FLAC) otherFilesPattern="$copyOtherFiles_FLAC" ;;
		ALAC) otherFilesPattern="$copyOtherFiles_ALAC" ;;
		WavPack) otherFilesPattern="$copyOtherFiles_WavPack" ;;
		WavPackHybrid) otherFilesPattern="$copyOtherFiles_WavPackHybrid" ;;
		MonkeysAudio) otherFilesPattern="$copyOtherFiles_MonkeysAudio" ;;

		WavPackLossy) otherFilesPattern="$copyOtherFiles_WavPackLossy" ;;
		lossyWAV) otherFilesPattern="$copyOtherFiles_lossyWAV" ;;
		lossyFLAC) otherFilesPattern="$copyOtherFiles_lossyFLAC" ;;
		lossyWV) otherFilesPattern="$copyOtherFiles_lossyWV" ;;
		MP3) otherFilesPattern="$copyOtherFiles_MP3" ;;
		AAC) otherFilesPattern="$copyOtherFiles_AAC" ;;
		OggVorbis) otherFilesPattern="$copyOtherFiles_OggVorbis" ;;
		Opus) otherFilesPattern="$copyOtherFiles_Opus" ;;
	esac

	echo "$otherFilesPattern"
}

setCodecCoverArtFile () {
	local outputCodec="$1" coverArtFile="$2" listOfCodecs codec

	case "$outputCodec" in
		default) read -a listOfCodecs <<< "$allCodecsString" ;;
		lossless) read -a listOfCodecs <<< "$losslessCodecsString" ;;
		lossy) read -a listOfCodecs <<< "$lossyCodecsString" ;;
		*) read -a listOfCodecs <<< "$outputCodec" ;;
	esac

	for codec in "${listOfCodecs[@]}"; do
		case "$codec" in
			WAV) coverArtFile_WAV="$coverArtFile" ;;
			AIFF) coverArtFile_AIFF="$coverArtFile" ;;
			CAF) coverArtFile_CAF="$coverArtFile" ;;
			FLAC) coverArtFile_FLAC="$coverArtFile" ;;
			ALAC) coverArtFile_ALAC="$coverArtFile" ;;
			WavPack) coverArtFile_WavPack="$coverArtFile" ;;
			WavPackHybrid) coverArtFile_WavPackHybrid="$coverArtFile" ;;
			MonkeysAudio) coverArtFile_MonkeysAudio="$coverArtFile" ;;

			WavPackLossy) coverArtFile_WavPackLossy="$coverArtFile" ;;
			lossyWAV) coverArtFile_lossyWAV="$coverArtFile" ;;
			lossyFLAC) coverArtFile_lossyFLAC="$coverArtFile" ;;
			lossyWV) coverArtFile_lossyWV="$coverArtFile" ;;
			MP3) coverArtFile_MP3="$coverArtFile" ;;
			AAC) coverArtFile_AAC="$coverArtFile" ;;
			OggVorbis) coverArtFile_OggVorbis="$coverArtFile" ;;
			Opus) coverArtFile_Opus="$coverArtFile" ;;
		esac
	done
}

getCodecCoverArtFile () {
	local outputCodec="$1" coverArtFile=""

	case "$outputCodec" in
		WAV) coverArtFile="$coverArtFile_WAV" ;;
		AIFF) coverArtFile="$coverArtFile_AIFF" ;;
		CAF) coverArtFile="$coverArtFile_CAF" ;;
		FLAC) coverArtFile="$coverArtFile_FLAC" ;;
		ALAC) coverArtFile="$coverArtFile_ALAC" ;;
		WavPack) coverArtFile="$coverArtFile_WavPack" ;;
		WavPackHybrid) coverArtFile="$coverArtFile_WavPackHybrid" ;;
		MonkeysAudio) coverArtFile="$coverArtFile_MonkeysAudio" ;;

		WavPackLossy) coverArtFile="$coverArtFile_WavPackLossy" ;;
		lossyWAV) coverArtFile="$coverArtFile_lossyWAV" ;;
		lossyFLAC) coverArtFile="$coverArtFile_lossyFLAC" ;;
		lossyWV) coverArtFile="$coverArtFile_lossyWV" ;;
		MP3) coverArtFile="$coverArtFile_MP3" ;;
		AAC) coverArtFile="$coverArtFile_AAC" ;;
		OggVorbis) coverArtFile="$coverArtFile_OggVorbis" ;;
		Opus) coverArtFile="$coverArtFile_Opus" ;;
	esac

	echo "$coverArtFile"
}

getNumberOfCpuCores () {
	local core lastCpuID currentCpuID totalNumberOfCores=0

	while read line; do
		core="$( echo "$line" | tr -cd '0-9' 2>/dev/null )"
		case "$line" in
			'physical id'*)
				lastCpuID="$currentCpuID"
				currentCpuID="$core"
				;;

			'cpu cores'*)
				if [ "$currentCpuID" != "$lastCpuID" ]; then
					totalNumberOfCores=$(( totalNumberOfCores + core ))
				fi
				;;
		esac
	done < <( grep -E '^(physical id|cpu cores)' '/proc/cpuinfo' 2>/dev/null )

	echo $totalNumberOfCores
}

# main() =======================================================================

if [ -n "$LC_ALL" ]; then
#	export LANG="$LC_ALL"
	unset LC_ALL
fi
export LANG='en_US.UTF-8'
export LC_NUMERIC='C'


datecmd='date' gnudate=false sedcmd='sed' gnused=false statcmd='stat' gnustat=false
if which 'uname' >/dev/null 2>&1 ; then
	OS="$( uname -s )"
	if [ "$OS" = 'Linux' ]; then
		gnudate=true gnused=true gnustat=true
	else
		if which 'gdate' >/dev/null 2>&1; then
			datecmd='gdate' gnudate=true
		fi
		if which 'gsed' >/dev/null 2>&1; then
			sedcmd='gsed' gnused=true
		fi
		if which 'gstat' >/dev/null 2>&1; then
			statcmd='gstat' gnustat=true # FIXME: gstat doesn't always work as expected on macOS
		fi
	fi
fi

checkMainBinaries

maxProcesses=''
if which 'nproc' >/dev/null 2>&1; then # GNU Coreutils installed
	maxProcesses="$( nproc 2>/dev/null )"
elif which 'gnproc' >/dev/null 2>&1; then # GNU Coreutils installed on macOS
	maxProcesses="$( gnproc 2>/dev/null )"
elif [ -e '/proc/cpuinfo' ]; then # Linux
	maxProcesses="$( grep -cF 'cpu MHz' /proc/cpuinfo 2>/dev/null )"
elif [ "$OS" = 'Darwin' ]; then # macOS
	# Many thanks to Tobias Link for helping me port caudec to macOS
	maxProcesses="$( system_profiler -detailLevel full SPHardwareDataType 2>/dev/null | grep -F 'Total Number of Cores:' 2>/dev/null | cut -d ':' -f 2 2>/dev/null | tr -d ' ' | cut -d '(' -f 1 2>/dev/null )"
fi

nProcesses=1
case "$maxProcesses" in
	[1-9]*) nProcesses=$maxProcesses ;;
esac
maxProcessesSetByUser=$nProcesses

losslessCodecsString="WAV AIFF CAF FLAC ALAC WavPack WavPackHybrid MonkeysAudio"
lossyCodecsString="WavPackLossy lossyWAV lossyFLAC lossyWV MP3 AAC OggVorbis Opus"
allCodecsString="${losslessCodecsString} ${lossyCodecsString}"

# Set default values
outputCodecs='' lastCodec='' nCodecs=0 copyWAV=false verbose=true
defaultDestDir="$PWD" linkDir='' gotLinkedDir=false
nLossyWAV=0 copyLossyWAV=false
bitDepth='' samplingRate='' preserveMetadata='' computeReplayGain=false reverseReplayGain=false
applyGain=false applyGainType='' preamp='' convertToStereo='false'
keepExistingFiles=false keepNewerFiles=false macHasVerify=false outputMode='human'
checkFiles=false hashFiles=false touchFiles=false peakReference=0 allFilesAreOpus=true
setArtworkParam=false copyFilesParam=false

if [ "$Self_Called_As" = 'decaude' ]; then
	lastCodec='WAV'
	outputCodecs="$outputCodecs $lastCodec"
	((nCodecs++))
	copyWAV=true
fi

if [ -n "$hashes" ]; then
	hashes="$( echo -n "$hashes" | tr '[:lower:]' '[:upper:]' )"
fi

getCompressionSetting 'AAC' "$compression_AAC" 'caudecrc'
getCompressionSetting 'FLAC' "$compression_FLAC" 'caudecrc'
getCompressionSetting 'lossyWAV' "$compression_lossyWAV" 'caudecrc'
getCompressionSetting 'MonkeysAudio' "$compression_MonkeysAudio" 'caudecrc'
getCompressionSetting 'MP3' "$compression_MP3" 'caudecrc'
getCompressionSetting 'OggVorbis' "$compression_OggVorbis" 'caudecrc'
getCompressionSetting 'Opus' "$compression_Opus" 'caudecrc'
getCompressionSetting 'WavPack' "$compression_WavPack" 'caudecrc'

getConstantBitrate 'AAC' "$bitrate_AAC" 'caudecrc'
getConstantBitrate 'MP3' "$bitrate_MP3" 'caudecrc'
getConstantBitrate 'OggVorbis' "$bitrate_OggVorbis" 'caudecrc'
getConstantBitrate 'Opus' "$bitrate_Opus" 'caudecrc'
getConstantBitrate 'WavPackLossy' "$bitrate_WavPackLossy" 'caudecrc'  # for backwards compatibility

getAverageBitrate 'AAC' "$average_bitrate_AAC" 'caudecrc'
getAverageBitrate 'MP3' "$average_bitrate_MP3" 'caudecrc'
getAverageBitrate 'OggVorbis' "$average_bitrate_OggVorbis" 'caudecrc'
getAverageBitrate 'Opus' "$average_bitrate_Opus" 'caudecrc'
getAverageBitrate 'WavPackLossy' "$average_bitrate_WavPackLossy" 'caudecrc'

getBitrateMode 'AAC' "$AAC_MODE" 'caudecrc'
getBitrateMode 'MP3' "$MP3_MODE" 'caudecrc'
getBitrateMode 'OggVorbis' "$OggVorbis_MODE" 'caudecrc'
getBitrateMode 'Opus' "$Opus_MODE" 'caudecrc'

if which 'mac' >/dev/null 2>&1; then
	if mac 2>&1 | grep -F 'Verify:' >/dev/null 2>&1; then # mac has the patch that adds the -v parameter
		macHasVerify=true
	fi
fi

if [ -n "$defaultDestination" ]; then
	if [ ! -e "$defaultDestination" ]; then
		if ! mkdir -p "$defaultDestination" >/dev/null 2>&1 ; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultDestination}" "$Self_Name: failed to create '\$defaultDestination' (do you have write permissions?)." ; exit $Ex_Cant_Create
		fi
	fi

	if [ -n "$defaultDestination" ]; then
		if [ ! -d "$defaultDestination" ]; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultDestination}" "$Self_Name: '\$defaultDestination' not a directory." ; exit $Ex_Cant_Create
		elif [ ! -w "$defaultDestination" ]; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultDestination}" "$Self_Name: '\$defaultDestination' is not writable (permission denied)." ; exit $Ex_Cant_Create
		else
			if [ "$defaultDestination" != '/' -a "${defaultDestination%/}" != "$defaultDestination" ]; then
				defaultDestination="${defaultDestination%/}"
			fi
			setDestDir "$allCodecString" "$defaultDestination" "true"
			defaultDestDir="$defaultDestination"
		fi
	fi
fi

if [ -n "$defaultLosslessDestination" ]; then
	if [ ! -e "$defaultLosslessDestination" ]; then
		if ! mkdir -p "$defaultLosslessDestination" >/dev/null 2>&1 ; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultLosslessDestination}" "$Self_Name: failed to create '\$defaultLosslessDestination' (do you have write permissions?)." ; exit $Ex_Cant_Create
		fi
	fi

	if [ -n "$defaultLosslessDestination" ]; then
		if [ ! -d "$defaultLosslessDestination" ]; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultLosslessDestination}" "$Self_Name: '\$defaultLosslessDestination' not a directory." ; exit $Ex_Cant_Create
		elif [ ! -w "$defaultLosslessDestination" ]; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultLosslessDestination}" "$Self_Name: '\$defaultLosslessDestination' is not writable (permission denied)." ; exit $Ex_Cant_Create
		else
			if [ "$defaultLosslessDestination" != '/' -a "${defaultLosslessDestination%/}" != "$defaultLosslessDestination" ]; then
				defaultLosslessDestination="${defaultLosslessDestination%/}"
			fi
			setDestDir "$losslessCodecsString" "$defaultLosslessDestination" "true"
		fi
	fi
fi

if [ -n "$defaultLossyDestination" ]; then
	if [ ! -e "$defaultLossyDestination" ]; then
		if ! mkdir -p "$defaultLossyDestination" >/dev/null 2>&1 ; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultLossyDestination}" "$Self_Name: failed to create '\$defaultLossyDestination' (do you have write permissions?)." ; exit $Ex_Cant_Create
		fi
	fi

	if [ -n "$defaultLossyDestination" ]; then
		if [ ! -d "$defaultLossyDestination" ]; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultLossyDestination}" "$Self_Name: '\$defaultLossyDestination' not a directory." ; exit $Ex_Cant_Create
		elif [ ! -w "$defaultLossyDestination" ]; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultLossyDestination}" "$Self_Name: '\$defaultLossyDestination' is not writable (permission denied)." ; exit $Ex_Cant_Create
		else
			if [ "$defaultLossyDestination" != '/' -a "${defaultLossyDestination%/}" != "$defaultLossyDestination" ]; then
				defaultLossyDestination="${defaultLossyDestination%/}"
			fi
			setDestDir "$lossyCodecsString" "$defaultLossyDestination" "true"
		fi
	fi
fi

# defaultLinkedDestination
if [ -n "$defaultLinkedDestination" ]; then
	if [ ! -e "$defaultLinkedDestination" ]; then
		if ! mkdir -p "$defaultLinkedDestination" >/dev/null 2>&1 ; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultLinkedDestination}" "$Self_Name: failed to create '\$defaultLinkedDestination' (do you have write permissions?)." ; exit $Ex_Cant_Create
		fi
	fi

	if [ -n "$defaultLinkedDestination" ]; then
		if [ ! -d "$defaultLinkedDestination" ]; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultLinkedDestination}" "$Self_Name: '\$defaultLinkedDestination' not a directory." ; exit $Ex_Cant_Create
		elif [ ! -w "$defaultLinkedDestination" ]; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultLinkedDestination}" "$Self_Name: '\$defaultLinkedDestination' is not writable (permission denied)." ; exit $Ex_Cant_Create
		else
			if [ "$defaultLinkedDestination" != '/' -a "${defaultLinkedDestination%/}" != "$defaultLinkedDestination" ]; then
				defaultLinkedDestination="${defaultLinkedDestination%/}"
			fi
			gotLinkedDir=true
			linkDir="$defaultLinkedDestination"
		fi
	fi
fi

if [ -n "$setCoverArtworkFileByDefault" ]; then
	setCodecCoverArtFile "default" "$setCoverArtworkFileByDefault"
fi
if [ -n "$setCoverArtworkFileForLosslessByDefault" ]; then
	setCodecCoverArtFile "lossless" "$setCoverArtworkFileForLosslessByDefault"
fi
if [ -n "$setCoverArtworkFileForLossyByDefault" ]; then
	setCodecCoverArtFile "lossy" "$setCoverArtworkFileForLossyByDefault"
fi

if [ -n "$copyOtherFilesByDefault" ]; then
	setCodecOtherFiles "default" "$copyOtherFilesByDefault"
fi
if [ -n "$copyOtherFilesForLosslessByDefault" ]; then
	setCodecOtherFiles "lossless" "$copyOtherFilesForLosslessByDefault"
fi
if [ -n "$copyOtherFilesForLossyByDefault" ]; then
	setCodecOtherFiles "lossy" "$copyOtherFilesForLossyByDefault"
fi

while getopts '2a:B:b:C:c:df:G:ghH:iKkL:l:n:O:o:P:q:r:S:sTtuVZz' o ; do
	case $o in
# -----------------------------------------------------------------------------

		n)
			case "$OPTARG" in
				[0-9]|[0-9][0-9])
					if [ $OPTARG -le $maxProcesses ]; then
						nProcesses=$OPTARG
						maxProcessesSetByUser=$OPTARG
					else
						printMessage 'error' 'usage' 'bad_value' "$Self_Name -n: the number of processes must be an integer between 1 and $maxProcesses" ; exit $Ex_Usage
					fi
					;;

				*) printMessage 'error' 'usage' 'bad_value' "$Self_Name -n: the number of processes must be an integer between 1 and $maxProcesses" ; exit $Ex_Usage ;;
			esac
			;;

		i) ignoreUnsupportedFiles=true ;;

		s) verbose=false ;;

		z) outputMode='machine' ;;

		Z) outputMode='humanAndMachine' ;;

# -----------------------------------------------------------------------------

		b)
			if [ -z "$lastCodec" ]; then
				case "$OPTARG" in
					16|24) bitDepth=$OPTARG ;;
					*) printMessage 'error' 'usage' 'bad_value' "$Self_Name -b: bit depth must be either 16 or 24" ; exit $Ex_Usage
				esac
			else
				case "$lastCodec" in
					AAC) getConstantBitrate 'AAC' "$OPTARG" ; AAC_MODE='CBR' ;;
					MP3) getConstantBitrate 'MP3' "$OPTARG" ; MP3_MODE='CBR' ;;
					OggVorbis) getConstantBitrate 'OggVorbis' "$OPTARG" ; OggVorbis_MODE='CBR' ;;
					Opus) getConstantBitrate 'Opus' "$OPTARG" ; Opus_MODE='CBR' ;;
					WavPackHybrid|WavPackLossy) getAverageBitrate 'WavPackLossy' "$OPTARG" ;; # for backwards compatibility
					*) printMessage 'error' 'usage' 'command_line' "$Self_Name -b: parameter not available with the selected codec" ; exit $Ex_Usage ;;
				esac
			fi
			;;

		r)
			if [ -n "$lastCodec" -a "$Self_Called_As" != 'decaude' ]; then
				printMessage 'error' 'usage' 'command_line' "$Self_Name -r: parameter must be given before -c" ; exit $Ex_Usage
			fi
			case "$OPTARG" in
				44|44.1) samplingRate=44100 ;;
				88|88.2) samplingRate=88200 ;;
				176|176.4) samplingRate=176400 ;;
				352|352.8) samplingRate=352800 ;;
				48|96|192|384) samplingRate="${OPTARG}000" ;;
				44100|48000|88200|96000|176400|192000|352800|384000) samplingRate=$OPTARG ;;
				cd|CD) bitDepth=16 samplingRate=44100 convertToStereo='flat' ;;
				dvd|DVD) bitDepth=16 samplingRate=48000 ;;
				sacd|SACD) bitDepth=24 samplingRate=88200 ;;
				dvda|DVDA|dvdaudio|DVDAUDIO|DVDAudio|bd|BD|bluray|BLURAY|BluRay) bitDepth=24 samplingRate=96000 ;;
				pono|Pono|PONO) bitDepth=24 samplingRate=192000 ;;
				dxd|DXD) bitDepth=24 samplingRate=352800 ;;
				*) printMessage 'error' 'usage' 'bad_value' "$Self_Name -r: sampling rate must be one of 44[100], 48[000], 88[200], 96[000], 176[400], 192[000], 352[800], 384[000], cd, dvd, sacd, dvda, bluray, pono or dxd" ; exit $Ex_Usage
			esac
			;;

		2) convertToStereo='flat' ;;

# -----------------------------------------------------------------------------

		c|C)
			case "$OPTARG" in
				wav)                 lastCodec='WAV' copyWAV=true ;;
				aiff)                lastCodec='AIFF' ;;
				caf)                 lastCodec='CAF' ;;
				flac)                lastCodec='FLAC' ;;
				alac)                lastCodec='ALAC' ;;
				wv)                  lastCodec='WavPack' ;;
				wvh)                 lastCodec='WavPackHybrid' ;;

				wvl)                 lastCodec='WavPackLossy' ;;
				aac)                 lastCodec='AAC' ;;
				ape)                 lastCodec='MonkeysAudio' ;;
				lossyWAV|lossywav)   lastCodec='lossyWAV'; ((nLossyWAV++)) ; copyLossyWAV=true ;;
				lossyFLAC|lossyflac) lastCodec='lossyFLAC'; ((nLossyWAV++)) ;;
				lossyWV|lossywv)     lastCodec='lossyWV'; ((nLossyWAV++)) ;;
				mp3)                 lastCodec='MP3' ;;
				ogg|vorbis)          lastCodec='OggVorbis' ;;
				opus)                lastCodec='Opus' ;;
				*) printMessage 'error' 'usage' 'bad_value' "$Self_Name -c: invalid codec (try $Self_Name -h)" ; exit $Ex_Usage ;;
			esac

			outputCodecs="$outputCodecs $lastCodec"; ((nCodecs++))
			if [ "$o" = 'c' ]; then
				preserveMetadata="${preserveMetadata}x${lastCodec}Y"
			fi

			grep -E "(WavPack.*WavPackLossy)|(WavPackLossy.*WavPack)" < <( echo "$outputCodecs" ) 1>/dev/null 2>/dev/null; rc=$?
			if [ $rc -eq $Ex_Ok ]; then
				printMessage 'error' 'usage' 'bad_value' "$Self_Name -c: don't specify both WavPack[*] and WavPackLossy; choose one or the other."
				printMessage 'error' 'usage' 'bad_value' "$Self_Name -c: if you want both lossless and lossy WavPack, choose -c wvh (possibly with -l DIR)"
				exit $Ex_Usage
			fi

			if [ "$lastCodec" = "WavPackLossy" -a -n "$linkDir" ]; then
				gotLinkedDir=false
				linkDir=""
			fi
			;;

		q)
			if [ -z "$lastCodec" ]; then
				printMessage 'error' 'usage' 'command_line' "$Self_Name -q: you must specify a codec first (-c)" ; exit $Ex_Usage
			fi

			case "$lastCodec" in
				AAC) getCompressionSetting 'AAC' "$OPTARG" ;;
				FLAC) getCompressionSetting 'FLAC' "$OPTARG" ;;
				lossyWAV|lossyFLAC|lossyWV) getCompressionSetting 'lossyWAV' "$OPTARG" ;;
				MonkeysAudio) getCompressionSetting 'MonkeysAudio' "$OPTARG" ;;
				MP3) getCompressionSetting 'MP3' "$OPTARG" ; MP3_MODE='VBR' ;;
				OggVorbis) getCompressionSetting 'OggVorbis' "$OPTARG" ; OggVorbis_MODE='VBR' ;;
				Opus) getCompressionSetting 'Opus' "$OPTARG" ; Opus_MODE='VBR' ;;
				WavPack|WavPackHybrid) getCompressionSetting 'WavPack' "$OPTARG" ;;
				WavPackLossy) getCompressionSetting 'WavPackLossy' "$OPTARG" ;;
				*) printMessage 'error' 'usage' 'command_line' "$Self_Name -q: parameter not available with the selected codec" ; exit $Ex_Usage ;;
			esac ;;

		B)
			if [ -z "$lastCodec" ]; then
				printMessage 'error' 'usage' 'command_line' "$Self_Name -B: you must select a codec first (-c)" ; exit $Ex_Usage
			fi
			case "$lastCodec" in
				AAC) getAverageBitrate 'AAC' "$OPTARG" ; AAC_MODE='ABR' ;;
				MP3) getAverageBitrate 'MP3' "$OPTARG" ; MP3_MODE='ABR' ;;
				OggVorbis) getAverageBitrate 'OggVorbis' "$OPTARG" ; OggVorbis_MODE='ABR' ;;
				Opus) getAverageBitrate 'Opus' "$OPTARG" ; Opus_MODE='ABR' ;;
				WavPackHybrid|WavPackLossy) getAverageBitrate 'WavPackLossy' "$OPTARG" ;;
				*) printMessage 'error' 'usage' 'command_line' "$Self_Name -B: parameter not available with the selected codec" ; exit $Ex_Usage ;;
			esac
			;;

		o)
			lastCodecDestDir="$OPTARG"
			if [ "$lastCodecDestDir" != '/' -a "${lastCodecDestDir%/}" != "$lastCodecDestDir" ]; then
				lastCodecDestDir="${lastCodecDestDir%/}"
			fi
			if [ ! -e "$lastCodecDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${lastCodecDestDir}" "$Self_Name -o: directory doesn't exist. Either create it manually, or try again with -O." ; exit $Ex_Cant_Create
			elif [ ! -d "$lastCodecDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${lastCodecDestDir}" "$Self_Name -o: not a directory." ; exit $Ex_Cant_Create
			elif [ ! -w "$lastCodecDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${lastCodecDestDir}" "$Self_Name -o: directory is not writable (permission denied)." ; exit $Ex_Cant_Create
			fi
			setDestDir "$lastCodec" "$lastCodecDestDir" "false"
			lastCodecDestDir=""
			;;

		O|P)
			lastCodecDestDir="$OPTARG"
			if [ "$lastCodecDestDir" != '/' -a "${lastCodecDestDir%/}" != "$lastCodecDestDir" ]; then
				lastCodecDestDir="${lastCodecDestDir%/}"
			fi
			if [ ! -e "$lastCodecDestDir" ]; then
				if ! mkdir -p "$lastCodecDestDir" >/dev/null 2>&1 ; then
					printMessage 'error' 'usage' 'filesystem' "path:${lastCodecDestDir}" "$Self_Name -O/P: failed to create directory (do you have write permissions?)." ; exit $Ex_Cant_Create
				fi
			elif [ ! -d "$lastCodecDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${lastCodecDestDir}" "$Self_Name -O/P: not a directory." ; exit $Ex_Cant_Create
			elif [ ! -w "$lastCodecDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${lastCodecDestDir}" "$Self_Name -O/P: directory is not writable (permission denied)." ; exit $Ex_Cant_Create
			fi
			if [ "$o" = 'P' ]; then
				setDestDir "$lastCodec" "$lastCodecDestDir" "true"
			else
				setDestDir "$lastCodec" "$lastCodecDestDir" "false"
			fi
			lastCodecDestDir=""
			;;

		# from an original idea by Porcus on https://hydrogenaudio.org/index.php/topic,127856.msg1062957.html#msg1062957
		l)
			if [ "$lastCodec" != "WavPackHybrid" -a $touchFiles = false ]; then
				printMessage 'error' 'usage' 'command_line' "$Self_Name -l: it must be preceded by -c wvh or -T." ; exit $Ex_Usage
			fi
			gotLinkedDir=false
			linkDir="$OPTARG"
			if [ "$linkDir" != '/' -a "${linkDir%/}" != "$linkDir" ]; then
				linkDir="${linkDir%/}"
			fi
			if [ ! -e "$linkDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${linkDir}" "$Self_Name -l: directory doesn't exist. Either create it manually, or try again with -L." ; exit $Ex_Cant_Create
			elif [ ! -d "$linkDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${linkDir}" "$Self_Name -l: not a directory." ; exit $Ex_Cant_Create
			elif [ ! -w "$linkDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${linkDir}" "$Self_Name -l: directory is not writable (permission denied)." ; exit $Ex_Cant_Create
			fi
			gotLinkedDir=true
			;;

		# from an original idea by Porcus on https://hydrogenaudio.org/index.php/topic,127856.msg1062957.html#msg1062957
		L)
			if [ "$lastCodec" != "WavPackHybrid" -a $touchFiles = false ]; then
				printMessage 'error' 'usage' 'command_line' "$Self_Name -L: it must be preceded by -c wvh or -T." ; exit $Ex_Usage
			fi
			gotLinkedDir=false
			linkDir="$OPTARG"
			if [ "$linkDir" != '/' -a "${linkDir%/}" != "$linkDir" ]; then
				linkDir="${linkDir%/}"
			fi
			if [ ! -e "$linkDir" ]; then
				if ! mkdir -p "$linkDir" >/dev/null 2>&1 ; then
					printMessage 'error' 'usage' 'filesystem' "path:${linkDir}" "$Self_Name -L: failed to create directory (do you have write permissions?)." ; exit $Ex_Cant_Create
				fi
			elif [ ! -d "$linkDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${linkDir}" "$Self_Name -L: not a directory." ; exit $Ex_Cant_Create
			elif [ ! -w "$linkDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${linkDir}" "$Self_Name -L: directory is not writable (permission denied)." ; exit $Ex_Cant_Create
			fi
			gotLinkedDir=true
			;;

		a)
			setArtworkParam=true
			case "$OPTARG" in
				*.jpg|*.jpeg|*.png|"")
				 	# "" disables embedding artwork
					if [ -z "$lastCodec" ]; then
						setCodecCoverArtFile "default" "$OPTARG"
					elif [ -n "$lastCodec" ]; then
						setCodecCoverArtFile "$lastCodec" "$OPTARG"
					fi
					;;

				*) printMessage 'error' 'usage' 'bad_value' "$Self_Name -a: the argument must be a JPEG or PNG file" ; exit $Ex_Usage ;;
			esac
			;;

		f)
			copyFilesParam=true
			if [ -z "$lastCodec" ]; then
				setCodecOtherFiles "default" "$OPTARG"
			elif [ -n "$lastCodec" ]; then
				if [ "$lastCodec" = "WavPackHybrid" ]; then
					if [ $gotLinkedDir = true ]; then
						setCodecOtherFiles "WavPackLossy" "$OPTARG"
					else
						setCodecOtherFiles "WavPackHybrid" "$OPTARG"
					fi
				# elif [ "$lastCodec" = "WavPackLossy" ]; then
				# 	setCodecOtherFiles "WavPackLossy" "$OPTARG"
				else
					setCodecOtherFiles "$lastCodec" "$OPTARG"
				fi
			fi
			;;

		k)
			keepExistingFiles=true
			if [ $keepNewerFiles = true ]; then
				printMessage 'error' 'usage' 'command_line' "$Self_Name -k: parameters -k and -K are mutually exclusive. Choose one or the other." ; exit $Ex_Usage
			fi
			;;

		K)
			keepNewerFiles=true
			if [ $keepExistingFiles = true ]; then
				printMessage 'error' 'usage' 'command_line' "$Self_Name -K: parameters -k and -K are mutually exclusive. Choose one or the other." ; exit $Ex_Usage
			fi
			;;

# -----------------------------------------------------------------------------

		d) lastCodec='WAV'; outputCodecs="$outputCodecs $lastCodec"; ((nCodecs++)); copyWAV=true ;;

		t) checkFiles=true ;;

		H)
			case "$OPTARG" in
				crc32|CRC32)   hashes="${hashes}CRC32 "  ;;
				md5|MD5)   hashes="${hashes}MD5 "  ;;
				sha1|SHA1) hashes="${hashes}SHA1 " ;;
				sha256|SHA256) hashes="${hashes}SHA256 " ;;
				sha512|SHA512) hashes="${hashes}SHA512 " ;;
				^crc32|^CRC32)   hashes="${hashes//CRC32/}"  ;;
				^md5|^MD5)   hashes="${hashes//MD5/}"  ;;
				^sha1|^SHA1) hashes="${hashes//SHA1/}" ;;
				^sha256|^SHA256) hashes="${hashes//SHA256/}" ;;
				^sha512|^SHA512) hashes="${hashes//SHA512/}" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$Self_Name -H: hash algorithm must be one of CRC32, MD5, SHA1, SHA256 or SHA512" ; exit $Ex_Usage ;;
			esac
			hashFiles=true
			;;

# -----------------------------------------------------------------------------

		g) computeReplayGain=true ;;

		G)
			if [ -z "$outputCodecs" ]; then
				case "$OPTARG" in
					album) gainValue='ALBUM'; computeReplayGain=true applyGain=true applyGainType="$gainValue" ;;
					track) gainValue='TRACK'; computeReplayGain=true applyGain=true applyGainType="$gainValue"  ;;
					undo) reverseReplayGain=true ;;
					*) printMessage 'error' 'usage' 'bad_value' "$Self_Name -G: MP3 gain type must be 'album', 'track' or 'undo'" ; exit $Ex_Usage ;;
				esac
			else
				case "$OPTARG" in
					album) gainValue='ALBUM' ;;
					track) gainValue='TRACK' ;;
					albumpeak) gainValue='ALBUM_PEAK' ;;
					trackpeak) gainValue='TRACK_PEAK' ;;
					+[0-9]|+[1-9][0-9]) gainValue="${OPTARG}.00" ;; # integer
					+[0-9].[0-9]|+[1-9][0-9].[0-9]) gainValue="${OPTARG}0" ;; # floating point, 1 decimal
					+[0-9].[0-9][0-9]|+[1-9][0-9].[0-9][0-9]) gainValue="$OPTARG" ;; # floating point, 2 decimals
					-[0-9]|-[1-9][0-9]) gainValue="${OPTARG}.00" ;; # integer
					-[0-9].[0-9]|-[1-9][0-9].[0-9]) gainValue="${OPTARG}0" ;; # floating point, 1 decimal
					-[0-9].[0-9][0-9]|-[1-9][0-9].[0-9][0-9]) gainValue="$OPTARG" ;; # floating point, 2 decimals
					*) printMessage 'error' 'usage' 'bad_value' "$Self_Name -G: gain type must be either album or track, albumpeak or trackpeak, or a signed number between -99.99 and +99.99" ; exit $Ex_Usage
				esac
				if [ $applyGain = true ]; then
					case "$applyGainType" in
						ALBUM|TRACK)
							preamp="$gainValue"
							;;

						ALBUM_PEAK|TRACK_PEAK)
							if [ "${gainValue:0:1}" = '-' ]; then
								peakReference="$gainValue"
							fi
							;;
					esac
				else
					applyGainType="$gainValue"
				fi
				applyGain=true
				if [ "${gainValue:1}" = '0.00' ]; then
					printMessage 'error' 'usage' 'bad_value' "$Self_Name -G: gain value must not be equal to 0" ; exit $Ex_Usage
				fi
				unset gainValue
			fi
			;;

# -----------------------------------------------------------------------------

		T) touchFiles=true ;;

# -----------------------------------------------------------------------------

		h) printUsage; exit $Ex_Ok ;;

		V) echo "$Self_Name $Self_Version"; exit $Ex_Ok ;;

# -----------------------------------------------------------------------------

		*) printMessage 'error' 'usage' 'command_line' "Run '$Self_Name -h' for more information." ; exit $Ex_Usage ;;
	esac
done

shift $(( OPTIND - 1 ))
if [ $# -lt 1 ]; then
	if [ "$outputMode" = 'machine' ]; then
		printMachineSyntax
		exit $Ex_Ok
	else
		printUsage 1>&2
		exit $Ex_Usage
	fi
fi

outputCodecs="${outputCodecs# }"
if [ -z "$outputCodecs" ]; then
	gotPCMCodecsOnly=false
else
	gotPCMCodecsOnly=true
	for outputCodec in $outputCodecs; do
		case "$outputCodec" in
			WAV|AIFF|CAF) continue ;;
			*) gotPCMCodecsOnly=false ; break ;;
		esac
	done
fi
if [ $gotPCMCodecsOnly = true ]; then
	hashes=''
else
	hashCRC32=false hashMD5=false hashSHA1=false hashSHA256=false hashSHA512=false
	hashes="${hashes//  / }"
	if [ "${hashes:0:1}" = ' ' ]; then hashes="${hashes:1}"; fi
	hashes="${hashes% }"
	newHashes=''
	for h in $hashes; do
		case "$h" in
			CRC32) if [ $hashCRC32 = false ]; then newHashes="${newHashes}${h} "; hashCRC32=true; fi ;;
			MD5) if [ $hashMD5 = false ]; then newHashes="${newHashes}${h} "; hashMD5=true; fi ;;
			SHA1) if [ $hashSHA1 = false ]; then newHashes="${newHashes}${h} "; hashSHA1=true; fi ;;
			SHA256) if [ $hashSHA256 = false ]; then newHashes="${newHashes}${h} "; hashSHA256=true; fi ;;
			SHA512) if [ $hashSHA512 = false ]; then newHashes="${newHashes}${h} "; hashSHA512=true; fi ;;
		esac
	done
	hashes="${newHashes% }"
fi
unset gotPCMCodecsOnly
if [ -z "$hashes" ]; then hashFiles=false; fi

# transcode, test, replaygain, touch, hash
if [ -z "$outputCodecs" -a $checkFiles = false -a $computeReplayGain = false -a $reverseReplayGain = false -a $touchFiles = false -a $hashFiles = false ]; then
	printMessage 'error' 'usage' 'command_line' "$Self_Name: no action specified"
	exit $Ex_Usage
fi

# transcode
if [ -z "$outputCodecs" ]; then
	if [ $setArtworkParam = true ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -a is only available when transcoding (-c)."
		exit $Ex_Usage
	fi
	if [ $copyFilesParam = true ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -f is only available when transcoding (-c)."
		exit $Ex_Usage
	fi
	if [ $keepExistingFiles = true ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -k is only available when -c has been provided."
		exit $Ex_Usage
	fi
	if [ $keepNewerFiles = true ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -K is only available when -c has been provided."
		exit $Ex_Usage
	fi
fi

# transcode (test, replaygain, touch, hash)
if [ -n "$outputCodecs" ]; then
	if [ $computeReplayGain = true -o $reverseReplayGain = true ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -c/-d and -g/-G are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ $hashFiles = true ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -c/-d and -H are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ $touchFiles = true ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -c/-d and -T are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ $checkFiles = true ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -c/-d and -t are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
fi

# Test files (replaygain, touch, hash)
if [ $checkFiles = true ]; then
	if [ $computeReplayGain = true -o $reverseReplayGain = true ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -t and -g/-G are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ $touchFiles = true ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -t and -T are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ $hashFiles = true ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -t and -H are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
fi

# ReplayGain (test, touch, hash)
if [ $computeReplayGain = true -o $reverseReplayGain = true ]; then
	if [ $checkFiles = true ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -g/-G and -t are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ $touchFiles = true ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -g/-G and -T are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ $hashFiles = true ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -g/-G and -H are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
fi

# Touch files (test, replaygain, hash)
if [ $touchFiles = true ]; then
	if [ $checkFiles = true ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -T and -t are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ $computeReplayGain = true -o $reverseReplayGain = true ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -T and -g/-G are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ $hashFiles = true ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -T and -H are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
fi

# Hash files (test, replaygain, touch)
if [ $hashFiles = true ]; then
	if [ $checkFiles = true ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -H and -t are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ $computeReplayGain = true -o $reverseReplayGain = true ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -H and -g/-G are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ $touchFiles = true ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -H and -T are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
fi

ec=$Ex_Ok
declare -a inputFilesAndDirs=("$@")
declare -a inputFiles=()
declare -a sourceFiles=()
numberOfInputFiles=0
numberOfSourceFiles=0

getInputFiles && checkInputFiles && checkBinaries && handleInstance && setupSwapDir

for signal in INT TERM ABRT PIPE; do
	trap "cleanAbort" $signal
done

if [ -n "$outputCodecs" -a $tagCompressionSetting = true ]; then
	getEncoderVersions
fi

if [ $nCodecs -gt 0 ]; then # action: transcode files
	checkOutputDirectories

	nJobs=$(( numberOfSourceFiles * nCodecs ))
	if [ $nProcesses -gt $nJobs ]; then setNumberOfProcesses $nJobs ; fi
	if [ $gnudate = true ]; then
		time1="$( $datecmd '+%s.%N' )"
	else
		time1="$( $datecmd '+%s' ).0"
	fi
	for ((p=0; p < nProcesses; p++)); do
		transcode &
	done
elif [ $checkFiles = true ]; then
	if [ $nProcesses -gt $numberOfSourceFiles ]; then setNumberOfProcesses $numberOfSourceFiles ; fi
	if [ $gnudate = true ]; then
		time1="$( $datecmd '+%s.%N' )"
	else
		time1="$( $datecmd '+%s' ).0"
	fi
	for ((p=0; p < nProcesses; p++)); do
		testFiles &
	done
elif [ $computeReplayGain = true ]; then
	if [ $nProcesses -gt $numberOfSourceFiles ]; then setNumberOfProcesses $numberOfSourceFiles ; fi
	if [ $gnudate = true ]; then
		time1="$( $datecmd '+%s.%N' )"
	else
		time1="$( $datecmd '+%s' ).0"
	fi
	for ((p=0; p < nProcesses; p++)); do
		computeTrackGains &
	done
elif [ $reverseReplayGain = true ]; then
	if [ $nProcesses -gt $numberOfSourceFiles ]; then setNumberOfProcesses $numberOfSourceFiles ; fi
	if [ $gnudate = true ]; then
		time1="$( $datecmd '+%s.%N' )"
	else
		time1="$( $datecmd '+%s' ).0"
	fi
	if [ $allFilesAreOpus = true ]; then
		reverseOpusTrackGains || ec=$Ex_Ko
	else
		for ((p=0; p < nProcesses; p++)); do
			reverseTrackGains &
		done
	fi
elif [ $touchFiles = true ]; then
	if [ $nProcesses -gt $numberOfSourceFiles ]; then setNumberOfProcesses $numberOfSourceFiles ; fi
	if [ $gnudate = true ]; then
		time1="$( $datecmd '+%s.%N' )"
	else
		time1="$( $datecmd '+%s' ).0"
	fi
	for ((p=0; p < nProcesses; p++)); do
		computeTrackDateTimes &
	done
elif [ $hashFiles = true ]; then
	if [ $nProcesses -gt $numberOfSourceFiles ]; then setNumberOfProcesses $numberOfSourceFiles ; fi
	if [ $gnudate = true ]; then
		time1="$( $datecmd '+%s.%N' )"
	else
		time1="$( $datecmd '+%s' ).0"
	fi
	for ((p=0; p < nProcesses; p++)); do
		computeHashes &
	done
fi
ec=$Ex_Ok ; for p in $( jobs -p ); do wait $p || ec=$Ex_Ko ; done

if [ $ec -eq $Ex_Ok ]; then
	if [ $computeReplayGain = true ]; then
		if [ $allFilesAreOpus = true ]; then
			computeOpusAlbumGain || ec=$Ex_Ko
		else
			if [ $applyGain = false -o "$applyGainType" = 'ALBUM' ]; then
				computeAlbumGain || ec=$Ex_Ko
			fi
		fi
	elif [ $touchFiles = true ]; then
		touchAllFiles || ec=$Ex_Ko
	fi
fi

if [ $gnudate = true ]; then
	time2="$( $datecmd '+%s.%N' )"
else
	time2="$( $datecmd '+%s' ).0"
fi

# print transcoding stats if applicable
if [ $ec -eq $Ex_Ok -a $verbose = true ]; then
	if [ "$outputMode" = 'machine' ]; then
		printMachineStats
	else
		printHumanStats
	fi
fi

cleanExit $ec
