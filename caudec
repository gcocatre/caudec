#!/bin/bash

# Copyright © 2012 - 2025 Guillaume Cocatre-Zilgien <guillaume@cocatre.net>
# https://github.com/gcocatre/caudec
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Global variables =============================================================

me='caudec'
calledAs="${0##*/}"
VERSION='2.0.0'

# EX_USAGE: The command was used incorrectly, e.g., with the wrong number of arguments, a bad flag, a bad syntax in a parameter, or whatever.
# EX_DATAERR: The input data was incorrect in some way. This should only be used for user's data & not system files.
# EX_NOINPUT: An input file (not a system file) did not exist or was not readable. This could also include errors like "No message" to a mailer (if it cared to catch it).
# EX_NOUSER: The user specified did not exist. This might be used for mail addresses or remote logins.
# EX_NOHOST: The host specified did not exist. This is used in mail addresses or network requests.
# EX_UNAVAILABLE: A service is unavailable. This can occur if a support program or file does not exist. This can also be used as a catchall message when something you wanted to do doesn't work, but you don't know why.
# EX_SOFTWARE: An internal software error has been detected. This should be limited to non-operating system related errors as possible.
# EX_OSERR: An operating system error has been detected. This is intended to be used for such things as "cannot fork", "cannot create pipe", or the like. It includes things like getuid returning a user that does not exist in the passwd file.
# EX_OSFILE: Some system file (e.g., /etc/passwd, /etc/utmp, etc.) does not exist, cannot be opened, or has some sort of error (e.g., syntax error).
# EX_CANTCREAT: A (user specified) output file cannot be created.
# EX_IOERR: An error occurred while doing I/O on some file.
# EX_TEMPFAIL: temporary failure, indicating something that is not really an error. In sendmail, this means that a mailer (e.g.) could not create a connection, and the request should be reattempted later.
# EX_PROTOCOL: the remote system returned something that was "not possible" during a protocol exchange.
# EX_NOPERM: You did not have sufficient permission to perform the operation. This is not intended for file system problems, which should use NOINPUT or CANTCREAT, but rather for higher level permissions.

EX_OK=0             # successful termination
EX_KO=1             # unsuccessful termination
EX_USAGE=64         # command line usage error
EX_DATAERR=65       # data format error
EX_NOINPUT=66       # cannot open input
EX_NOUSER=67        # addressee unknown
EX_NOHOST=68        # host name unknown
EX_UNAVAILABLE=69   # service unavailable
EX_SOFTWARE=70      # internal software error
EX_OSERR=71         # system error (e.g., can't fork)
EX_OSFILE=72        # critical OS file missing
EX_CANTCREAT=73     # can't create (user) output file
EX_IOERR=74         # input/output error
EX_TEMPFAIL=75      # temp failure; user is invited to retry
EX_PROTOCOL=76      # remote error in protocol
EX_NOPERM=77        # permission denied
EX_CONFIG=78        # configuration error
EX_INTERRUPT=143    # user interruption (Ctrl+C)

EL="\\033[2K\\033[0G"
OK="\\033[1;32m" KO="\\033[1;31m" WG="\\033[1;33m"
DG="\\033[0;32m" # dark green
DR="\\033[0;31m" # dark red
BR="\\033[0;33m" # brown
DB="\\033[0;34m" # dark blue
BB="\\033[1;34m" # bright blue
NM="\\033[0m" BD="\\033[1;37m" GR="\\033[1;30m" CY="\\033[0;36m" BCY="\\033[1;36m"

# User settings ================================================================

if [ -r '/etc/caudecrc' ]; then
	. '/etc/caudecrc'
	test -n "$maxInstances" && rootMaxInstances="$maxInstances"
	test -n "$maxInputFiles" && rootMaxInputFiles="$maxInputFiles"
	test -n "$preloadSources" && rootPreloadSources="$preloadSources"
fi

if [ -r "${HOME}/.caudecrc" ]; then
	. "${HOME}/.caudecrc"
fi

# sanitize caudecrc input

case "$ID3Padding" in
	[0-9]*) true ;; # nothing to do
	*) ID3Padding=512 ;;
esac

# true by default
if [ "$preventClipping" = "false" ]; then preventClipping=false; else preventClipping=true; fi

# false by default
if [ "$tagCompressionSetting" = "true" ]; then tagCompressionSetting=true; else tagCompressionSetting=false; fi
if [ "$setCompilationFlagWithAlbumArtist" = "true" ]; then setCompilationFlagWithAlbumArtist=true; else setCompilationFlagWithAlbumArtist=false; fi
if [ "$keepWavMetadata" = "true" ]; then keepWavMetadata=true; else keepWavMetadata=false; fi
if [ "$ignoreUnsupportedFiles" = "true" ]; then ignoreUnsupportedFiles=true; else ignoreUnsupportedFiles=false; fi

test -z "$hashes" && hashes=''
if [ -n "$hashes" ]; then
	hashes="${hashes// /}"
	hashes="${hashes//,/ } "
fi

test -z "$tagWhitelist" && tagWhitelist=''
if [ -n "$tagWhitelist" ]; then
	tagWhitelist="${tagWhitelist//, /,}"
	tagWhitelist="${tagWhitelist%,}"
fi

test -z "$tagBlacklist" && tagBlacklist=''
if [ -n "$tagBlacklist" ]; then
	tagBlacklist="${tagBlacklist//, /,}"
	tagBlacklist="${tagBlacklist%,}"
fi

if [ -n "$rootMaxInstances" ]; then maxInstances="$rootMaxInstances"; fi
case "$maxInstances" in
	[0-9]*) if [ $maxInstances -lt 1 ]; then maxInstances=1 ; fi ;;
	*) maxInstances=1 ;;
esac

if [ -n "$rootMaxInputFiles" ]; then maxInputFiles="$rootMaxInputFiles"; fi
case "$maxInputFiles" in
	[0-9]*) if [ $maxInputFiles -lt 1 ]; then maxInputFiles=100 ; fi ;;
	*) maxInputFiles=100 ;;
esac

# true by default
if [ -n "$rootPreloadSources" ]; then preloadSources="$rootPreloadSources"; fi
if [ "$preloadSources" = "false" ]; then preloadSources=false; else preloadSources=true; fi

# true by default
if [ "$enableColors" = "false" ]; then
	enableColors=false
	OK='' KO='' WG='' DG='' NM='' BD='' GR='' CY='' BCY=''
else
	enableColors=true
fi

# true by default
if [ "$useBrightColors" = "false" ]; then
	useBrightColors=false
	OK="$DG" KO="$DR" WG="$BR" CY="$DB"
else
	useBrightColors=true
fi

# Global values ================================================================

piddir='/tmp/caudec'
iodir="${piddir}/io"

maxFlacThreads=128
maxWavPackThreads=12

# Functions ====================================================================

printUsage ()
{
	if [ "$calledAs" = 'decaude' ]; then
		echo "caudec ${VERSION}: multiprocess audio converter
Copyright © 2012 - 2025 Guillaume Cocatre-Zilgien
https://github.com/gcocatre/caudec

Usage: decaude FILES
Decodes FILES to WAV (same as 'caudec -d' and 'caudec -c wav').
Instead of multiple files, one or more directories may be specified.
See also: caudec -h"
	else
		echo "caudec ${VERSION}: multiprocess audio converter
Copyright © 2012 - 2025 Guillaume Cocatre-Zilgien
https://github.com/gcocatre/caudec

Usage: $me [ GLOBAL OPTIONS ] [ PROCESSING ] [ ENCODING/DECODING/RG ] FILES
Operate on multiple audio files at once, in parallel.
Instead of multiple files, one or more directories may be specified.
Multiple codec switches (optionally paired with a -q switch) may be specified.
Supported input files: .wav, .aiff, .caf, .flac, .wv, .ape


Global options:
  -s        be silent, only print errors
  -n N      launch N processes concurrently (1-${maxProcesses});
            by default, the number of CPU cores.

  -o DIR    set existing output directory
  -O DIR    set output directory, create it if it doesn't exist already
  -P DIR    set and create output directory, and mirror the source file's
            path components (e.g. 'a/b/file.flac' => 'DIR/a/b/file.ogg')

  -l DIR    set existing directory for hard linking lossy .wv files from
            WavPackHybrid's output directory
  -L DIR    set and create a directory for hard linking lossy .wv files from
            WavPackHybrid's output directory

  -a FILE   embed cover art FILE into supported files. Specify -a first
            to embed the same file for all supported codecs specified by -c,
            or specify -a after -c to embed cover art only for that codec,
            if supported. FILE must be a filename and that file must be
            located in the source directory.

  -f ARG    copy certain files to the output directory. ARG may be a 'all',
            a comma separated list of files, and / or file extensions preceded
            by a dot. If ARG is a list of files, they must be filenames and
            those files must be located in the source directory.

  -k        keep existing destination files (don't overwrite them)
  -K        keep existing destination files if they're newer than their source

  -T        touch files using metadata to reflect the music's release date
            and duration. Provide all files as arguments, not just audio files,
            although at least one audio file is required for this to work.
            Use with -l when dealing with a hard linked collection (-c wvh).
            Ex: $me -T ~/Music/Lossless/Artist/Album/*
            Ex: $me -T ~/Music/Lossless/Artist/Album/* -l ~/Music/Lossy

  -z        produce machine-parsable output; must be the first parameter on the
            command line to take effect. Run 'caudec -z' on its own to print
            a description of the syntax.

When transcoding to multiple codecs at once (multiple -c parameters),
specify a -o/O/P parameter after each -c parameter in order to set per-codec
output directories. For instance:
\$ caudec -c flac -P '/data/flac' -c mp3 -P '/data/mp3' \"artist/album\"/*.flac

Similarly, specifying -a/-f after a -c parameter will affect only that codec.
For instance:
\$ caudec -c flac -P '/data/flac' -f cover.jpg \\
  -c mp3 -P '/data/mp3' -f folder.jpg \"artist/album\"/*.flac

Processing / resampling options:
  -b BITS   bit depth (16, 24)
  -r HZ     sampling rate in Hz (44100, 48000, 88200, 96000, 176400, 192000,
            352800, 384000)
  -r KHZ    sampling rate in kHz (44[.1], 48, 88[.2], 96, 176[.4], 192, 352[.8],
            384)
  -r cd     equivalent to -b 16 -r 44100 -2 (includes conversion to stereo)
  -r dvd    equivalent to -b 16 -r 48000
  -r sacd   equivalent to -b 24 -r 88200
  -r dvda   equivalent to -b 24 -r 96000
  -r bluray equivalent to -b 24 -r 96000
  -r pono   equivalent to -b 24 -r 192000
  -r dxd    equivalent to -b 24 -r 352800
  -2        convert to stereo: 2.1, 4.0, 5.0, 5.1 and 7.1 audio will be
            downmixed, using proper channel mappings; mono audio will be
            upmixed to dual-mono (stereo with two identical channels)


Encoding options:
  -c CODEC  use specified CODEC: wav, aiff, caf,
            flac, wv (WavPack), wvh (WavPack Hybrid), wvl (WavPack lossy),
            lossyWAV, lossyFLAC, lossyWV, ape (Monkey's Audio), mp3,
            aac (m4a), ogg / vorbis, opus.
            Note that artwork preservation in MP3s requires eyeD3.

  -C CODEC  use specified CODEC, but discard existing metadata

  -q ARG    set compression level (variable bitrate mode; try -q help for
            a list of valid values)

  -b ARG    constant or target bitrate in bits per sample (for -c wvh/wvl)
            or in kilobits per second (for -c wvh/wvl, opus, mp3, ogg/vorbis)

  -B ARG    average bitrate in kilobits per second (for -c mp3, aac (m4a),
            ogg/vorbis, opus)

  -G ARG    MP3: apply Replaygain (album or track) if found in source file
            metadata, after decoding and BEFORE encoding (irreversible).
            Note: it is possible to specify a preamp value with an additional
            -G parameter, for instance '-G album -G -3' or '-G track -G +2'.
            Only use positive preamp values if you know what you're doing.

  -G ARG    MP3: apply peak normalization (albumpeak or trackpeak); this makes
            the tracks as loud as possible without clipping; requires
            Replaygain metadata to be available in the source files.
            Note: it is possible to specify an arbitrary peak reference lower
            than 0dBFS with an additional -G parameter: '-G albumpeak -G -4'.

  -G GAIN   MP3: apply arbitrary GAIN (signed number from -99.99 to +99.99)

  -H HASH   compute hash of raw PCM (CRC32, MD5, SHA1, SHA256 or SHA512,
            lossless codecs and lossyFLAC, lossyWV only)
  -H ^HASH  do NOT compute HASH even if it's in caudecrc


Decoding options:
  -d        decode to WAV (same as -c wav)
  -t        test file integrity
  -H HASH   compute hash of raw PCM (CRC32, MD5, SHA1, SHA256 or SHA512,
            lossless codecs and lossyFLAC, lossyWV only)
  -H ^HASH  do NOT compute HASH even if it's in caudecrc


Replaygain options (mutually exclusive from -c/-d/-t/-T):
  -g        generate Replaygain metadata
  -G ARG    MP3: compute and apply gain of type ARG (album or track)
            (no tags, works everywhere)
  -G ARG    MP3: apply peak normalization (albumpeak or trackpeak);
            this makes the tracks as loud as possible without clipping.
            Note: it is possible to specify an arbitrary peak reference lower
            than 0dBFS with an additional -G parameter: '-G albumpeak -G -4'.
  -G GAIN   MP3: apply arbitrary GAIN (signed number from -99.99 to +99.99).


Information:
  -h        display this help and exit
  -V        output version information and exit


caudec uses a temporary directory for processing files (\$TMPDIR or /tmp by
default). If you wish to use another directory, set the CAUDECDIR environment
variable to its path (export CAUDECDIR=\"/some/dir\"), or set CAUDECDIR in your
configuration file (~/.caudecrc or /etc/caudecrc).

To enable debugging, set the CAUDECDEBUG environment variable to 'true'
(export CAUDECDEBUG='true'). caudec will output some additional information,
as well as a log of errors that occurred while using external tools.

For more help, see the online documentation:
https://github.com/gcocatre/caudec"
	fi
}

printMachineSyntax ()
{
	echo "-------------------------------------------------------------------------------
         Format specification of caudec's machine-parsable output (-z)
-------------------------------------------------------------------------------

Fields are separated with pipes ('|', Unicode: U+007C); pipe characters present
in filenames or messages are replaced with the visually similar 'broken bar'
sign ('¦', Unicode: U+00A6).

status|status_info|status_data|file|message|process_id

status: one of info, success, error, warning, abort.

status_info: optional additional information about the status (usage,
    initialization, decoding, processing, encoding, testing, hashing, debugging,
    track_gain, album_gain, checking_version, aborting, hash_type,
    bitrate_codecName, processing_rate).

status_data: optional data about the status (hash type, hash value, hash error,
    gain value in dB, bitrate in bits per second, processing rate, version
    status). Some status_data keywords:
    * filesystem (filesystem related error or information),
    * server (server related error or information),
    * command_line (command line related error or information),
    * bad_value (user provided a parameter with a bad argument),
    * quota (some limit has been reached),
    * internal (internal software error / warning),
    * no_hash (no hash metadata found),
    * no_hash_tool (no hashing tools available),
    * bad_internal_hash (internal MD5 hash is incorrect),
    * user_agent (user agent sent to caudec's server),
    * up_to_date (caudec is up to date),
    * new_version_available (there's a new version of caudec available),
    * running_newer_version (local copy of caudec is newer than the latest
      available online)

file: path of the file that is affected by the status (if applicable).

message: optional human-readable information about the status.

process_id: identifier (PID) of the caudec process."
}

# status;status_info;status_data;file;message;process_number
genMachineParsableString ()
{
	local pid=''

	if [ -n "$BASHPID" ]; then
		pid="$BASHPID"
	elif [ -n "$$" ]; then
		pid="$$"
	fi

	# replace pipes ('|', Unicode: U+007C) with 'broken bar' signs ('¦', Unicode: U+00A6)
	file="${file//|/¦}"
	msg="${msg//|/¦}"

	case "$msgType" in
		abort) str="$( printf "%s|%s|%s|%s|%s|%s\n" 'info' 'aborting' '' '' 'Aborting.' '' )" ;;

		info)
			if [ -n "$bitrate" ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" 'info' "bitrate_${codec}" "$bitrate" '' "$msg" "$pid" )"
			elif [ -n "$rate" ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" 'info' 'processing_rate' "$rate" '' "$msg" "$pid" )"
			elif [ -n "$hashType" ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" 'info' "$hashType" "$statusData" "$file" '' "$pid" )"
			else
				str="$( printf "%s|%s|%s|%s|%s|%s\n" 'info' "$statusInfo" "$statusData" '' "$msg" "$pid" )"
			fi
			;;

		success)
			if [ "$statusInfo" = 'track_gain' ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$gain" "$file" '' "$pid" )"
			elif [ "$statusInfo" = 'testing' ]; then
				if [ -n "$hashError" ]; then
					str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$hashError" "$file" '' "$pid" )"
				else
					str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$hashType" "$file" '' "$pid" )"
				fi
			elif [ "$statusInfo" = 'album_gain' ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$gain" '' "$msg" "$pid" )"
			else
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$statusData" "$file" "$msg" "$pid" )"
			fi
			;;

		error)
			if [ "$statusInfo" = 'testing' ]; then
				if [ -n "$hashError" ]; then
					str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$hashError" "$file" '' "$pid" )"
				else
					str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$hashType" "$file" '' "$pid" )"
				fi
			elif [ "$statusInfo" = 'album_gain' ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" '' '' "$msg" "$pid" )"
			else
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$statusData" "$file" "$msg" "$pid" )"
			fi
			;;

		warning)
			if [ "$statusInfo" = 'testing' ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$hashError" "$file" "$msg" "$pid" )"
			elif [ -n "$hashError" ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$hashError" "$file" "$msg" "$pid" )"
			else
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$msgType" "$statusInfo" "$statusData" "$file" "$msg" "$pid" )"
			fi
			;;
	esac
}

genHumanReadableString ()
{
	case "$msgType" in
		info)
			if [ -n "$msg" ]; then
				str="$( printf "${GR} * ${NM}%s\n" "$msg" )"
			fi ;;

		abort) str="$( printf "${WG} * ${NM}%s\n" 'Aborting.' )" ;;

		success)
			if [ "$statusInfo" = 'track_gain' ]; then
				str="$( printf "${GR}%2u ${OK}OK ${NM}%9s ${CY}%s${NM}\n" $p "$gain dB" "$fileName" )"
			elif [ "$statusInfo" = 'album_gain' ]; then
				str="$( printf "${GR} * ${OK}OK ${NM}%9s ${NM}%s\n" "$gain dB" 'Album gain' )"
			elif [ "$statusInfo" = 'touch_file' ]; then
				str="$( printf "${GR}%2u ${OK}OK ${NM}%s ${CY}%s${NM}\n" $p "$dateTime" "$fileName" )"
			elif [ "$statusInfo" = 'touch_files' ]; then
				str="$( printf "${GR} * ${OK}OK ${NM}%10s ${NM}%s\n" "$albumTime" "Album length" )"
			elif [ "$statusInfo" = 'testing' ]; then
				if [ -n "$numberOfThreads" ]; then
					if [ $numberOfThreads -lt 2 ]; then
						str="$( printf "${GR}%2u ${GR}%2ux ${OK}OK ${NM}%s ${CY}%s${NM}\n" $p "$numberOfThreads" "$hashType" "$fileName" )"
					elif [ $numberOfThreads -ge 2 -a $numberOfThreads -lt 4 ]; then
						str="$( printf "${GR}%2u ${DG}%2ux ${OK}OK ${NM}%s ${CY}%s${NM}\n" $p "$numberOfThreads" "$hashType" "$fileName" )"
					elif [ $numberOfThreads -ge 4 ]; then
						str="$( printf "${GR}%2u ${OK}%2ux ${OK}OK ${NM}%s ${CY}%s${NM}\n" $p "$numberOfThreads" "$hashType" "$fileName" )"
					fi
				else
					str="$( printf "${GR}%2u ${OK}OK ${NM}%s ${CY}%s${NM}\n" $p "$hashType" "$fileName" )"
				fi
			elif [ -n "$file" ]; then # transcoding or hashing
				if [ -n "$p" ]; then
					if [ -n "$numberOfThreads" ]; then
						if [ $numberOfThreads -lt 2 ]; then
							str="$( printf "${GR}%2u ${GR}%2ux ${OK}OK ${CY}%s${NM}\n" $p "$numberOfThreads" "$fileName" )"
						elif [ $numberOfThreads -ge 2 -a $numberOfThreads -lt 4 ]; then
							str="$( printf "${GR}%2u ${DG}%2ux ${OK}OK ${CY}%s${NM}\n" $p "$numberOfThreads" "$fileName" )"
						elif [ $numberOfThreads -ge 4 ]; then
							str="$( printf "${GR}%2u ${OK}%2ux ${OK}OK ${CY}%s${NM}\n" $p "$numberOfThreads" "$fileName" )"
						fi
					else
						str="$( printf "${GR}%2u ${OK}OK ${CY}%s${NM}\n" $p "$fileName" )"
					fi
				else
					str="$( printf "${GR} * ${OK}OK ${CY}%s${NM}\n" "$fileName" )"
				fi
			elif [ -n "$msg" ]; then
				str="$( printf "${GR} * ${OK}OK${NM}: %s\n" "$msg" )"
			fi
			;;

		error)
			if [ "$statusInfo" = 'decoding' ]; then
				str="$( printf "${GR}%2u ${KO}DC ${CY}%s${NM}\n" $p "$fileName" )"
			elif [ "$statusInfo" = 'processing' ]; then
				str="$( printf "${GR}%2u ${KO}PR ${CY}%s${NM}\n" $p "$fileName" )"
			elif [ "$statusInfo" = 'testing' ]; then
				if [ -n "$hashType" ]; then
					str="$( printf "${GR}%2u ${KO}ER ${NM}%s ${CY}%s${NM}\n" $p "$hashType" "$fileName" )"
				elif [ -n "$msg" ]; then
					str="$( printf "${GR}%2u ${KO}ER ${CY}%s${NM}: %s\n" $p "$fileName" "$msg" )"
				else
					str="$( printf "${GR}%2u ${KO}ER ${CY}%s${NM}\n" $p "$fileName" )"
				fi
			elif [ -n "$file" ]; then
				if [ -n "$msg" ]; then
					if [ -n "$p" ]; then
						str="$( printf "${GR}%2u ${KO}ER ${CY}%s${NM}: %s\n" $p "$fileName" "$msg" )"
					else
						str="$( printf "${GR} * ${KO}ER ${CY}%s${NM}: %s\n" "$fileName" "$msg" )"
					fi
				else
					if [ -n "$p" ]; then
						str="$( printf "${GR}%2u ${KO}ER ${CY}%s${NM}\n" $p "$fileName" )"
					else
						str="$( printf "${GR} * ${KO}ER ${CY}%s${NM}\n" "$fileName" )"
					fi
				fi
			elif [ -n "$msg" ]; then
				if [ -n "$p" ]; then
					str="$( printf "${GR}%2u ${KO}ER${NM}: %s\n" $p "$msg" )"
				else
					str="$( printf "${GR} * ${KO}ER${NM}: %s\n" "$msg" )"
				fi
			fi
			;;

		warning)
			if [ -n "$file" ]; then
				if [ -n "$p" ]; then
					str="$( printf "${GR}%2u ${WG}WG ${CY}%s${NM}: %s\n" $p "$fileName" "$msg" )"
				else
					str="$( printf "${GR} * ${WG}WG ${CY}%s${NM}: %s\n" "$fileName" "$msg" )"
				fi
			else
				if [ -n "$p" ]; then
					str="$( printf "${GR}%2u ${WG}WG${NM}: %s\n" $p "$msg" )"
				else
					str="$( printf "${GR} * ${WG}WG${NM}: %s\n" "$msg" )"
				fi
			fi
			;;
	esac
}

printMessage ()
{
	local msgType='info' msgVerbose='default' msgDebug='normal' msgOut='stdout' statusInfo='' statusData='' file='' path='' filePath='' msg='' p='' numberOfThreads='' hashType='' hashError='' gain='' bitrate='' rate='' codec='' str=''

	for a in "$@"; do
		case "$a" in
			info) msgType="$a" msgVerbose='verbose' ;;
			success) msgType="$a" msgVerbose='verbose' ;;
			warning|error|abort) msgType="$a" msgOut='stderr' ;;
			verbose) msgVerbose='verbose' ;;
			debug) msgDebug='debug' statusInfo='debugging' ;;
			stderr) msgOut='stderr' ;;
			initialization|usage|encoding|processing|decoding|hashing|testing|album_gain|track_gain|touch_file|touch_files|checking_version) statusInfo="$a" ;;
			unsupported|quota|bad_value|filesystem|command_line|internal|user_agent) statusData="$a" ;;
			server|up_to_date|new_version_available|running_newer_version) statusData="$a" ;;
			file:*) file="${a#file:}"; filePath="$( dirname "$file" )"; fileName="$( basename "$file" )" ;;
			path:*) file="${a#path:}"; fileName="$file" ;;
			+*dB|-*dB) gain="${a% dB}" ;;
			*bps) bitrate="${a%bps}" ;;
			*x) rate="${a%x}" ;;
			bitrate_*) codec="${a#bitrate_}" ;;
			[0-9]*) p="$a" ;;
			threads:[0-9]*) numberOfThreads="${a#threads:}" ;;
			dateTime:[0-9]*) dateTime="${a#dateTime:}" ;;
			albumTime:[0-9:]*) albumTime="${a#albumTime:}" ;;

			CRC32|MD5|SHA1|SHA256|SHA512) hashType="$a" ;;
			no_hash|no_hash_tool|bad_internal_hash) hashError="$a" ;;

			CRC32=*) statusData="${a#CRC32=}" ;;
			MD5=*) statusData="${a#MD5=}" ;;
			SHA1=*) statusData="${a#SHA1=}" ;;
			SHA256=*) statusData="${a#SHA256=}" ;;
			SHA512=*) statusData="${a#SHA512=}" ;;

			*) msg="$a" ;;
		esac
	done

	if [ "$msgVerbose" = 'verbose' -a "$verbose" != 'true' ]; then return $EX_OK; fi
	if [ "$msgDebug" = 'debug' -a -z "$CAUDECDEBUG" ]; then return $EX_OK; fi

	if [ "$outputMode" = 'machine' ]; then
		genMachineParsableString
	else
		genHumanReadableString
	fi

	if [ -n "$str" ]; then
		if [ "$msgOut" = 'stderr' ]; then
			echo -e "$str" 1>&2
		else
			echo -e "$str"
		fi
	fi

	return $EX_OK
}

getCompressionSetting ()
{
	local c="$1" v="$2" s="$3" errormsg="$me -q:"

	if [ -n "$s" ]; then
		errormsg="Configuration error (caudecrc):"
	fi

	case "$c" in
		FLAC)
			case "$v" in
				[0-8]) compression_FLAC="$v" ;;
				f|fast) compression_FLAC=0 ;;
				b|best) compression_FLAC=8 ;;
				'') compression_FLAC=5 ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg compression level for $c must be an integer between 0 and 8, or one of fast or best" ; exit $EX_USAGE ;;
			esac
			;;

		WavPack|WavPackHybrid|WavPackLossy)
			case "$v" in
				x|x[1-6]|g|gx|gx[1-6]|f|fx|fx[1-6]|h|hx|hx[1-6]|hh|hhx|hhx[1-6]) compression_WavPack="$v" ;;
				'') compression_WavPack='g' ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg compression level for $c must be a combination of [f|g|h|hh][x[1-6]]" ; exit $EX_USAGE ;;
			esac
			;;

		MonkeysAudio)
			case "$v" in
				[1-5]) compression_MonkeysAudio="$v" ;;
				fast) compression_MonkeysAudio=1 ;;
				normal) compression_MonkeysAudio=2 ;;
				high) compression_MonkeysAudio=3 ;;
				extra*) compression_MonkeysAudio=4 ;;
				insane) compression_MonkeysAudio=5 ;;
				'') compression_MonkeysAudio=2 ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg compression level for $c must be a number between 1 and 5, or one of fast, normal, high, extra, insane" ; exit $EX_USAGE ;;
			esac
			;;

		lossyWAV|lossyFLAC|lossyWV)
			case "$v" in
				x|p|c|s|h|e|i) compression_lossyWAV="$( echo "$v" | tr '[:lower:]' '[:upper:]' )" ;;
				X|P|C|S|H|E|I) compression_lossyWAV="$v" ;;
				extraportable) compression_lossyWAV='X' ;;
				portable) compression_lossyWAV='P' ;;
				economic) compression_lossyWAV='C' ;;
				standard) compression_lossyWAV='S' ;;
				high) compression_lossyWAV='H' ;;
				extreme) compression_lossyWAV='E' ;;
				insane) compression_lossyWAV='I' ;;
				'') compression_lossyWAV='S' ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg compression level for $c must be one of X, P, C, S, H, E, I, or one of extraportable, portable, economic, standard, high, extreme or insane" ; exit $EX_USAGE ;;
			esac
			;;

		MP3)
			case "$v" in
				[0-9]) compression_MP3="$v" ;;
				medium) compression_MP3=4 ;;
				standard) compression_MP3=2 ;;
				extreme) compression_MP3=0 ;;
				insane|320) compression_MP3=320 ;;
				'') compression_MP3=2 ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg compression level for $c must be an integer between 0 and 9 or one of medium, standard, extreme, insane or 320" ; exit $EX_USAGE ;;
			esac
			;;

		OggVorbis)
			case "$v" in
				[0-9]|10) compression_OggVorbis="$v" ;;
				'') compression_OggVorbis=3 ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg compression level for $c must be an integer between 0 and 10" ; exit $EX_USAGE ;;
			esac
			;;

		Opus)
			if [ -z "$v" ]; then
				compression_Opus=128
			else
				case "$v" in
					[6-9]|[1-9][0-9]|[1-3][0-9][0-9]) true ;;
					*) printMessage 'error' 'usage' 'bad_value' "$errormsg target bitrate for $c must be an integer between 6 and 320 in kilobits per second" ; exit $EX_USAGE ;;
				esac
				if [ $v -lt 6 -o $v -gt 320 ]; then
					printMessage 'error' 'usage' 'bad_value' "$errormsg target bitrate for $c must be an integer between 6 and 320 in kilobits per second" ; exit $EX_USAGE
				fi
				compression_Opus="$v"
			fi
			;;
	esac
}

getConstantBitrate ()
{
	local c="$1" v="$2" s="$3" errormsg="$me -b:"

	if [ -n "$s" ]; then
		errormsg="Configuration error (caudecrc):"
	fi

	case "$c" in
		WavPackHybrid|WavPackLossy)
			if [ -z "$v" ]; then
				bitrate_WavPackLossy=320
			else
				case "$v" in
					[2-9]|[2-9].[0-9]|1[0-9]|1[0-9].[0-9]|2[0-3]|2[0-3].[0-9]) true ;;
					[2-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]) true ;;
					*) printMessage 'error' 'usage' 'bad_value' "$errormsg target bitrate for $c must be a float between 2.0 and 23.9 in bits per sample, or an integer between 24 and 9600 in kilobits per second" ; exit $EX_USAGE ;;
				esac
				if [ "${v%.*}" -lt 2 -o "${v%.*}" -gt 9600 ]; then
					printMessage 'error' 'usage' 'bad_value' "$errormsg target bitrate for $c must be a float between 2.0 and 23.9 in bits per sample, or an integer between 24 and 9600 in kilobits per second" ; exit $EX_USAGE
				fi
				bitrate_WavPackLossy="$v"
			fi
			;;

		MP3)
			if [ -z "$v" ]; then
				bitrate_MP3=320
			else
				case "$v" in
					1[6-9]|[2-9][0-9]|[1-2][0-9][0-9]|3[0-1][0-9]|320) bitrate_MP3="$v" ;;
					*) printMessage 'error' 'usage' 'bad_value' "$errormsg constant bitrate for $c must be an integer between 16 and 320 in kilobits per second" ; exit $EX_USAGE ;;
				esac
			fi
			;;

		OggVorbis)
			if [ -z "$v" ]; then
				bitrate_OggVorbis=256
			else
				case "$v" in
					3[2-9][4-9][0-9]|[1-4][0-9][0-9]|500) bitrate_OggVorbis="$v" ;;
					*) printMessage 'error' 'usage' 'bad_value' "$errormsg constant bitrate for $c must be an integer between 32 and 500 in kilobits per second" ; exit $EX_USAGE ;;
				esac
			fi
			;;

		Opus)
			if [ -z "$v" ]; then
				bitrate_Opus=128
			else
				case "$v" in
					[6-9]|[1-9][0-9]|[1-3][0-9][0-9]) true ;;
					*) printMessage 'error' 'usage' 'bad_value' "$errormsg constant bitrate for $c must be an integer between 6 and 320 in kilobits per second" ; exit $EX_USAGE ;;
				esac
				if [ $v -lt 6 -o $v -gt 320 ]; then
					printMessage 'error' 'usage' 'bad_value' "$errormsg constant bitrate for $c must be an integer between 6 and 320 in kilobits per second" ; exit $EX_USAGE
				fi
				bitrate_Opus="$v"
			fi
			;;
	esac
}

getAverageBitrate ()
{
	local c="$1" v="$2" s="$3" errormsg="$me -B:"

	if [ -n "$s" ]; then
		errormsg="Configuration error (caudecrc):"
	fi

	case "$c" in
		MP3)
			if [ -z "$v" ]; then
				average_bitrate_MP3=256
			else
				case "$v" in
					[8-9]|[1-9][0-9]|[1-2][0-9][0-9]|30[0-9]|310) average_bitrate_MP3="$v" ;;
					*) printMessage 'error' 'usage' 'bad_value' "$errormsg average bitrate for $c must be an integer between 8 and 310 in kilobits per second" ; exit $EX_USAGE ;;
				esac
			fi
			;;

		AAC)
			if [ -z "$v" ]; then
				average_bitrate_AAC=256
			else
				case "$v" in
					[0-9]|[1-9][0-9]|[1-2][0-9][0-9]|3[0-1][0-9]|320) average_bitrate_AAC="$v" ;;
					*) printMessage 'error' 'usage' 'bad_value' "$errormsg average bitrate for $c must be an integer between 0 and 320 in kilobits per second" ; exit $EX_USAGE ;;
				esac
			fi
			;;

		OggVorbis)
			if [ -z "$v" ]; then
				average_bitrate_OggVorbis=256
			else
				case "$v" in
					3[2-9][4-9][0-9]|[1-4][0-9][0-9]|500) average_bitrate_OggVorbis="$v" ;;
					*) printMessage 'error' 'usage' 'bad_value' "$errormsg average bitrate for $c must be an integer between 32 and 500 in kilobits per second" ; exit $EX_USAGE ;;
				esac
			fi
			;;

		Opus)
			if [ -z "$v" ]; then
				average_bitrate_Opus=128
			else
				case "$v" in
					[6-9]|[1-9][0-9]|[1-3][0-9][0-9]) true ;;
					*) printMessage 'error' 'usage' 'bad_value' "$errormsg average bitrate for $c must be an integer between 6 and 320 in kilobits per second" ; exit $EX_USAGE ;;
				esac
				if [ $v -lt 6 -o $v -gt 320 ]; then
					printMessage 'error' 'usage' 'bad_value' "$errormsg average bitrate for $c must be an integer between 6 and 320 in kilobits per second" ; exit $EX_USAGE
				fi
				average_bitrate_Opus="$v"
			fi
			;;
	esac
}

getBitrateMode ()
{
	local c="$1" mode="$2"

	case "$mode" in
		cbr|abr|vbr) mode="$( echo "$mode" | tr '[:lower:]' '[:upper:]' )" ;;
		CBR|ABR|VBR) true ;;
		'') mode='VBR' ;;
		*) printMessage 'error' 'usage' 'bad_value' "Configuration error (caudecrc): bitrate mode for $c must be one of VBR, ABR or CBR" ; exit $EX_USAGE ;;
	esac

	case "$c" in
		MP3) MP3_MODE="$mode" ;;
		AAC) AAC_MODE="ABR" ;;
		OggVorbis) OggVorbis_MODE="$mode" ;;
		Opus) Opus_MODE="$mode" ;;
	esac
}

cleanExit ()
{
	local nLines=0 swapDirBasename

	if [ -n "$CAUDECDEBUG" -a "$verbose" = "true" -a "$outputMode" != 'machine' -a $1 -ne $EX_OK -a $1 -ne $EX_INTERRUPT -a -e "$errorLogFile" ]; then
		nLines="$( cat "$errorLogFile" 2>/dev/null | wc -l | tr -cd '0-9' )"
		if [ $nLines -gt 0 ]; then
			echo -e "\nError Log:\n================================================================================" 1>&2
			cat "$errorLogFile" 1>&2
		fi
	fi

	if [ -n "$SWAPDIR" ]; then
		rm -rf "$SWAPDIR"
		swapDirBasename="$( basename "$SWAPDIR" )"
		rm "${piddir}"/"${swapDirBasename}"
	fi
	test -n "$TDIR" && rm -rf "$TDIR"

	for f in "$instanceDir"/ioLockFiles/* ; do
		if [ -e "$f" ]; then
			echo '' > "${iodir}/${f##*/}.lock" 2>/dev/null
			mv "${iodir}/${f##*/}.lock" "${iodir}/${f##*/}" >/dev/null 2>&1
		fi
	done

	rm -rf "$instanceDir"
	cleanUpInstances
	ls -d "${piddir}"/instance.* >/dev/null 2>&1 || rm -rf "$iodir"

	rm -rf "$piddir" >/dev/null 2>&1

	exit $1
}

cleanAbort ()
{
	echo
	printMessage 'abort'
	kill $( jobs -p ) >/dev/null 2>&1
	cleanExit $EX_INTERRUPT
}

getInputFiles ()
{
	local fileIndex=0 fileOrDir ec=$EX_OK ext

	for fileOrDir in "${inputFilesAndDirs[@]}"; do
		if [ -d "$fileOrDir" ]; then
			if [ -r "$fileOrDir" ]; then
				if [ "$OS" = 'Linux' ]; then
					while IFS= read -d $'\0' -r file ; do
						if [ -f "$file" -a -r "$file" ]; then
							inputFiles[$fileIndex]="$file"
							((fileIndex++))
						fi
					done < <(find "$fileOrDir" -type f -regex '.*\.\(wav\|aiff\|caf\|flac\|wv\|ape\|mp3\|m4a\|ogg\|opus\)$' -print0 2>/dev/null)
				else
					while IFS= read -d $'\0' -r file ; do
						if [ -f "$file" -a -r "$file" ]; then
							inputFiles[$fileIndex]="$file"
							((fileIndex++))
						fi
					done < <(find -E "$fileOrDir" -type f -regex '.*\.(wav|aiff|caf|flac|wv|ape|mp3|m4a|ogg|opus)$' -print0 2>/dev/null)
				fi
			else
				printMessage 'warning' 'usage' 'filesystem' "path:${fileOrDir}" 'directory is not readable (permission denied).' ; ec=$EX_NOINPUT
			fi
		else
			inputFiles[$fileIndex]="$fileOrDir"
			((fileIndex++))
		fi
	done

	for fileOrDir in "${inputFiles[@]}"; do
		ext="${fileOrDir##*.}"
		if [ "$ext" != "opus" ]; then
			allFilesAreOpus=false
		fi
	done

	unset inputFilesAndDirs
	if [ $ec -eq $EX_OK ]; then
		return $EX_OK
	else
		printMessage 'abort' 'verbose'
		cleanExit $ec
	fi
}

checkInputFiles ()
{
	local file ec=$EX_OK bn dn commonFileExtension="" fileExtension="" fileExtensionAreAllTheSame=true refDn cdpath pdpath basenames='' isf=0 keepInputFile errorMSG gotExistingFiles=false nChannels=0 gotAudioFile=false

	numberOfInputFiles="${#inputFiles[@]}"

	if [ $numberOfInputFiles -gt $maxInputFiles ]; then
		printMessage 'warning' 'usage' 'quota' "the number of input files ($numberOfInputFiles) is greater than maxInputFiles=${maxInputFiles}."
		printMessage 'abort'
		if [ "$outputMode" != 'machine' ]; then
			echo 1>&2
			echo "If you're processing multiple directories, try running caudec in a loop:
find * -type f -name '*.flac' -exec dirname '{}' ';' | sort -u | while read d;
do echo \"\$d\"; caudec -s -K -P /some/destination/dir -c ogg \"\$d\"/*.flac; done" 1>&2
		fi
		cleanExit $EX_USAGE
	fi

	for file in "${inputFiles[@]}" ; do
		fileExtension="${file##*.}"
		if [ -z "$commonFileExtension" ]; then
			commonFileExtension="$fileExtension"
		elif [ "$fileExtension" != "$commonFileExtension" ]; then
			fileExtensionAreAllTheSame=false
		fi
		keepInputFile=false
		dn="$( dirname "$file" )"
		if [ ! -e "$file" ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${file}" 'no such file.' ; ec=$EX_NOINPUT
		elif [ ! -f "$file" ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${file}" 'not a regular file.' ; ec=$EX_DATAERR
		elif [ ! -r "$file" ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${file}" 'cannot open file for reading (permission denied).' ; ec=$EX_NOINPUT
		elif [ ! -w "$file" -a $computeReplaygain = true ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${file}" 'cannot open file for writing (permission denied).' ; ec=$EX_CANTCREAT
		elif [ ! -w "$file" -a $actionHash = true ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${file}" 'cannot open file for writing (permission denied).' ; ec=$EX_CANTCREAT
		elif [ ! -w "$file" -a $touchFiles = true ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${file}" 'refusing to touch file that is read-only.' ; ec=$EX_CANTCREAT
		else
			if [ -z "$refDn" ] ; then refDn="$dn"; fi # for touching mtime files
			if [ $copyPath = true ]; then
				cdpath='/./' pdpath='/../'
				if [ "${file:0:2}" = './' -o "${f:0:3}" = '../' -o "$dn" != "${dn//$cdpath/@}" -o "$dn" != "${dn//$pdpath/@}" ]; then
					printMessage 'warning' 'usage' 'filesystem' "path:${f}" "can't use paths containing ./ or ../ with caudec -P." ; ec=$EX_USAGE
					continue
				fi
			fi

			if [ -n "$outputCodecs" ]; then # transcode
				bn="$( basename "$file" )"
				bn="${bn%.*}"
				if [ $copyPath = true ]; then
					bn="x${dn#/}/${bn%.lossy}Y";
				else
					bn="x${bn%.lossy}Y";
				fi
				if [ "$basenames" != "${basenames//$bn/@}" ]; then
					printMessage 'warning' 'usage' 'filesystem' "file:${file}" "there's already an input file with the same basename." ; ec=$EX_DATAERR
					continue
				fi
				basenames="${basenames}${bn}"

				if [ $keepExistingFiles = true -o $keepNewerFiles = true ]; then
					sourceFile="$file"
					for outputCodec in $outputCodecs; do
						getFileProps "$sourceFile" "$outputCodec"
						if [ ! -e "$destFile" ]; then
							keepInputFile=true; break
						elif [ $keepNewerFiles = true ]; then
							if ! isFileNewer "$destFile" "$sourceFile"; then
								keepInputFile=true; break
							fi
						fi
					done

					if [ $keepInputFile = false ]; then
						gotExistingFiles=true
						continue
					fi
				fi
				keepInputFile=false
			fi

			if [ -n "$outputCodecs" ]; then # transcode
				case "$file" in
					*.wav|*.aiff|*.caf|*.flac|*.wv|*.ape) keepInputFile=true ;;
					*)
						if [ $ignoreUnsupportedFiles = true ]; then
							continue
						else
							printMessage 'warning' 'processing' 'unsupported' "file:${file}" 'unsupported format.' ; ec=$EX_DATAERR ; continue
						fi
						;;
				esac
			else # actions other than transcoding
				if [ $checkFiles = true -o $actionHash = true ]; then
					case "$file" in
						*.flac|*.wv|*.ape) keepInputFile=true ;;
						*)
							if [ $ignoreUnsupportedFiles = true ]; then
								continue
							else
								printMessage 'warning' 'processing' 'unsupported' "file:${file}" 'unsupported format.' ; ec=$EX_DATAERR ; continue
							fi
							;;
					esac
				fi

				if [ $computeReplaygain = true ]; then
					if [ $fileExtensionAreAllTheSame = false ]; then
						printMessage 'error' 'usage' 'filesystem' "file:${file}" "all files must have the same file extension" ; ec=$EX_DATAERR
					else
						case "$file" in
							*.flac|*.wv|*.mp3|*.ogg)
								nChannels="$( getNumberOfChannels "$file" )"
								if [ $nChannels -le 2 ]; then
									keepInputFile=true
								else
									if [ $ignoreUnsupportedFiles = true ]; then
										continue
									else
										printMessage 'warning' 'processing' 'unsupported' "file:${file}" 'unsupported format (neither mono or stereo).' ; ec=$EX_DATAERR ; continue
									fi
								fi
								;;

							*.opus) keepInputFile=true ;;

							*)
								if [ $ignoreUnsupportedFiles = true ]; then
									continue
								else
									printMessage 'warning' 'processing' 'unsupported' "file:${file}" 'unsupported format.' ; ec=$EX_DATAERR ; continue
								fi
								;;
						esac
					fi
				fi

				if [ $applyGain = true ]; then
					case "$file" in
						*.mp3) keepInputFile=true ;;
						*)
							if [ $ignoreUnsupportedFiles = true ]; then
								continue
							else
								printMessage 'warning' 'processing' 'unsupported' "file:${file}" 'unsupported format.' ; ec=$EX_DATAERR ; continue
							fi
							;;
					esac
				fi

				if [ $touchFiles = true ]; then
					if [ "$dn" != "$refDn" ]; then
						printMessage 'error' 'usage' 'filesystem' "all files must be in the same directory" ; ec=$EX_DATAERR
						printMessage 'abort' 'verbose'
						cleanExit $ec
					fi
					case "$file" in
						*.flac|*.ogg|*.m4a|*.wv|*.ape|*.opus) gotAudioFile=true ;;
					esac
					sourceFiles[$isf]="$file"
					((isf++))
				fi
			fi
		fi

		if [ $keepInputFile = true ]; then
			sourceFiles[$isf]="$file"
			((isf++))
		fi
	done

	if [ $touchFiles = true -a $gotAudioFile = false ]; then
		printMessage 'warning' 'processing' 'unsupported' 'at least one supported audio file is required.'; ec=$EX_DATAERR
		printMessage 'abort' 'verbose'
		cleanExit $ec
	fi

	unset inputFiles

	if [ $ec -ne $EX_OK ]; then
		printMessage 'abort'
		cleanExit $ec
	elif [ $isf -eq 0 ]; then
		if [ $gotExistingFiles = true ]; then
			if [ $keepExistingFiles = true ]; then
				printMessage 'warning' 'usage' 'filesystem' 'verbose' "-k: all destination files exist already, nothing to do."
			elif [ $keepNewerFiles = true ]; then
				printMessage 'warning' 'usage' 'filesystem' 'verbose' "-K: all destination files are newer than their source, nothing to do."
			fi
		else
			printMessage 'warning' 'usage' 'filesystem' 'verbose' "no files to work with, nothing to do."
		fi
		printMessage 'abort' 'verbose'
		cleanExit $ec
	else
		nTracks="${#sourceFiles[@]}"
		return $EX_OK
	fi
}

checkOutputDirectories ()
{
	local outputCodec codecFullName codecDestDir

	for outputCodec in $outputCodecs; do
		codecFullName="$( getCodecFullName "$outputCodec" )"
		codecDestDir="$( getDestDir "$outputCodec")"
		if [ ! -e "$codecDestDir" ]; then
			if ! mkdir -p "$codecDestDir" >/dev/null 2>&1 ; then
				printMessage 'error' 'usage' 'filesystem' "path:${codecDestDir}" "$me -O/P: failed to create directory, do you have write permissions? ($codecFullName)" ; exit $EX_CANTCREAT
			fi
		elif [ ! -d "$codecDestDir" ]; then
			if [ "$codecDestDir" = "$defaultDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${codecDestDir}" "$me: not a directory ($codecFullName)." ; exit $EX_CANTCREAT
			else
				printMessage 'error' 'usage' 'filesystem' "path:${codecDestDir}" "$me -O/P: not a directory ($codecFullName)" ; exit $EX_CANTCREAT
			fi
		elif [ ! -w "$codecDestDir" ]; then
			if [ "$codecDestDir" = "$defaultDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${codecDestDir}" "$me: permission denied, not writable ($codecFullName)" ; exit $EX_CANTCREAT
			else
				printMessage 'error' 'usage' 'filesystem' "path:${codecDestDir}" "$me -O/P: permission denied, not writable ($codecFullName)" ; exit $EX_CANTCREAT
			fi
		fi
	done
}

checkBinary ()
{
	local binary listOfBinaries="$@" pattern rc=$EX_OK

	for binary in $listOfBinaries; do
		pattern="x${binary}Y"
		if [ "$searchedBinaries" = "${searchedBinaries//$pattern/@}" ]; then # search for binary hasn't been done before
			searchedBinaries="${searchedBinaries}${pattern}" # make sure we don't check twice for nothing
			if which "$binary" >/dev/null 2>&1 ; then
				foundBinaries="${foundBinaries}${pattern}"
				continue
			else
				rc=$EX_KO binaryMissing=true
				if [ "$binary" = "opusgain" ]; then
					printMessage 'warning' 'initialization' 'filesystem' \
	"Binary \"${binary}\" not found. Make sure it is in your \$PATH, and that you've upgraded it to the latest available version. \
You may find it at https://github.com/FrancisRussell/zoog"
				else
					printMessage 'warning' 'initialization' 'filesystem' \
	"Binary \"${binary}\" not found. Make sure it is in your \$PATH, and that you've upgraded it to the latest available version."
				fi
			fi
		elif [ -z "$foundBinaries" -o "$foundBinaries" = "${foundBinaries//$pattern/@}" ]; then
			# binary was previously searched, but not found
			rc=$EX_KO
		fi
	done

	return $rc
}

checkBinaries ()
{
	local sourceFile searchedBinaries='' binaryMissing=false hash outputCodec

	if ! which 'which' >/dev/null 2>&1 ; then
		printMessage 'warning' 'initialization' 'filesystem' "Binary \"which\" not found. Make sure it is in your \$PATH."
		printMessage 'abort'
		cleanExit $EX_OSFILE
	fi

	if [ -z "$nTracks" ]; then
		checkBinary 'uname' 'bc' 'grep' "$sedcmd" 'tr' 'cut' 'wc' 'df' 'stat' 'mktemp' 'xargs' 'soxi' 'head' 'tail' 'sort' 'ps' 'find'
	else
		for sourceFile in "${sourceFiles[@]}" ; do
			case "$sourceFile" in
				*.ape) checkBinary 'ffprobe' ; break ;;
			esac
		done

		if [ $computeReplaygain = true ]; then
			for sourceFile in "${sourceFiles[@]}" ; do
				case "$sourceFile" in
					*.flac) checkBinary 'metaflac' ;;
					*.ogg) checkBinary 'ogginfo' 'vorbisgain' 'vorbiscomment' ;;
					*.opus) checkBinary 'opusinfo' 'opusgain' ;; # https://github.com/FrancisRussell/zoog
					*.wv) checkBinary 'APEv2' 'wvunpack' 'wvgain' ;;
					*.mp3) checkBinary 'lame' 'mp3gain' ; if [ $applyGain = false ]; then checkBinary 'eyeD3'; fi ;;
				esac
			done
		elif [ $checkFiles = true ]; then
			checkBinary 'sox'
			for sourceFile in "${sourceFiles[@]}" ; do
				case "$sourceFile" in
					*.flac) checkBinary 'flac' 'metaflac' ;;
					*.wv) checkBinary 'wvunpack' 'APEv2' ;;
					*.ape) checkBinary 'mac' 'APEv2' ;;
				esac
			done
		elif [ $touchFiles = true ]; then
			for sourceFile in "${sourceFiles[@]}" ; do
				case "$sourceFile" in
					*.flac) checkBinary 'metaflac' ;;
					*.ogg) checkBinary 'ogginfo' 'vorbiscomment' ;;
					*.m4a) checkBinary 'ffmpeg' 'ffprobe' ;;
					*.opus) checkBinary 'opusinfo' ;;
					*.wv) checkBinary 'wvtag' 'wvunpack' ;;
					*.ape) checkBinary 'mac' 'APEv2' 'ffprobe' ;;
				esac
			done
		else # transcode
			for sourceFile in "${sourceFiles[@]}" ; do
				case "$sourceFile" in
					*.aiff|*.caf) checkBinary 'sox' ;;
					*.flac) checkBinary 'flac' 'metaflac' ;;
					*.wv) checkBinary 'wvunpack' 'APEv2' ;;
					*.ape) checkBinary 'mac' 'APEv2' ;;
				esac
			done

			if [ $applyGain = true ]; then
				checkBinary 'sox'
			fi
		fi

		for outputCodec in $outputCodecs; do
			case "$outputCodec" in
				AIFF|CAF) checkBinary 'sox' ;;
				FLAC) checkBinary 'flac' ;;
				WavPack|WavPackHybrid|WavPackLossy) checkBinary 'wavpack' 'APEv2' ;;
				MonkeysAudio) checkBinary 'mac' 'APEv2' ;;
				lossyWAV) checkBinary 'lossywav' ;;
				lossyFLAC) checkBinary 'lossywav' 'flac' ;;
				lossyWV) checkBinary 'lossywav' 'wavpack' 'APEv2' ;;
				OggVorbis) checkBinary 'oggenc' ;;
				MP3) checkBinary 'lame' 'eyeD3' ;;
				AAC) checkBinary 'ffmpeg' ;;
				Opus) checkBinary 'opusenc' ;;
			esac
		done

		if [ -n "$hashes" ]; then
			checkBinary 'sox'
			if [ "$OS" = 'Linux' ]; then
				for hash in $hashes; do
					case $hash in
						CRC32) checkBinary 'cksfv' 'mkfifo' ;;
						MD5) checkBinary 'md5sum' ;;
						SHA1) checkBinary 'sha1sum' ;;
						SHA256) checkBinary 'sha256sum' ;;
						SHA512) checkBinary 'sha512sum' ;;
					esac
				done
			else
				for hash in $hashes; do
					case $hash in
						CRC32) checkBinary 'cksfv' 'mkfifo' ;;
						MD5) checkBinary 'md5' ;;
						SHA1|SHA256|SHA512) checkBinary 'shasum' ;;
					esac
				done
			fi
		fi

		if [ -n "$bitDepth" -o -n "$samplingRate" -o "$convertToStereo" != 'false' ]; then
			checkBinary 'sox'
		fi
	fi

	if [ $binaryMissing = true ]; then
		printMessage 'abort'
		cleanExit $EX_OSFILE
	else
		return $EX_OK
	fi
}

setNumberOfProcesses ()
{
	local newNumberOfProcesses=$1 processNumber

	for (( processNumber=0 ; processNumber < newNumberOfProcesses; processNumber++ )); do
		touch "${instanceDir}/process.$processNumber" >/dev/null 2>&1
	done

	if [ $newNumberOfProcesses -lt $nProcesses ]; then
		for (( processNumber=newNumberOfProcesses ; processNumber < nProcesses; processNumber++ )); do
			rm -f "${instanceDir}/process.$processNumber"
		done
	elif [ $newNumberOfProcesses -gt $nProcesses ]; then
		for (( processNumber=nProcesses ; processNumber < newNumberOfProcesses; processNumber++ )); do
			touch "${instanceDir}/process.$processNumber" >/dev/null 2>&1
		done
	fi

	nProcesses=$newNumberOfProcesses
}

isProcessRunning ()
{
	if ps "$1" >/dev/null 2>&1 ; then
		return $EX_OK
	else
		return $EX_KO
	fi
}

cleanUpInstances ()
{
	local pid tdir

	for d in "${piddir}/instance".???????? ; do
		if [ -d "$d" -a -f "${d}/PID" ]; then
			pid="$( cat "${d}/PID" 2>/dev/null )"
			if ! isProcessRunning $pid ; then
				tdir="$( cat "${d}/tdir" 2>/dev/null )"
				if [ -d "$tdir" ]; then
					rm -rf "$tdir" >/dev/null 2>&1
				fi
				rm -rf "$d" >/dev/null 2>&1
			fi
		fi
	done

	for f in "${iodir}"/*.lock ; do
		if [ -f "$f" ]; then
			cleanUpCopyLockFile "${f%.lock}"
		fi
	done
}

handleInstance ()
{
	local nRunningProcesses=0 nAvailableProcesses=$nProcesses pid

	if [ -e "$piddir" ]; then
		cleanUpInstances
	else
		mkdir -m 0777 -p "$piddir" >/dev/null 2>&1
	fi

	if [ ! -d "$piddir" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${piddir}" "couldn't create directory."
		printMessage 'abort'
		cleanExit $EX_CANTCREAT
	elif [ ! -w "$piddir" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${piddir}" "directory is not writable (permission denied)."
		printMessage 'abort'
		cleanExit $EX_NOPERM
	fi

	if [ ! -d "$iodir" ]; then
		mkdir -m 0777 -p "$iodir" >/dev/null 2>&1
	fi

	instanceDir="$( TMPDIR="$piddir" mktemp -d "${piddir}/instance.XXXXXXXX" 2>/dev/null )"
	if [ -z "$instanceDir" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${piddir}" "mktemp failed to create a directory (do you have write permissions?)."
		printMessage 'abort'
		cleanExit $EX_OSERR
	elif [ ! -w "$instanceDir" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${instanceDir}" "directory is not writable (permission denied)."
		printMessage 'abort'
		cleanExit $EX_NOPERM
	fi
	chmod 0775 "$instanceDir"
	mkdir -m 0775 "${instanceDir}/ioLockFiles"
	errorLogFile="${instanceDir}/errors.log"
	touch "$errorLogFile"
	echo "$$" > "${instanceDir}/PID"

	nInstances=$( find "$piddir" -type d -name 'instance.*' 2>/dev/null | wc -l | tr -cd '0-9' )
	if [ $nInstances -le $maxInstances ]; then
		nRunningProcesses="$( getNumberOfCaudecProcesses )"
		nAvailableProcesses=$(( maxProcesses - nRunningProcesses ))
		if [ $nAvailableProcesses -eq 0 ]; then
			printMessage 'warning' 'usage' 'quota' "There are too many caudec processes already running."
			printMessage 'abort'
			cleanExit $EX_TEMPFAIL
		elif [ $nProcesses -gt $nAvailableProcesses ]; then
			printMessage 'warning' 'usage' 'quota' 'verbose' "Number of processes reduced to $nAvailableProcesses in order to stay within limits."
			setNumberOfProcesses $nAvailableProcesses
		else
			setNumberOfProcesses $nProcesses
		fi
		return 0
	else
		if [ $maxInstances -eq 1 ]; then
			printMessage 'warning' 'usage' 'quota' "Another instance of caudec is already running."
		else
			printMessage 'warning' 'usage' 'quota' "Too many instances of caudec are already running."
		fi
		printMessage 'info' 'stderr' "You might want to increase the 'maxInstances' value in /etc/caudecrc or ~/.caudecrc."
		printMessage 'abort'
		cleanExit $EX_TEMPFAIL
	fi
}

setupSwapdir ()
{
	local sourceFileNumber c mktempFS='other' devshmFS='other' mktempSpace devshmSpace ec=1 copyLockFile fileBytes

	if [ -n "$TMPDIR" ]; then mktempDir="$TMPDIR"; else mktempDir='/tmp'; fi

	if [ -n "$CAUDECDIR" ]; then
		if [ "$CAUDECDIR" != '/' ]; then
			CAUDECDIR="${CAUDECDIR%/}" # remove trailing slash
		fi
		if [ "${CAUDECDIR:0:1}" != '/' ]; then # if not an absolute path, prepend current dir
			CAUDECDIR="${PWD}/${CAUDECDIR}"
		fi

		if [ ! -e "$CAUDECDIR" ]; then
			printMessage 'warning' 'initialization' 'filesystem' "path:${CAUDECDIR}" "CAUDECDIR doesn't exist."
			printMessage 'abort'
			cleanExit $EX_OSFILE
		elif [ ! -d "$CAUDECDIR" ]; then
			printMessage 'warning' 'initialization' 'filesystem' "path:${CAUDECDIR}" "CAUDECDIR is not a directory."
			printMessage 'abort'
			cleanExit $EX_CANTCREAT
		elif [ ! -w "$CAUDECDIR" ]; then
			printMessage 'warning' 'initialization' 'filesystem' "path:${CAUDECDIR}" "CAUDECDIR is not writable (permission denied)."
			printMessage 'abort'
			cleanExit $EX_NOPERM
		fi
		mktempDir="$CAUDECDIR"
	fi

	if [ ! -e "$mktempDir" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${mktempDir}" "directory doesn't exist."
		printMessage 'abort'
		cleanExit $EX_OSFILE
	elif [ ! -d "$mktempDir" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${mktempDir}" "not a directory."
		printMessage 'abort'
		cleanExit $EX_CANTCREAT
	elif [ ! -w "$mktempDir" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${mktempDir}" "directory is not writable (permission denied)."
		printMessage 'abort'
		cleanExit $EX_NOPERM
	fi

	TDIR="$( TMPDIR="$mktempDir" mktemp -d "${mktempDir}/${me}.XXXXXXXX" 2>/dev/null )"

	if [ -z "$TDIR" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${mktempDir}" "mktemp failed to create a directory (do you have write permissions?)."
		printMessage 'abort'
		cleanExit $EX_OSERR
	elif [ ! -w "$TDIR" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${TDIR}" "directory is not writable (permission denied)."
		printMessage 'abort'
		cleanExit $EX_NOPERM
	fi

	chmod 0775 "$TDIR"

	if [ "$OS" = 'Linux' ]; then
		TDEV="$( stat -c '%d' "$TDIR" )"
	else
		TDEV="$( stat -f '%d' "$TDIR" )"
	fi
	echo "$TDEV" > "${instanceDir}/tdev"
	echo "$TDIR" > "${instanceDir}/tdir"

	SWAPDIR="$TDIR"

	for ((sourceFileNumber=0; sourceFileNumber < ${#sourceFiles[@]}; sourceFileNumber++)); do
		if [ "$OS" = 'Linux' ]; then
			copyLockFile="${iodir}/$( stat -c '%d' "${sourceFiles[$sourceFileNumber]}" 2>> "$errorLogFile" )"
		else
			copyLockFile="${iodir}/$( stat -f '%d' "${sourceFiles[$sourceFileNumber]}" 2>> "$errorLogFile" )"
		fi
		if [ ! -e "${copyLockFile}.lock" ]; then
			touch "$copyLockFile"
		fi

		touch "${TDIR}/${sourceFileNumber}"
		if [ "$OS" = 'Linux' ]; then
			fileBytes="$( stat -L --printf "%s" "${sourceFiles[$sourceFileNumber]}" 2>> "$errorLogFile" )"
		else
			fileBytes="$( stat -L -n -f "%z" "${sourceFiles[$sourceFileNumber]}" 2>> "$errorLogFile" )"
		fi
		echo "$fileBytes $sourceFileNumber" > "${TDIR}/inputBytes_${sourceFileNumber}"
		if [ $nLossyWAV -ge 1 ]; then
			touch "${TDIR}/lossyWAV_${sourceFileNumber}"
			touch "${TDIR}/lossyWAV_${sourceFileNumber}_WAV_NEEDED"
		fi
		for outputCodec in $outputCodecs; do
			touch "${TDIR}/${outputCodec}_${sourceFileNumber}"
			if [ "$outputCodec" = 'lossyFLAC' -o "$outputCodec" = 'lossyWV' ]; then
				touch "${TDIR}/${outputCodec}_${sourceFileNumber}_LOSSYWAV_NEEDED"
				touch "${TDIR}/lossyWAV_${sourceFileNumber}_WAV_NEEDED"
			else
				touch "${TDIR}/${outputCodec}_${sourceFileNumber}_WAV_NEEDED"
			fi
		done
	done

	sort -n "${TDIR}/inputBytes_"* > "${TDIR}/bytesAndFileNumbers"

	echo -n "0" > "${TDIR}/durations"
	echo -n "0" > "${TDIR}/readTimes"
	touch "${TDIR}/transcodingErrorFiles"
	ln -s "$SWAPDIR" "$piddir"
}

getNumberOfChannels ()
{
	local f="$1" c=0 bn='' dn=''

	case "$f" in
		*.flac) c="$( metaflac --show-channels "$f" 2>/dev/null )" ;;

		*.wv)
			c="$( wvunpack -f "$f" 2>/dev/null | cut -d ';' -f 4 )"
			;;

		*) c="$( ffprobe -print_format 'default' -show_streams -select_streams 'a:0' "$f" 2>/dev/null | grep -F 'channels=' | tr -cd '0-9' )" ;;
	esac

	if [ -z "$c" ]; then c=0; fi
	echo "$c"
}

getNumberOfCaudecProcesses ()
{
	local n=0

	n=$( find "$piddir" -type f -name 'process.*' 2>/dev/null | wc -l | tr -cd '0-9' )
	case "$n" in
		[0-9]*) echo $n ;;
		*) echo 0 ;;
	esac
}

getNumberOfProcessedFiles ()
{
	stat "${TDIR}/WAS_PROCESSED".* 2>/dev/null | wc -l | tr -cd '[:digit:]'
}

getNumberOfAvailableThreads ()
{
	local n=$1 maxThreads="$2" nProcessedFiles=0 nUnprocessedFiles nBytesLeft=0 nThreads foo

	if [ -z "$maxThreads" ]; then
		maxThreads=999999
	fi

	nProcessedFiles="$( getNumberOfProcessedFiles )"
	nUnprocessedFiles=$(( numberOfInputFiles - nProcessedFiles ))
	if [ $nUnprocessedFiles -ge $maxProcessesSetByUser ]; then
		echo 1
		return
	fi

	while read bytes number; do
		test -e "${TDIR}/WAS_PROCESSED.${number}" &>/dev/null && continue
		nBytesLeft=$(( nBytesLeft + bytes ))
	done < "${TDIR}/bytesAndFileNumbers"

	while read bytes number; do
		test -e "${TDIR}/WAS_PROCESSED.${number}" &>/dev/null && continue
		if [ "$number" = "$i" ]; then
			nThreads="$( printf "%.0f" "$( echo "scale=3; $maxProcessesSetByUser * ($bytes / $nBytesLeft)" | bc )" )"
			break
		fi
	done < "${TDIR}/bytesAndFileNumbers"

	if [ $nThreads -lt 1 ]; then
		nThreads=1
	fi
	if [ $nThreads -gt $maxThreads ]; then
		nThreads=$maxThreads
	fi
	echo $nThreads
}


tagline ()
{
	local IFS=' ' tags switch value pattern nLines ereg
	test -e "$destTagFile" || return

	cp "$destTagFile" "${destTagFile}.${outputCodec}"

	if [ -n "$outputCodecs" ]; then
		pattern="x${outputCodec}Y"
		if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then
			for h in $hashes; do
				case $h in
					CRC32) ereg="${ereg}|CRC32=" ;;
					MD5) ereg="${ereg}|MD5=" ;;
					SHA1) ereg="${ereg}|SHA1=" ;;
					SHA256) ereg="${ereg}|SHA256=" ;;
					SHA512) ereg="${ereg}|SHA512=" ;;
				esac
			done
			if [ -n "$ereg" ]; then
				grep -iE "${ereg:1}" "$destTagFile" > "${destTagFile}.${outputCodec}"
			else
				rm -f "${destTagFile}.${outputCodec}" ; touch "${destTagFile}.${outputCodec}"
			fi
		fi

		case "$outputCodec" in
			WavPackLossy|MP3|AAC|OggVorbis|Opus)
				if [ "$outputCodec" = 'WavPackLossy' ]; then
					grep -viE "MD5=|CRC32=|SHA1=|SHA256=|SHA512=" "${destTagFile}.${outputCodec}" > "${destTagFile}.${outputCodec}.tmp"
				else
					grep -viE "replaygain|MD5=|CRC32=|SHA1=|SHA256=|SHA512=" "${destTagFile}.${outputCodec}" > "${destTagFile}.${outputCodec}.tmp"
				fi
				mv "${destTagFile}.${outputCodec}.tmp" "${destTagFile}.${outputCodec}"
				for h in $hashes; do
					grep -i "SOURCE${h}=" "$destTagFile" >> "${destTagFile}.${outputCodec}"
				done
				;;

			FLAC|WavPack|WavPackHybrid|MonkeysAudio)
				if isWavProcessed ; then # SoX was used on the WAV file for resampling, applying gain, or converting to stereo
					grep -viE "µµµCRC32=|µµµMD5=|µµµSHA1=|µµµSHA256=|µµµSHA512=" "${destTagFile}.${outputCodec}" > "${destTagFile}.${outputCodec}.tmp"
					mv "${destTagFile}.${outputCodec}.tmp" "${destTagFile}.${outputCodec}"
				else # no processing was done to the original WAV file
					for h in $hashes; do
						grep -viE "SOURCE${h}=" "${destTagFile}.${outputCodec}" > "${destTagFile}.${outputCodec}.tmp"
						mv "${destTagFile}.${outputCodec}.tmp" "${destTagFile}.${outputCodec}"
					done
					$sedcmd -i'' -e 's@µµµCRC32=@SOURCECRC32=@i' -e 's@µµµMD5=@SOURCEMD5=@i' -e 's@µµµSHA1=@SOURCESHA1=@i' -e 's@µµµSHA256=@SOURCESHA256=@i' -e 's@µµµSHA512=@SOURCESHA512=@i' "${destTagFile}.${outputCodec}"
				fi
				;;

			lossy*)
				grep -viE "MD5=|CRC32=|SHA1=|SHA256=|SHA512=" "${destTagFile}.${outputCodec}" > "${destTagFile}.${outputCodec}.tmp"
				mv "${destTagFile}.${outputCodec}.tmp" "${destTagFile}.${outputCodec}"
				for h in $hashes; do
					grep -i "SOURCE${h}=" "$destTagFile" >> "${destTagFile}.${outputCodec}"
					case "$h" in
						CRC32) if [ -f "$lossywavCRC32File" ]; then cat "$lossywavCRC32File" >> "${destTagFile}.${outputCodec}" ; fi ;;
						MD5) if [ -f "$lossywavMD5File" ]; then cat "$lossywavMD5File" >> "${destTagFile}.${outputCodec}" ; fi ;;
						SHA1) if [ -f "$lossywavSHA1File" ]; then cat "$lossywavSHA1File" >> "${destTagFile}.${outputCodec}" ; fi ;;
						SHA256) if [ -f "$lossywavSHA256File" ]; then cat "$lossywavSHA256File" >> "${destTagFile}.${outputCodec}" ; fi ;;
						SHA512) if [ -f "$lossywavSHA512File" ]; then cat "$lossywavSHA512File" >> "${destTagFile}.${outputCodec}" ; fi ;;
					esac
				done
				;;
		esac
	fi

	if isWavProcessed ; then # SoX was used on the WAV file for resampling, applying gain, or converting to stereo
		grep -Fvi 'replaygain' "${destTagFile}.${outputCodec}" > "${destTagFile}.${outputCodec}.tmp"
		mv "${destTagFile}.${outputCodec}.tmp" "${destTagFile}.${outputCodec}"
	fi

	if [ -n "$compressionTag" ]; then
		echo "$compressionTag" >> "${destTagFile}.${outputCodec}"
	fi

	nLines="$( cat "${destTagFile}.${outputCodec}" | wc -l | tr -cd '0-9' )"
	if [ $nLines -eq 0 ]; then
		return
	fi

	if [ -n "$1" ]; then
		while read line; do
			tags="${tags}\x00${1}\x00${line}"
		done < "${destTagFile}.${outputCodec}"
	else
		while read switch value; do
			tags="${tags}\x00${switch}\x00${value}"
		done < "${destTagFile}.${outputCodec}"
	fi
	rm -f "${destTagFile}.${outputCodec}"
	printf -- "%s" "${tags//%/%%}" | $sedcmd -e 's#§#\n#g' -e 's@\x02@\\\\x00@g'
}

# http://wiki.xiph.org/Field_names
# http://age.hobba.nl/audio/mirroredpages/ogg-tagging.html
# http://reallylongword.org/vorbiscomment/
# http://wiki.hydrogenaudio.org/index.php?title=APE_key
# http://www.id3.org/id3v2.3.0

# Sanitize track or disc number
getTrackOrDiscNumber ()
{
	local s="$1"

	s="${s%/*}"
	case "$s" in
		[0-9]|[0-9][0-9]|[0-9][0-9][0-9]|[0-9][0-9][0-9][0-9]) echo "$s" ;;
		*) echo '0' ;;
	esac
}

getTotalDiscsAndTracks ()
{
	local field value

	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		case "$field" in
			DISCTOTAL|TOTALDISCS)   totalDiscs="$( getTrackOrDiscNumber "$value" )" ;;
			TRACKTOTAL|TOTALTRACKS) totalTracks="$( getTrackOrDiscNumber "$value" )" ;;

			Media|Disc|DISCNUMBER)
				case "$value" in
					[0-9]*)
						if [ "${value#*/}" != "$value" ]; then
							totalDiscs="$( getTrackOrDiscNumber "${value#*/}" )"
						fi
						;;
				esac
				;;

			Track|TRACKNUMBER)
				if [ "${value#*/}" != "$value" ]; then
					totalTracks="$( getTrackOrDiscNumber "${value#*/}" )"
				fi
				;;
		esac
	done < "$sourceTagFile"
}

vorbisCommentsToAPEv2 ()
{
	local line field value totalDiscs='' totalTracks=''

	getTotalDiscsAndTracks
	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		case "$field" in
			ALBUM)                 echo "Album=$value" ;;
			ALBUMARTIST|"ALBUM ARTIST") echo "Album Artist=$value" ;;
			ARTIST)                echo "Artist=$value" ;;
			COMPOSER)              echo "Composer=$value" ;;
			CONDUCTOR)             echo "Conductor=$value" ;;
			COPYRIGHT)             echo "Copyright=$value" ;;
			CRC32)                 echo "CRC32=$value" ;;
			DATE)                  printf 'Year=%.4s\n' "$value" ;;
			DESCRIPTION)           echo "Comment=$value" ;;
			DISCNUMBER)
				if [ -n "$totalDiscs" ]; then
					printf 'Disc=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalDiscs"
				else
					printf 'Disc=%g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			DISCTOTAL|TOTALDISCS)  continue ;;
			EAN/UPC)               echo "EAN/UPC=$value" ;;
			ENCODER|ENCODING)      continue ;;
			GENRE)                 echo "Genre=$value" ;;
			ISRC)                  echo "ISRC=$value" ;;
			LABELNO)               echo "Catalog=$value" ;;
			LICENSE)               echo "License=$value" ;;
			LOCATION)              echo "Record Location=$value" ;;
			MD5)                   echo "MD5=$value" ;;
			PERFORMER)             echo "Performer=$value" ;;
			PUBLISHER)             echo "Publisher=$value" ;;
			REPLAYGAIN_REFERENCE_LOUDNESS) echo "Replaygain_Reference_Loudness=$value" ;;
			REPLAYGAIN_TRACK_GAIN) echo "Replaygain_Track_Gain=$value" ;;
			REPLAYGAIN_TRACK_PEAK) echo "Replaygain_Track_Peak=$value" ;;
			REPLAYGAIN_ALBUM_GAIN) echo "Replaygain_Album_Gain=$value" ;;
			REPLAYGAIN_ALBUM_PEAK) echo "Replaygain_Album_Peak=$value" ;;
			SHA1)                  echo "SHA1=$value" ;;
			SHA256)                echo "SHA256=$value" ;;
			SHA512)                echo "SHA512=$value" ;;
			SOURCEMEDIA)           echo "Media=$value" ;;
			SUBTITLE)              echo "Subtitle=$value" ;;
			TITLE)                 echo "Title=$value" ;;
			TRACKNUMBER)
				if [ -n "$totalTracks" ]; then
					printf 'Track=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalTracks"
				else
					printf 'Track=%g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			TRACKTOTAL|TOTALTRACKS) continue ;;
			*)                     echo "${field}=${value}" ;;
		esac
	done < "$sourceTagFile"
}

vorbisCommentsToEyeD3 ()
{
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks
	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		case "$field" in
			ALBUM)                 echo "--album $value" ;;
			ALBUMARTIST|"ALBUM ARTIST")
				echo "--album-artist $value"
				if [ "$value" = 'Various Artists' -o $setCompilationFlagWithAlbumArtist = true ]; then
					echo "--text-frame TCMP:1" # iTunes 'compilation' frame
				fi
				;;
			ARTIST)                echo "--artist $value" ;;
			COMPOSER)              echo "--composer $value" ;;
			CONDUCTOR)             echo "--text-frame TPE3=$value" ;;
			DATE)                  printf -- '--release-year %.4s\n' "$value" ; printf -- '--release-date %.4s\n' "$value" ;;
			# DESCRIPTION)           echo "--tc $value" ;;
			DISCNUMBER)            printf -- '--disc-num %g\n' "$( getTrackOrDiscNumber "$value" )" ;;
			DISCTOTAL|TOTALDISCS)  printf -- '--disc-total %g\n' "$( getTrackOrDiscNumber "$value" )" "$totalDiscs" ;;
			ENCODER|ENCODING)      continue ;;
			GENRE)                 echo "--genre $value" ;;
			ISRC)                  echo "--text-frame TSRC=$value" ;;
			LICENSE) if [ "${value:0:7}" = 'http://' ]; then echo "--text-frame WCOP=$value" ; fi ;;
			LYRICIST)              echo "--text-frame TEXT=$value" ;;
			PERFORMER)             echo "--text-frame TPE3=$value" ;;
			PUBLISHER)             echo "--publisher $value" ;;
			SUBTITLE)              echo "--text-frame TIT3=$value" ;;
			TITLE)                 echo "--title $value" ;;
			TRACKNUMBER)           printf -- '--track %g\n' "$( getTrackOrDiscNumber "$value" )" ;;
			TRACKTOTAL|TOTALTRACKS) printf -- '--track-total %g\n' "$totalTracks" ;;
			*)                     echo "--user-text-frame ${field}:${value}" ;;
		esac
	done < "$sourceTagFile"
}

vorbisCommentsToM4A ()
{
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks

	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		case "$field" in
			ALBUM)                 echo "-metadata album=$value" ;;
			ALBUMARTIST|"ALBUM ARTIST")
				echo "-metadata album_artist=$value"
				if [ "$value" = 'Various Artists' -o $setCompilationFlagWithAlbumArtist = true ]; then
					echo "-metadata compilation=1" # iTunes 'compilation' frame
				fi
				;;
			ARTIST)                echo "-metadata artist=$value" ;;
			COMPOSER)              echo "-metadata composer=$value" ;;
			COPYRIGHT)             echo "-metadata copyright=$value" ;;
			DATE)                  printf -- '-metadata date=%.4s\n' "$value" ;;
			DESCRIPTION)           echo "-metadata comment=$value" ;;
			DISCNUMBER)
				if [ -n "$totalDiscs" ]; then
					printf -- '-metatadata disc=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalDiscs"
				else
					printf -- '-metatadata disc=%g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			DISCTOTAL|TOTALDISCS)  continue ;;
			ENCODER|ENCODING)      continue ;;
			GENRE)                 echo "-metadata genre=$value" ;;
			ISRC)                  echo "-metadata isrc=$value" ;;
			ORGANIZATION)          echo "-metadata label=$value" ;;
			TITLE)                 echo "-metadata title=$value" ;;
			TRACKNUMBER)
				if [ -n "$totalTracks" ]; then
					printf -- '-metadata track=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalTracks"
				else
					printf -- '-metadata track=%g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			TRACKTOTAL|TOTALTRACKS) continue ;;
			cdec|encoding*|itunnorm|itunsmpb|tool) continue ;;
			# *)                     echo "-meta-user:${field}=${value}" ;;
		esac
	done < "$sourceTagFile"
}

APEv2ToVorbisComments ()
{
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks
	if [ -n "$totalDiscs" ]; then
		printf 'DISCTOTAL=%g\n' "$totalDiscs"
	fi
	if [ -n "$totalTracks" ]; then
		printf 'TRACKTOTAL=%g\n' "$totalTracks"
	fi

	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		case "$field" in
			Album)                 echo "ALBUM=$value" ;;
			Albumartist|"Album Artist") echo "ALBUMARTIST=$value" ;;
			Artist)                echo "ARTIST=$value" ;;
			Catalog)               echo "LABELNO=$value" ;;
			Comment)               echo "DESCRIPTION=$value" ;;
			Composer)              echo "COMPOSER=$value" ;;
			Conductor)             echo "CONDUCTOR=$value" ;;
			Copyright)             echo "COPYRIGHT=$value" ;;
			CRC32)                 echo "CRC32=$value" ;;
			EAN/UPC)               echo "EAN/UPC=$value" ;;
			Encoder|Encoding)      continue ;;
			Genre)                 echo "GENRE=$value" ;;
			ISRC)                  echo "ISRC=$value" ;;
			License)               echo "LICENSE=$value" ;;
			MD5)                   echo "MD5=$value" ;;
			Media|Disc)
				case "$value" in
					[0-9]*) printf 'DISCNUMBER=%g\n' "$( getTrackOrDiscNumber "$value" )" ;;
					*) echo "SOURCEMEDIA=$value" ;;
				esac ;;
			Performer)             echo "PERFORMER=$value" ;;
			Publisher)             echo "PUBLISHER=$value" ;;
			'Record Location')     echo "LOCATION=$value" ;;
			Replaygain_Reference_Loudness) echo "REPLAYGAIN_REFERENCE_LOUDNESS=$value" ;;
			Replaygain_Track_Gain) echo "REPLAYGAIN_TRACK_GAIN=$value" ;;
			Replaygain_Track_Peak) echo "REPLAYGAIN_TRACK_PEAK=$value" ;;
			Replaygain_Album_Gain) echo "REPLAYGAIN_ALBUM_GAIN=$value" ;;
			Replaygain_Album_Peak) echo "REPLAYGAIN_ALBUM_PEAK=$value" ;;
			SHA1)                  echo "SHA1=$value" ;;
			SHA256)                echo "SHA256=$value" ;;
			SHA512)                echo "SHA512=$value" ;;
			Subtitle)              echo "SUBTITLE=$value" ;;
			Title)                 echo "TITLE=$value" ;;
			Track)                 printf 'TRACKNUMBER=%g\n' "$( getTrackOrDiscNumber "$value" )" ;;
			Year)                  printf 'DATE=%.4s\n' "$value" ;;
			*)                     echo "${field}=${value}" ;;
		esac
	done < "$sourceTagFile"
}

APEv2ToEyeD3 ()
{
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks
	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		case "$field" in
			Album)                 echo "--album $value" ;;
			Albumartist|"Album Artist")
				echo "--album artist $value"
				if [ "$value" = 'Various Artists' -o $setCompilationFlagWithAlbumArtist = true ]; then
					echo "--text-frame TCMP:1" # iTunes 'compilation' frame
				fi
				;;
			Artist)                echo "--artist $value" ;;
			Composer)              echo "--composer $value" ;;
			Conductor)             echo "--text-frame TPE3=$value" ;;
			Encoder|Encoding)      continue ;;
			Genre)                 echo "--genre $value" ;;
			ISRC)                  echo "--text-frame TSRC=$value" ;;
			License) if [ "${value:0:7}" = 'http://' ]; then echo "--text-frame WCOP=$value" ; fi ;;
			Media|Disc)
				case "$value" in
					[0-9]*)
						printf -- '--disc-num %g\n' "$( getTrackOrDiscNumber "$value" )"
						if [ -n "$totalDiscs" ]; then
							printf -- '--disc-total %g\n' "$( getTrackOrDiscNumber "$value" )" "$totalDiscs"
						fi
						;;
				esac
				;;
			Performer)             echo "--text-frame TPE3=$value" ;;
			Publisher)             echo "--publisher $value" ;;
			Subtitle)              echo "--text-frame TIT3=$value" ;;
			Title)                 echo "--title $value" ;;
			Track)
				if [ -n "$totalTracks" ]; then
					printf -- '--track %g\n' "$( getTrackOrDiscNumber "$value" )"
					printf -- '--track-total %g\n' "$totalTracks"
				else
					printf -- '--track %g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			Year)                  printf -- '--release-year %.4s\n' "$value" ; printf -- '--release-date %.4s\n' "$value" ;;
			*)                     echo "--user-text-frame ${field}:${value}" ;;
		esac
	done < "$sourceTagFile"
}

APEv2ToM4A ()
{
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks

	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		case "$field" in
			Album)                 echo "-metadata album=$value" ;;
			Albumartist|"Album Artist")
				echo "-metadata album_artist=$value"
				if [ "$value" = 'Various Artists' -o $setCompilationFlagWithAlbumArtist = true ]; then
					echo "-metadata compilation=1" # iTunes 'compilation' frame
				fi
				;;
			Artist)                echo "-metadata artist=$value" ;;
			Comment)               echo "-metadata comment=$value" ;;
			Composer)              echo "-metadata composer=$value" ;;
			Copyright)             echo "-metadata copyright=$value" ;;
			Encoder|Encoding)      continue ;;
			Genre)                 echo "-metadata genre=$value" ;;
			ISRC)                  echo "-metadata isrc=$value" ;;
			Media|Disc)
				case "$value" in
					[0-9]*)
						if [ -n "$totalDiscs" ]; then
							printf -- '-metadata disc=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalDiscs"
						else
							printf -- '-metadata disc=%g\n' "$( getTrackOrDiscNumber "$value" )"
						fi
						;;
				esac
				;;
			Title)                 echo "-metadata title=$value" ;;
			Track)
				if [ -n "$totalTracks" ]; then
					printf -- '-metadata track=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalTracks"
				else
					printf '-metadata track=%g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			Year)                  printf -- '-metadata date=%.4s\n' "$value" ;;
			cdec|encoding*|itunnorm|itunsmpb|tool) continue ;;
			# *)                     echo "-meta-user:${field}=${value}" ;;
		esac
	done < "$sourceTagFile"
}

genTagFilter ()
{
	local taglist="$1" translations search match

	translations="@albumartist@,@album artist@
@date@,@year@
@description@,@comment@
@discnumber@,@disc@
@disctotal@,@totaldiscs@
@labelno@,@catalog@
@location@,@record location@
@organization@,@label@
@sourcemedia@,@media@
@tracknumber@,@track@
@tracktotal@,@totaltracks@"

	ereg="^${taglist//,/=|^}="
	search="@${taglist//,/@,@}@"
	OIFS="$IFS"; IFS=','
	for w in $search; do
		match="$( echo "$translations" | grep -Fi "$w" 2>/dev/null )"
		if [ -n "$match" ]; then
			match="${match//@/}"; match="${match//,/=|^}"
			ereg="${ereg}|^${match}="
		fi
	done
	IFS="$OIFS"
}

processSourceTagFile ()
{
	local firstLine=true nChars=0

	test -e "$sourceTagFile" || return

	# process multi-line tags
	while read line; do
		if [ "$line" != "${line%%=*}" ]; then # new field
			if [ $firstLine = true ]; then
				firstLine=false
				echo -n "$line"
			else
				echo -en "\n${line}"
			fi
		else # multi-line tag
			echo -n "§${line}"
		fi
	done < "$sourceTagFile" > "${sourceTagFile}.tmp"
	mv "${sourceTagFile}.tmp" "$sourceTagFile"
	nChars="$( cat "$sourceTagFile" | wc -m | tr -d ' ' )"
	if [ $nChars -gt 0 ]; then
		$sedcmd -i'' -e 's@crc=@CRC32=@i' "$sourceTagFile" >/dev/null 2>&1
		echo >> "$sourceTagFile"
	fi

	if [ -n "$outputCodecs" ]; then
		# white/blacklists
		if [ -n "$tagWhitelist" ]; then
			genTagFilter "$tagWhitelist"
			grep -iE "$ereg" "$sourceTagFile" > "${sourceTagFile}.tmp"
			mv "${sourceTagFile}.tmp" "$sourceTagFile"
		elif [ -n "$tagBlacklist" ]; then
			genTagFilter "$tagBlacklist"
			grep -viE "$ereg" "$sourceTagFile" > "${sourceTagFile}.tmp"
			mv "${sourceTagFile}.tmp" "$sourceTagFile"
		fi

		if isWavProcessed ; then
			ereg='^sourcecrc32=|^sourcemd5=|^sourcesha1=|^crc32=|^md5=|^sha1=|^µµµcrc32=|^µµµmd5=|^µµµsha1='
			grep -viE "$ereg" "$sourceTagFile" > "${sourceTagFile}.tmp" # purge former hash tags
			mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
		fi

		for h in $hashes; do
			case "$h" in
				CRC32)
					if [ -f "$sourceCRC32File" ]; then
						grep -viE "^SOURCECRC32=" "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
						cat "$sourceCRC32File" >> "$sourceTagFile"
					fi
					if [ -f "$losslessCRC32File" ]; then
						grep -viE "^CRC32=" "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
						cat "$losslessCRC32File" >> "$sourceTagFile"
					fi
					;;

				MD5)
					if [ -f "$sourceMD5File" ]; then
						grep -viE "^SOURCEMD5=" "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
						cat "$sourceMD5File" >> "$sourceTagFile"
					fi
					if [ -f "$losslessMD5File" ]; then
						grep -viE "^MD5=" "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
						cat "$losslessMD5File" >> "$sourceTagFile"
					fi
					;;

				SHA1)
					if [ -f "$sourceSHA1File" ]; then
						grep -viE "^SOURCESHA1=" "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
						cat "$sourceSHA1File" >> "$sourceTagFile"
					fi
					if [ -f "$losslessSHA1File" ]; then
						grep -viE "^SHA1=" "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
						cat "$losslessSHA1File" >> "$sourceTagFile"
					fi
					;;

				SHA256)
					if [ -f "$sourceSHA256File" ]; then
						grep -viE "^SOURCESHA256=" "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
						cat "$sourceSHA256File" >> "$sourceTagFile"
					fi
					if [ -f "$losslessSHA256File" ]; then
						grep -viE "^SHA256=" "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
						cat "$losslessSHA256File" >> "$sourceTagFile"
					fi
					;;

				SHA512)
					if [ -f "$sourceSHA512File" ]; then
						grep -viE "^SOURCESHA512=" "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
						cat "$sourceSHA512File" >> "$sourceTagFile"
					fi
					if [ -f "$losslessSHA512File" ]; then
						grep -viE "^SHA512=" "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv -f "${sourceTagFile}.tmp" "$sourceTagFile"
						cat "$losslessSHA512File" >> "$sourceTagFile"
					fi
					;;
			esac
		done
	fi
}

sanitizeApeTags ()
{
	local field lastField value lastValue first=true

	# transform duplicate fields into unique multi-value fields
	while read line; do
		lastField="$field" lastValue="$value"
		field="$( echo "${line%%=*}" | tr '[:upper:]' '[:lower:]' 2>/dev/null )"
		value="${line#*=}"
		if [ "$field" != "$lastField" ]; then
			if [ "$first" = "true" ]; then
				echo -en "${line}"
				first=false
			else
				echo -en "\n${line}"
			fi
		elif [ "$value" != "$lastValue" ]; then
			echo -n '\\x01'
			echo -n "$value"
		fi
	done < <( sort -u "$destTagFile" 2>/dev/null ) > "${destTagFile}.tmp"
	if [ -f "${destTagFile}.tmp" ]; then
		if [ "$OS" = 'Linux' ]; then
			destTagFileSize=$(stat -f %s "${destTagFile}.tmp")
		else
			destTagFileSize=$(stat -f %z "${destTagFile}.tmp")
		fi
		if [ $destTagFileSize -gt 0 ]; then
			echo -en "\n" >> "${destTagFile}.tmp"
		fi
		rm -f "$destTagFile" >/dev/null 2>&1
		mv "${destTagFile}.tmp" "$destTagFile" >/dev/null 2>&1
	fi
}

convertTags ()
{
	destTagFile="${TDIR}/${i}.${2}.txt"
	test -e "$sourceTagFile" || return
	test -e "$destTagFile" && return
	shopt -qs nocasematch
	case $1 in
		vc)
			case $2 in
				vc)
					if [ -n "$outputCodecs" ]; then
						grep -viE '^encoder=|^encoding=' "$sourceTagFile" > "$destTagFile"
					else
						cp "$sourceTagFile" "$destTagFile" >/dev/null 2>&1
					fi
					;;

				ape)  vorbisCommentsToAPEv2 > "$destTagFile" ;;
				mp3) vorbisCommentsToEyeD3 > "$destTagFile" ;;
				m4a) vorbisCommentsToM4A > "$destTagFile" ;;
			esac ;;

		ape)
			case $2 in
				ape)
					if [ -n "$outputCodecs" ]; then
						grep -viE '^encoder=|^encoding=' "$sourceTagFile" > "$destTagFile"
					else
						cp "$sourceTagFile" "$destTagFile" >/dev/null 2>&1
					fi
					;;

				vc)   APEv2ToVorbisComments > "$destTagFile" ;;
				mp3) APEv2ToEyeD3 > "$destTagFile" ;;
				m4a) APEv2ToM4A > "$destTagFile" ;;

			esac
			case $2 in
				vc|mp3) $sedcmd -i'' -e 's@\x02@ / @g' -e 's@^ro:@@' "$destTagFile" ;;
			esac ;;
	esac

	case "$destTagFile" in
		*.ape.txt) sanitizeApeTags ;;
	esac
	shopt -qu nocasematch
}

extractFlacArtwork ()
{
	local blockNumber withinPictureBlock=false picType picNumber=0 picExt description pattern ec=$EX_OK

	for outputCodec in $outputCodecs; do
		case "$outputCodec" in
			OggVorbis) continue ;; # unsupported formats
		esac
		pattern="x${outputCodec}Y"
		if [ "$preserveMetadata" != "${preserveMetadata//$pattern/@}" ]; then
			metaflac --list "$copyFile" 2>> "$errorLogFile" | grep -vE '[0-9A-F]{8}:' > "${TDIR}/${i}.flist" 2>/dev/null
			$sedcmd -i'' -e 's@METADATA block #@\nMETADATA block #@' "${TDIR}/${i}.flist" # binary data can screw up the 'METADATA block #' line
			while read line; do
				if [ "${line:0:16}" = 'METADATA block #' ]; then
					blockNumber="${line#*#}"
				elif [ "$line" = 'type: 6 (PICTURE)' ]; then
					withinPictureBlock=true
				elif [ "${line:0:5}" = 'type:' -a $withinPictureBlock = true ]; then
					picType="${line#* }" ; picType="${picType%% *}"
				elif [ "${line:0:10}" = 'MIME type:' -a $withinPictureBlock = true ]; then
					case "$line" in
						'MIME type: image/jpeg') picExt='jpg' ;;
						'MIME type: image/png') picExt='png' ;;
						'MIME type: image/gif') picExt='gif' ;;
					esac
				elif [ "${line:0:12}" = 'description:' -a $withinPictureBlock = true ]; then
					description="${line/description: /}"
					if [ "$description" != 'description:' ]; then
						echo "$description" > "${SWAPDIR}/picture-${i}-${picNumber}.txt"
					fi
					metaflac --block-number=$blockNumber --export-picture-to="${SWAPDIR}/picture-${i}-${picNumber}_${picType}.${picExt}" "$copyFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
					if [ $ec -eq $EX_OK ]; then
						((picNumber++))
					else
						rm -rf "${SWAPDIR}/picture-${i}-${picNumber}_${picType}.${picExt}" "${SWAPDIR}/picture-${i}-${picNumber}.txt" >/dev/null 2>> "$errorLogFile"
					fi
					withinPictureBlock=false
				fi
			done < "${TDIR}/${i}.flist"
			rm -f "${TDIR}/${i}.flist" >/dev/null 2>&1
			return $ec
		fi
	done
	return $ec
}

extractAPEv2Artwork ()
{
	local picNumber=0 picExt='' picType=0 picTypeText='' pattern ec=$EX_OK otherType='' argString='' fieldName=''

	for outputCodec in $outputCodecs; do
		case "$outputCodec" in
			OggVorbis) continue ;; # unsupported formats
		esac
		pattern="x${outputCodec}Y"
		if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then continue; fi

		for fieldName in 'other' 'icon' 'other icon' 'front' 'back' 'leaflet' 'media' 'lead artist' 'artist' 'conductor' 'band' 'composer' 'lyricist' 'recording location' 'during recording' 'during performance' 'video' 'a bright colored fish' 'illustration' 'band logo' 'publisher logo'; do
			argString="${argString}\\x00-d\\x00cover art (${fieldName})=${SWAPDIR}/picture-${i}-${picNumber}_${picType}."
			((picType++))
			((picNumber++))
		done
		echo -en "-z${argString}\x00${copyFile}" | xargs -0 APEv2 >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
		return $ec
	done
	return $ec
}

extractAPEv2Binaries ()
{
	local pattern ec=$EX_OK argString='' fieldName='' b=0

	for outputCodec in $outputCodecs; do
		case "$outputCodec" in
			MonkeysAudio|WavPack*|lossyWV)
				pattern="x${outputCodec}Y"
				if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then continue; fi

				if [ ! -d "$apeBinariesDir" ]; then mkdir -p "$apeBinariesDir" >/dev/null 2>&1 ; fi
				while read fieldName; do
					echo "$fieldName" > "${apeBinariesDir}/${b}.txt" 2>/dev/null
					argString="${argString}\\x00-d\\x00${fieldName}=${apeBinariesDir}/${b}.bin"
					((b++))
				done < <( APEv2 -z "$copyFile" 2>/dev/null | grep -F '=data:' 2>/dev/null | cut -d '=' -f 1 2>/dev/null )

				if [ -n "$argString" ]; then
					echo -en "-z${argString}\x00${copyFile}" | xargs -0 APEv2 >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				fi
				return $ec
				;;

			*) continue ;;
		esac
	done
	return $ec
}

importCoverArt ()
{
	local ec=$EX_OK userSpecifiedArtwork

	for f in "${SWAPDIR}/picture-3-"*_*; do
		userSpecifiedArtwork="$( getCodecCoverArtFile "$outputCodec" )"
		if [ -n $userSpecifiedArtwork ]; then
			userSpecifiedArtwork="${sourceDirname}/${userSpecifiedArtwork}"
			if [ -f "$userSpecifiedArtwork" -a -r "$userSpecifiedArtwork" ]; then
				echo "" > "${SWAPDIR}/picture-${i}-3.txt"
				picExt="${userSpecifiedArtwork##*.}"
				picType=3
				swapFilePath="${SWAPDIR}/picture-${i}-0_${picType}.${picExt}"
				rm -f "$swapFilePath" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				if [ $ec -eq $EX_OK ]; then
					cp -f "$userSpecifiedArtwork" "$swapFilePath" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				fi
			fi
		fi
	done

	return $ec
}

importArtworkIntoFLAC ()
{
	local ec=$EX_OK picBasename="" picType picExt description='' descFile='' swapFilePath pattern

	pattern="x${outputCodec}Y"
	if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then
		return $EX_OK
	fi

	importCoverArt || ec=$EX_KO

	for f in "${SWAPDIR}/picture-${i}-"*_*; do
		if [ ! -e "$f" ]; then
			continue
		fi
		picBasename="$( basename "$f" )"
		picType="${picBasename#*_}"; picType="${picType%.*}"; descFile="${f%_*}.txt"
		description=''
		if [ -f "$descFile" ]; then
			description="$( cat "$descFile" 2>> "$errorLogFile" )"; description="${description//|//}" # replace | with /
		fi
		metaflac --import-picture-from="${picType}||${description}||${f}" "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
	done
	return $ec
}

genOpusArtworkCommandLine ()
{
	local ec=$EX_OK picBasename="" picType description='' descFile='' pattern cmdline=''

	pattern="x${outputCodec}Y"
	if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then
		echo "$cmdline"
		return 0
	fi

	importCoverArt || ec=$EX_KO

	for f in "${SWAPDIR}/picture-${i}-"*_*; do
		if [ ! -e "$f" ]; then continue; fi
		picBasename="$( basename "$f" )"
		picType="${picBasename#*_}"; picType="${picType%.*}"; descFile="${f%_*}.txt"
		description=''
		if [ -f "$descFile" ]; then
			description="$( cat "$descFile" 2>> "$errorLogFile" )"; description="${description//|//}" # replace | with /
		fi
		cmdline="${cmdline}\x00--picture=${picType}||${description}||${f}"
	done
	echo "$cmdline"
	return 0
}

importArtworkIntoAPEv2 ()
{
	local ec=$EX_OK picBasename="" picType picTypeText pattern af='' argString='' lastPicType=''

	pattern="x${outputCodec}Y"
	if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then
		return $EX_OK
	fi

	importCoverArt || ec=$EX_KO

	for f in "${SWAPDIR}/picture-${i}-"*_*; do
		if [ ! -e "$f" ]; then continue; fi
		picBasename="$( basename "$f" )"
		picType="${picBasename#*_}"; picType="${picType%.*}"
		if [ "$lastPicType" = "$picType" ]; then
			continue
		fi
		lastPicType="$picType"
		case "$picType" in
			0) picTypeText='other' ;;
			1) picTypeText='icon' ;;
			2) picTypeText='other icon' ;;
			3) picTypeText='front' ;;
			4) picTypeText='back' ;;
			5) picTypeText='leaflet' ;;
			6) picTypeText='media' ;;
			7) picTypeText='lead artist' ;;
			8) picTypeText='artist' ;;
			9) picTypeText='conductor' ;;
			10) picTypeText='band' ;;
			11) picTypeText='composer' ;;
			12) picTypeText='lyricist' ;;
			13) picTypeText='recording location' ;;
			14) picTypeText='during recording' ;;
			15) picTypeText='during performance' ;;
			16) picTypeText='video' ;;
			17) picTypeText='a bright colored fish' ;;
			18) picTypeText='illustration' ;;
			19) picTypeText='band logo' ;;
			20) picTypeText='publisher logo' ;;
		esac
		argString="${argString}\\x00-a\\x00Cover Art (${picTypeText})=${f}"
	done

	if [ -n "$argString" ]; then
		echo -en "-z${argString}\x00${encodedFile}" | xargs -0 APEv2 >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
	fi

	return $ec
}

importBinariesIntoAPEv2 ()
{
	local ec=$EX_OK pattern argString='' fieldName='' bf=''

	if [ ! -d "$apeBinariesDir" ]; then return $EX_OK; fi

	pattern="x${outputCodec}Y"
	if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then
		return $EX_OK
	fi

	for bf in "${apeBinariesDir}"/*.txt; do
		if [ ! -e "$bf" ]; then continue; fi
		fieldName="$( cat "$bf" )"
		argString="${argString}\\x00-b\\x00${fieldName}=${bf/.txt/.bin}"
	done

	if [ -n "$argString" ]; then
		echo -en "-z${argString}\x00${encodedFile}" | xargs -0 APEv2 >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
	fi

	return $ec
}

importArtworkIntoMP3 ()
{
	local ec=$EX_OK picBasename="" picType picTypeText pattern descFile description='' n=0

	pattern="x${outputCodec}Y"
	if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then
		return $EX_OK
	fi

	importCoverArt || ec=$EX_KO

	which 'eyeD3' >/dev/null 2>&1 || return $EX_OK
	for f in "${SWAPDIR}/picture-${i}-"*_*; do
		if [ ! -e "$f" ]; then continue; fi
		((n++))
		picBasename="$( basename "$f" )"
		picType="${picBasename#*_}"; picType="${picType%.*}"; descFile="${f%_*}.txt"
		case $picType in
			0) picTypeText='OTHER' ;;
			1) picTypeText='ICON' ;;
			2) picTypeText='OTHER_ICON' ;;
			3) picTypeText='FRONT_COVER' ;;
			4) picTypeText='BACK_COVER' ;;
			5) picTypeText='LEAFLET' ;;
			6) picTypeText='MEDIA' ;;
			7) picTypeText='LEAD_ARTIST' ;;
			8) picTypeText='ARTIST' ;;
			9) picTypeText='CONDUCTOR' ;;
			10) picTypeText='BAND' ;;
			11) picTypeText='COMPOSER' ;;
			12) picTypeText='LYRICIST' ;;
			13) picTypeText='RECORDING_LOCATION' ;;
			14) picTypeText='DURING_RECORDING' ;;
			15) picTypeText='DURING_PERFORMANCE' ;;
			16) picTypeText='VIDEO' ;;
			17) picTypeText='BRIGHT_COLORED_FISH' ;;
			18) picTypeText='ILLUSTRATION' ;;
			19) picTypeText='BAND_LOGO' ;;
			20) picTypeText='PUBLISHER_LOGO' ;;
			*) continue ;;
		esac
		description=''
		if [ -f "$descFile" ]; then
			description="$( cat "$descFile" 2>> "$errorLogFile" )"; description="${description//|//}" # replace | with /
		fi
		if [ -z "$description" ]; then
			description="${picTypeText}_${n}" # add a number to make it unique
		fi
		eyeD3 --add-image="${f}:${picTypeText}:${description}" "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
	done
	return $ec
}

computeCRC32 ()
{
	local hfile="$1" fifo dgst wtype='' earg=''

	wtype="$( soxi -e "$wavFile" 2>/dev/null )"
	if [ "$wtype" = 'Floating Point PCM' ]; then
		earg='-e unsigned-integer -b 16'
	fi

	fifo="${TDIR}/${i}.fifo"
	if [ ! -e "$fifo" ]; then mkfifo "$fifo" >/dev/null 2>> "$errorLogFile" ; fi
	sox $earg "$hfile" -t raw "$fifo" 2>> "$errorLogFile" &
	dgst="$( cksfv -b "$fifo" 2>> "$errorLogFile" | grep -Fv ';' )"
	dgst="${dgst##* }"
	if [ -n "$dgst" ]; then
		echo -n "${dgst##* }"
	fi
}

computeMD5 ()
{
	local wavFile="$1" dgst wtype='' earg=''

	wtype="$( soxi -e "$wavFile" 2>/dev/null )"
	if [ "$wtype" = 'Floating Point PCM' ]; then
		earg='-e unsigned-integer -b 16' # courtesy of David Bryant, author of WavPack
	fi

	if [ "$OS" = 'Linux' ]; then
		dgst="$( sox $earg "$wavFile" -t raw - 2>> "$errorLogFile" | md5sum - 2>> "$errorLogFile" )"
	else
		dgst="$( sox $earg "$wavFile" -t raw - 2>> "$errorLogFile" | md5 -q - 2>> "$errorLogFile" )"
	fi
	dgst="${dgst%% *}"
	if [ -n "$dgst" ]; then
		echo -n "$dgst"
	fi
}

computeSHA ()
{
	local wavFile="$1" hashtype="$2" hashvar='' dgst wtype='' earg=''

	wtype="$( soxi -e "$wavFile" 2>/dev/null )"
	if [ "$wtype" = 'Floating Point PCM' ]; then
		earg='-e unsigned-integer -b 16'
	fi

	if [ "$OS" = 'Linux' ]; then
		case "$hashtype" in
			SHA1) hashvar='sha1sum' ;;
			SHA256) hashvar='sha256sum' ;;
			SHA512) hashvar='sha512sum' ;;
		esac
	else
		case "$hashtype" in
			SHA1) hashvar='1' ;;
			SHA256) hashvar='256' ;;
			SHA512) hashvar='512' ;;
		esac
	fi

	if [ "$OS" = 'Linux' ]; then
		dgst="$( sox $earg "$wavFile" -t raw - 2>> "$errorLogFile" | $hashvar - 2>> "$errorLogFile" )"
	else
		dgst="$( sox $earg "$wavFile" -t raw - 2>> "$errorLogFile" | shasum -a $hashvar - 2>> "$errorLogFile" )"
	fi
	dgst="${dgst%% *}"
	if [ -n "$dgst" ]; then
		echo -n "$dgst"
	fi
}

getSoxDuration ()
{
	local f="$1" hours minutes seconds milliseconds

	duration="$( soxi -D "$f" 2>/dev/null )"
	if [ -z "$duration" -o -z "${duration//0/}" -o "${duration//0/}" = '.' ]; then
		duration='1.0'
	fi
}

getSoxSeconds ()
{
	local msec
	getSoxDuration "$1"
	seconds="${duration%.*}"
	msec="${duration#*.}"
	if [ -z "$msec" ]; then
		msec=0
	fi
	milliseconds="$( echo "scale=3; $seconds + 0.$msec" | bc )"
	if [ $msec -ge 500 ]; then
		((seconds++))
	fi
}

saveDurations ()
{
	local samples sampleRate duration hours minutes seconds centiseconds f data

	case "$copyFile" in
		*.flac)
			data="$( metaflac --show-total-samples --show-sample-rate "$copyFile" 2>/dev/null )"
			if [ -n "$data" ]; then
				for v in $data; do
					if [ -z "$samples" ]; then
						samples="$v"
					else
						sampleRate="$v"
					fi
				done
				if [ -n "$samples" -a -n "$sampleRate" ]; then
					duration="$( echo "scale=3; $samples / $sampleRate" | bc )"
					echo -n " + $duration" >> "${TDIR}/durations"
				fi
			fi
			;;

		*.wv)
			# New WavPack data format (-f):
			# 1. sampling rate
			# 2. bit-depth (1-32)
			# 3. format ("int" or "float")
			# 4. number of channels
			# 5. channel mask (in hex because it's a mask, always prefixed with "0x")
			# 6. number of samples (missing if unknown)
			# 7. md5sum (technically is hex, but not prefixed with "0x", might be missing)
			# 8. encoder version (basically this will always be 4, but there are some old files out there, could be 5 one day)
			# 9. encoding mode (in hex because it's a bitfield, always prefixed with "0x")
			# 10. filename
			data="$( wvunpack -f "$copyFile" 2>/dev/null )"
			if [ -n "$data" ]; then
				samples="$( echo "$data" | cut -d ';' -f 6 )"
				sampleRate="$( echo "$data" | cut -d ';' -f 1 )"
				if [ -n "$samples" -a -n "$sampleRate" ]; then
					seconds="$( echo "scale=3; $samples / $sampleRate" | bc )"
					echo -n " + ${seconds}" >> "${TDIR}/durations"
				fi
			fi
			;;

		*.ape|*.m4a)
			duration="$( ffprobe -print_format 'default' -show_streams -select_streams 'a:0' "$copyFile" 2>/dev/null | grep -F 'duration=' 2>/dev/null | cut -d '=' -f 2 | tr -cd '0-9.' )"
			if [ -n "$duration" ]; then
				echo -n " + $duration" >> "${TDIR}/durations"
			fi
			;;

		*)
			getSoxDuration "$wavFile"
			echo -n " + $duration" >> "${TDIR}/durations"
			;;
	esac
}

getDownmixFactors ()
{
	local divider="$1"

	fv="$( echo "scale=5; 1 / $divider" | bc )"
	fv="$( printf "%.4f" "$fv" )"

	pv="$( echo "scale=5; (1 / sqrt(2)) / $divider" | bc )"
	pv="$( printf "%.4f" "$pv" )"

	hv="$( echo "scale=5; 0.5 / $divider" | bc )"
	hv="$( printf "%.4f" "$hv" )"
}

upmixToStereo ()
{
	local ec=$EX_OK

	sox $soxGuard -M "$wavFile" "$wavFile" $bitdepthcmd -c 2 "$resampledWavFile" $gaincmd $ratecmd $dithercmd >/dev/null 2>> "$errorLogFile" || ec=$EX_KO

	if [ $ec -eq $EX_OK -a -f "$resampledWavFile" ]; then
		mv -f "$resampledWavFile" "$wavFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
		if [ $ec -eq $EX_OK ]; then
			isWavProcessed 'true'
		fi
	fi
	if [ -e "$resampledWavFile" ]; then rm -f "$resampledWavFile"; fi
	return $ec
}

downmixToStereo ()
{
	local ec=$EX_OK surroundConfig='' fv='' pv='' hv=''

	# The following channel mappings have been thoroughly tested and should never clip, even in worst-case scenarios
	# Front ($fv): factor 1, LFE ($hv): factor 0.5 (1/2), everything else ($pv): factor 0.7071 (1 / sqrt(2))
	# http://www.academia.edu/2397757/A_downmix_approach
	case "$nChannels" in
		3) # FL, FR, LFE
			surroundConfig='2.1'
			getDownmixFactors '1.55'
			sox $soxGuard "$wavFile" $bitdepthcmd "$resampledWavFile" $ratecmd remix -m 1v${fv},3v${hv} 2v${fv},3v${hv} $dithercmd >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
			;;

		4) # FL, FR, SL, SR
			surroundConfig='4.0'
			getDownmixFactors '1.75'
			sox $soxGuard "$wavFile" $bitdepthcmd "$resampledWavFile" $ratecmd remix -m 1v${fv},3v${pv} 2v${fv},4v${pv} $dithercmd >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
			;;

		5) # FL, FR, C, SL, SR
			surroundConfig='5.0'
			getDownmixFactors '2.5'
			sox $soxGuard "$wavFile" $bitdepthcmd "$resampledWavFile" $ratecmd remix -m 1v${fv},3v${pv},4v${pv} 2v${fv},3v${pv},5v${pv} $dithercmd >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
			;;

		6) # FL, FR, C, LFE, SL, SR
			surroundConfig='5.1'
			getDownmixFactors '3'
			sox $soxGuard "$wavFile" $bitdepthcmd "$resampledWavFile" $ratecmd remix -m 1v${fv},3v${pv},4v${hv},5v${pv} 2v${fv},3v${pv},4v${hv},6v${pv} $dithercmd >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
			;;

		8) # FL, FR, C, LFE, SL, SR, BL, BR
			surroundConfig='7.1'
			getDownmixFactors '3.75'
			sox $soxGuard "$wavFile" $bitdepthcmd "$resampledWavFile" $ratecmd remix -m 1v${fv},3v${pv},4v${hv},5v${pv},7v${pv} 2v${fv},3v${pv},4v${hv},6v${pv},8v${pv} $dithercmd >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
			;;

		*) return $EX_OK ;; # nothing to do
	esac

	unset fv pv hv

	if [ $ec -eq $EX_OK -a -f "$resampledWavFile" ]; then
		mv -f "$resampledWavFile" "$wavFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
		if [ $ec -eq $EX_OK ]; then
			isWavProcessed 'true'
		fi
	fi
	if [ -e "$resampledWavFile" ]; then rm -f "$resampledWavFile"; fi
	return $ec
}

isWavProcessed ()
{
	local val="$1"

	if [ -z "$wavProcessedStatusFile" ]; then
		wavProcessed='false'
	else
		if [ "$val" = "true" ]; then
			if [ ! -e "$wavProcessedStatusFile" ]; then
				touch "$wavProcessedStatusFile"
			fi
			wavProcessed='true'
		elif [ "$val" = "false" ]; then
			if [ -e "$wavProcessedStatusFile" ]; then
				rm -f "$wavProcessedStatusFile" >/dev/null 2>&1
			fi
			wavProcessed='false'
		else
			if [ -e "$wavProcessedStatusFile" ]; then
				wavProcessed='true'
			else
				wavProcessed='false'
			fi
		fi
	fi

	if [ "$wavProcessed" = "true" ]; then
		return $EX_OK
	else
		return $EX_KO
	fi
}

decode ()
{
	local ec=$EX_OK sourceTagFormat hline samples sampleRate duration hours minutes seconds centiseconds pattern soxGuard='' sourceMD5='' kfm='' nChannels=2 gaincmd='' ratecmd='' bitdepthcmd='' dithercmd='' gainPeak=''

	isWavProcessed 'false'
	if [ -e "$copyFile" ]; then
		case "$sourceExtension" in
			wav)
				sourceTagFormat='vc'
				mv "$copyFile" "$wavFile" >/dev/null 2>&1 || ec=$EX_KO
				touch "$sourceTagFile"
				;;

			aiff|caf)
				sourceTagFormat='vc'
				sox "$copyFile" -t wav "$wavFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				touch "$sourceTagFile"
				;;

			flac)
				sourceTagFormat='vc'
				getInternalMD5 "$copyFile"
				if [ $keepWavMetadata = true ]; then
					if ! flac -s -d --keep-foreign-metadata -o "$wavFile" "$copyFile" >/dev/null 2>&1; then
						if [ -e "$wavFile" ]; then rm -f "$wavFile"; fi
						flac -s -d -o "$wavFile" "$copyFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
					fi
				else
					flac -s -d -o "$wavFile" "$copyFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				fi
				if [ $ec -eq $EX_OK ]; then
					metaflac --no-utf8-convert --export-tags-to="$sourceTagFile" "$copyFile" >/dev/null 2>> "$errorLogFile" &&
					extractFlacArtwork || ec=$EX_KO
					if [ -e "$sourceTagFile" ]; then
						grep -iv 'WAVEFORMATEXTENSIBLE_CHANNEL_MASK=' "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv "${sourceTagFile}.tmp" "$sourceTagFile"
					fi
				fi
				;;

			wv)
				sourceTagFormat='ape' kfm='-w'
				getInternalMD5 "$copyFile"
				if [ $keepWavMetadata = true ]; then kfm='' ; fi
				nThreads=$( getNumberOfAvailableThreads $i $maxWavPackThreads )
				wvunpack -q $kfm -m --threads=$nThreads -o "$wavFile" "$copyFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				if [ $ec -eq $EX_OK ]; then
					APEv2 -z "$copyFile" 2>> "$errorLogFile" | grep -vE '(=data:)|(=artwork:)' | $sedcmd -e 's@\\n@\n@g' -e 's@\\x00@\x02@g' > "$sourceTagFile" 2>/dev/null
					extractAPEv2Binaries
					extractAPEv2Artwork
				fi
				;;

			ape)
				sourceTagFormat='ape'
				nThreads=$( getNumberOfAvailableThreads $i )
				mac "$copyFile" "$wavFile" -d -threads=$nThreads >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				if [ $ec -eq $EX_OK ]; then
					APEv2 -z "$copyFile" 2>> "$errorLogFile" | grep -vE '(=data:)|(=artwork:)' | $sedcmd -e 's@\\n@\n@g' -e 's@\\x00@\x02@g' > "$sourceTagFile" 2>/dev/null
					extractAPEv2Binaries
					extractAPEv2Artwork
				fi
				;;

			*) ec=$EX_KO ;;
		esac

		if [ $sourceIsLossyWAV = true ]; then
			if [ ! -h "$lossywavFile" ]; then
				ln -s "${i}.wav" "$lossywavFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
			fi
		fi
	else
		ec=$EX_KO
	fi

	if [ $ec -eq $EX_OK ]; then
		saveDurations
		if [ -e "$copyFile" ]; then
			rm -f "$copyFile" "${copyFile}c"
		fi

		if [ -f "$sourceTagFile" ]; then
			$sedcmd -i'' -e 's@SOURCEMD5=@µµµMD5=@i' -e 's@SOURCECRC32=@µµµCRC32=@i' -e 's@SOURCESHA1=@µµµSHA1=@i' -e 's@SOURCESHA256=@µµµSHA256=@i' -e 's@SOURCESHA512=@µµµSHA512=@i' "$sourceTagFile"
		fi

		gainValue='' gaincmd=''
		if [ $applyGain = true ]; then
			if [ "$applyGainType" = 'ALBUM' ]; then
				gainValue="$( grep -Fi 'replaygain_album_gain' "$sourceTagFile" 2>/dev/null | cut -d '=' -f 2 | cut -d ' ' -f 1 )"
				if [ "${preamp:0:1}" = '-' ]; then
					gainValue="$( printf '%.2f' "$( echo "$gainValue - ${preamp:1}" | bc -l 2>/dev/null )" )"
				elif [ "${preamp:0:1}" = '+' ]; then
					gainValue="$( printf '%.2f' "$( echo "$gainValue + ${preamp:1}" | bc -l 2>/dev/null )" )"
				fi
				if [ "${gainValue:0:1}" != '-' -a "${gainValue:0:1}" != '+' ]; then
					gainValue="+${gainValue}"
				fi
			elif [ "$applyGainType" = 'TRACK' ]; then
				gainValue="$( grep -Fi 'replaygain_track_gain' "$sourceTagFile" 2>/dev/null | cut -d '=' -f 2 | cut -d ' ' -f 1 )"
				if [ "${preamp:0:1}" = '-' ]; then
					gainValue="$( printf '%.2f' "$( echo "$gainValue - ${preamp:1}" | bc -l 2>/dev/null )" )"
				elif [ "${preamp:0:1}" = '+' ]; then
					gainValue="$( printf '%.2f' "$( echo "$gainValue + ${preamp:1}" | bc -l 2>/dev/null )" )"
				fi
				if [ "${gainValue:0:1}" != '-' -a "${gainValue:0:1}" != '+' ]; then
					gainValue="+${gainValue}"
				fi
			elif [ "$applyGainType" = 'ALBUM_PEAK' -o "$applyGainType" = 'TRACK_PEAK' ]; then
				if [ "$applyGainType" = 'ALBUM_PEAK' ]; then
					gainPeak="$( grep -Fi 'replaygain_album_peak' "$sourceTagFile" 2>/dev/null | cut -d '=' -f 2 )"
				elif [ "$applyGainType" = 'TRACK_PEAK' ]; then
					gainPeak="$( grep -Fi 'replaygain_track_peak' "$sourceTagFile" 2>/dev/null | cut -d '=' -f 2 )"
				fi
				if [ "${gainPeak:0:1}" = '0' ]; then
					gainValue="$( printf "%.2f" "$( echo  "20 * (l(${gainPeak}) / l(10))" | bc -l )" )"
					if [ "${gainValue:0:1}" != '-' ]; then # gainValue is positive
						if [ "${peakReference:0:1}" = '-' ]; then
							gainValue="${peakReference}"
						else
							gainValue=''
						fi
					else # gainValue is negative
						if [ "${peakReference:0:1}" = '-' ]; then
							gainValue="$( printf "%.2f" "$( echo "${gainValue:1} + (${peakReference})" | bc -l )" )"
							if [ "${gainValue:0:1}" != '-' ]; then
								gainValue="+${gainValue}"
							fi
						else
							gainValue="+${gainValue:1}"
						fi
					fi
				elif [ "${peakReference:0:1}" = '-' ]; then
					gainValue="$peakReference"
				fi
			else
				gainValue="$applyGainType"
			fi

			if [ -n "$gainValue" ]; then
				gaincmd="gain $gainValue"
			fi
		fi

		nChannels="$( soxi -c "$wavFile" 2>> "$errorLogFile" )"
		if [ -z "$nChannels" -o "$nChannels" = '0' ]; then
			nChannels=2
		fi

		hasLossy=false hasLossless=false
		if [ -n "$gainValue" -o -n "$bitDepth" -o -n "$samplingRate" ]; then
			hasLossy=true
		elif [ "$convertToStereo" != 'false' -a $nChannels -ne 2 ]; then
			hasLossy=true
		fi
		for outputCodec in $outputCodecs; do
			case "$outputCodec" in
				lossy*|*Vorbis|Opus|WavPackLossy|MP3|AAC) hasLossy=true ;;
				FLAC|WavPack|WavPackHybrid|MonkeysAudio) hasLossless=true ;;
			esac
		done

		if [ $hasLossy = true ]; then
			for h in $hashes; do
				case "$h" in
					CRC32)
						{
						hline="$( computeCRC32 "$wavFile" )"
						test -n "$hline" && echo "SOURCECRC32=${hline}" > "$sourceCRC32File"
						} & ;;

					MD5)
						{
						hline="$( computeMD5 "$wavFile" )"
						if [ -n "$hline" ]; then
							echo "SOURCEMD5=${hline}" > "$sourceMD5File"
							if [ -n "$sourceMD5" -a "$sourceMD5" != "$hline" ]; then
								printMessage 'warning' 'decoding' 'bad_internal_hash' $p "file:${sourceFile}" 'internal MD5 hash is incorrect (possible bug in the codec)!'
								printMessage 'info' 'decoding' 'stderr' 'Please file a bug report: https://github.com/gcocatre/caudec/issues'
							fi
						fi
						} & ;;

					SHA1)
						{
						hline="$( computeSHA "$wavFile" "$h" )"
						test -n "$hline" && echo "SOURCESHA1=${hline}" > "$sourceSHA1File"
						} & ;;

					SHA256)
						{
						hline="$( computeSHA "$wavFile" "$h" )"
						test -n "$hline" && echo "SOURCESHA256=${hline}" > "$sourceSHA256File"
						} & ;;

					SHA512)
						{
						hline="$( computeSHA "$wavFile" "$h" )"
						test -n "$hline" && echo "SOURCESHA512=${hline}" > "$sourceSHA512File"
						} & ;;
				esac
			done
			wait
		fi

		if [ $preventClipping = true ]; then
			soxGuard='-G'
		fi

		if [ -n "$bitDepth" ]; then
			bitdepthcmd="-b $bitDepth"
		fi

		if [ -n "$samplingRate" ]; then
			ratecmd="rate -v $samplingRate"
		fi

		if [ -n "$bitDepth" -o -n "$samplingRate" ]; then
			dithercmd='dither -a -s' # FL, FR, C, LFE, SL, SR, BL, BR; 1/4
		fi

		# convert to stereo (and at the same time, resample and / or apply gain if requested)
		if [ "$convertToStereo" != 'false' ]; then
			if [ $nChannels -gt 2 ]; then
				downmixToStereo || ec=$EX_IOERR
			elif [ $nChannels -eq 1 ]; then
				upmixToStereo || ec=$EX_IOERR
			fi
		fi

		# resample (and apply gain if requested) if not already done
		# make sure to test both wavProcessed != 'true' and ec = EX_OK, because wavProcessed will only be true if prior processing succeeded
		if [ $ec -eq $EX_OK -a "$wavProcessed" != 'true' ]; then # no prior processing, resampling has not yet be done
			if [ -n "$bitdepthcmd" -o -n "$ratecmd" ]; then
				sox $soxGuard "$wavFile" $bitdepthcmd "$resampledWavFile" $gaincmd $ratecmd $dithercmd >/dev/null 2>> "$errorLogFile" || ec=$EX_IOERR
				if [ $ec -eq $EX_OK -a -f "$resampledWavFile" ]; then
					mv -f "$resampledWavFile" "$wavFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_IOERR
					if [ $ec -eq $EX_OK ]; then
						isWavProcessed 'true'
					fi
				fi
				if [ -e "$resampledWavFile" ]; then rm -f "$resampledWavFile"; fi
			fi
		fi

		# apply gain if not already done
		if [ $ec -eq $EX_OK -a "$wavProcessed" != 'true' -a -n "$gaincmd" ]; then # no prior processing, gain has not yet been applied
			sox $soxGuard "$wavFile" "$resampledWavFile" $gaincmd >/dev/null 2>> "$errorLogFile" || ec=$EX_IOERR
			if [ $ec -eq $EX_OK -a -f "$resampledWavFile" ]; then
				mv -f "$resampledWavFile" "$wavFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_IOERR
				if [ $ec -eq $EX_OK ]; then
					isWavProcessed 'true'
				fi
			fi
			if [ -e "$resampledWavFile" ]; then rm -f "$resampledWavFile"; fi
		fi
	fi

	if [ $ec -ne $EX_OK ]; then
		rm -f "$wavFile" "$copyFile" "${copyFile}c" "$lossywavFile" "$resampledWavFile" # in case it exists
		rm -f "${TDIR}/"*"_${i}" # delete all codec lock files
		rm -f "${TDIR}/"*"_${i}_WAV_NEEDED" # delete associated lock files
		if [ $ec -eq $EX_IOERR ]; then
			printMessage 'error' 'processing' "file:${sourceFile}" $p
		elif [ $ec -ne $EX_OK ]; then
			printMessage 'error' 'decoding' "file:${sourceFile}" $p
		fi
		return $EX_KO
	fi

	if [ "$OS" = 'Linux' ]; then
		stat -L --printf ' + %s' "$wavFile" >> "${TDIR}/bytes" 2>> "$errorLogFile"
	else
		stat -L -n -f ' + %z' "$wavFile" >> "${TDIR}/bytes" 2>> "$errorLogFile"
	fi

	if [ $hasLossless = true ]; then
		for h in $hashes; do
			case "$h" in
				CRC32)
					if [ "$wavProcessed" != 'true' -a -f "$sourceCRC32File" ]; then
						$sedcmd -e 's@SOURCE@@' "$sourceCRC32File" > "$losslessCRC32File" 2>/dev/null
						hval="$( $sedcmd -e 's@SOURCE@@' "$sourceCRC32File" 2>/dev/null )"
						test -n "$hval" && printMessage 'info' "$h" "$hval" "file:${sourceFile}" $p
					else
						{
						hline="$( computeCRC32 "$wavFile" )"
						test -n "$hline" && echo "CRC32=${hline}" > "$losslessCRC32File"
						test -n "$hline" && printMessage 'info' "$h" "CRC32=$hline" "file:${sourceFile}" $p
						} &
					fi
					;;

				MD5)
					if [ "$wavProcessed" != 'true' -a -f "$sourceMD5File" ]; then
						$sedcmd -e 's@SOURCE@@' "$sourceMD5File" > "$losslessMD5File"
						hval="$( $sedcmd -e 's@SOURCE@@' "$sourceMD5File" 2>/dev/null )"
						test -n "$hval" && printMessage 'info' "$h" "$hval" "file:${sourceFile}" $p
					else
						{
						hline="$( computeMD5 "$wavFile" )"
						test -n "$hline" && printMessage 'info' "$h" "MD5=$hline" "file:${sourceFile}" $p
						if [ -n "$hline" ]; then
							echo "MD5=${hline}" > "$losslessMD5File"
							if [ "$wavProcessed" != 'true' -a -n "$sourceMD5" -a "$sourceMD5" != "$hline" ]; then
								printMessage 'warning' 'decoding' 'bad_internal_hash' $p "file:${sourceFile}" 'internal MD5 hash is incorrect (possible bug in the codec)!'
								printMessage 'info' 'decoding' 'stderr' 'Please file a bug report: https://github.com/gcocatre/caudec/issues'
							fi
						fi
						} &
					fi
					;;

				SHA1)
					if [ "$wavProcessed" != 'true' -a -f "$sourceSHA1File" ]; then
						$sedcmd -e 's@SOURCE@@' "$sourceSHA1File" > "$losslessSHA1File"
						hval="$( $sedcmd -e 's@SOURCE@@' "$sourceSHA1File" 2>/dev/null )"
						test -n "$hval" && printMessage 'info' "$h" "$hval" "file:${sourceFile}" $p
					else
						{
						hline="$( computeSHA "$wavFile" "$h" )"
						test -n "$hline" && echo "SHA1=${hline}" > "$losslessSHA1File"
						test -n "$hline" && printMessage 'info' "$h" "SHA1=$hline" "file:${sourceFile}" $p
						} &
					fi
					;;

				SHA256)
					if [ "$wavProcessed" != 'true' -a -f "$sourceSHA256File" ]; then
						$sedcmd -e 's@SOURCE@@' "$sourceSHA256File" > "$losslessSHA256File"
						hval="$( $sedcmd -e 's@SOURCE@@' "$sourceSHA256File" 2>/dev/null )"
						test -n "$hval" && printMessage 'info' "$h" "$hval" "file:${sourceFile}" $p
					else
						{
						hline="$( computeSHA "$wavFile" "$h" )"
						test -n "$hline" && echo "SHA256=${hline}" > "$losslessSHA256File"
						test -n "$hline" && printMessage 'info' "$h" "SHA256=$hline" "file:${sourceFile}" $p
						} &
					fi
					;;

				SHA512)
					if [ "$wavProcessed" != 'true' -a -f "$sourceSHA512File" ]; then
						$sedcmd -e 's@SOURCE@@' "$sourceSHA512File" > "$losslessSHA512File"
						hval="$( $sedcmd -e 's@SOURCE@@' "$sourceSHA512File" 2>/dev/null )"
						test -n "$hval" && printMessage 'info' "$h" "$hval" "file:${sourceFile}" $p
					else
						{
						hline="$( computeSHA "$wavFile" "$h" )"
						test -n "$hline" && echo "SHA512=${hline}" > "$losslessSHA512File"
						test -n "$hline" && printMessage 'info' "$h" "SHA512=$hline" "file:${sourceFile}" $p
						} &
					fi
					;;
			esac
		done
		wait
	fi

	processSourceTagFile

	for outputCodec in $outputCodecs; do
		case "$outputCodec" in
			FLAC|lossyFLAC|OggVorbis|Opus) convertTags $sourceTagFormat 'vc' ;;
			WavPack*|MonkeysAudio|lossyWV) convertTags $sourceTagFormat 'ape' ;;
			MP3) convertTags $sourceTagFormat 'mp3' ;;
			AAC) convertTags $sourceTagFormat 'm4a' ;;
		esac
	done

	return $ec
}

encodeLossyWAV ()
{
	local ec=$EX_OK overwriteLossyWAV=true

	encodedFile="$lossywavFile"

	if [ $copyLossyWAV = true ]; then
		getFileProps "$sourceFile" 'lossyWAV'
		if [ $copyPath = true ]; then
			if ! mkdir -p "$destPath" >/dev/null 2>&1 ; then
				ec=$EX_KO
			fi
		fi
	fi

	if [ $ec -eq $EX_OK ]; then
		if [ ! -e "$lossywavFile" ]; then
			cd "$SWAPDIR"
			lossywav "${i}.wav" -q $compression_lossyWAV >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
			cd "$OLDPWD"
		fi
	fi

	if [ $ec -eq $EX_OK ]; then
		for outputCodec in $outputCodecs; do
			case "$outputCodec" in
				lossyFLAC|lossyWV)
					for h in $hashes; do
						case $h in
							CRC32)
								hline="$( computeCRC32 "$lossywavFile" )"
								test -n "$hline" && echo "CRC32=$hline" > "$lossywavCRC32File"
								;;

							MD5)
								hline="$( computeMD5 "$lossywavFile" )"
								test -n "$hline" && echo "MD5=$hline" > "$lossywavMD5File"
								;;

							SHA1)
								hline="$( computeSHA "$lossywavFile" "$h" )"
								test -n "$hline" && echo "SHA1=$hline" > "$lossywavSHA1File"
								;;

							SHA256)
								hline="$( computeSHA "$lossywavFile" "$h" )"
								test -n "$hline" && echo "SHA256=$hline" > "$lossywavSHA256File"
								;;

							SHA512)
								hline="$( computeSHA "$lossywavFile" "$h" )"
								test -n "$hline" && echo "SHA512=$hline" > "$lossywavSHA512File"
								;;
						esac
					done
					break
					;;
			esac
		done

		if [ $copyLossyWAV = true ]; then
			overwriteLossyWAV=true
			if [ -e "$destFile" ]; then
				if [ $keepExistingFiles = true ]; then
					overwriteLossyWAV=false
				elif [ $keepNewerFiles = true ]; then
					if isFileNewer "$destFile" "$sourceFile"; then
						overwriteLossyWAV=false
					fi
				fi
			fi
			if [ $overwriteLossyWAV = true ]; then
				chmod 0644 "$encodedFile"
				cp "$encodedFile" "$destFile" >/dev/null 2>> "$errorLogFile"
				printMessage 'success' 'encoding' $p "file:${destFile}"
			fi
		fi
	else
		rm -f "$lossywavFile" # delete lossyWAV file if it exists
		rm -f "${TDIR}/lossy"*"_${i}" # delete all lossy* codec lock files
		rm -f "${TDIR}/"*"_${i}_LOSSYWAV_NEEDED" # delete associated codec lock files
		rm -f "${TDIR}/lossyWAV_${i}_WAV_NEEDED"
		printMessage 'error' 'encoding' $p "file:${sourceFile}"
	fi

	return $ec
}

getEncoderVersions ()
{
	local outputCodec oggencPath vorbisPrefix libvorbisVersion

	for outputCodec in $outputCodecs; do
		case "$outputCodec" in
			FLAC) flacVersion="$( flac --version | head -n 1 )"; flacVersion="${flacVersion##* }" ;;
			MonkeysAudio) apeVersion="$( mac 2>&1 | grep -F '(c)' | tr -d ' ' | cut -d '(' -f 2 | cut -d ')' -f 1 )"; apeVersion="${apeVersion#v}" ;;
			MP3) lameVersion="$( lame --version 2>/dev/null | grep -E 'LAME.*version' | cut -d 'v' -f 2 | cut -d '(' -f 1 | cut -d ' ' -f 2- )" ; lameVersion="${lameVersion% *}" ;;
			AAC) aacVersion="$( ffmpeg -version 2>/dev/null | grep -E '^ffmpeg version' | cut -d ' ' -f 3 )" ;;
			Opus) opusVersion="$( opusenc --version 2>/dev/null | grep -F 'opusenc' )" ;;

			WavPack|WavPackHybrid|WavPackLossy)
				wavpackVersion="$( wavpack --version 2>/dev/null | head -n 1 )"
				wavpackVersion="${wavpackVersion##* }"
				;;

			lossy*)
				lossywavVersion="$( lossywav -v 2>/dev/null | grep -F 'lossyWAV' | tr -d '\r\n' )" # recent lossyWAV
				if [ -z "$lossywavVersion" ]; then
					lossywavVersion="$( lossywav -v 2>&1 | grep -F 'lossyWAV' | tr -d '\r\n' )" # old lossyWAV
				fi
				lossywavVersion="${lossywavVersion##* }"
				;;

			OggVorbis)
				oggencVersion="$( oggenc -V | tr -cd '0-9.' )"
				oggencPath="$( which oggenc )"
				vorbisPrefix="${oggencPath%/oggenc}"; vorbisPrefix="${vorbisPrefix%/bin}"
				if [ -f "${vorbisPrefix}/lib/pkgconfig/vorbisenc.pc" ]; then
					libvorbisVersion="$( grep -i 'version' "${vorbisPrefix}/lib/pkgconfig/vorbisenc.pc" | tr -cd '0-9.' )"
					oggencVersion="${oggencVersion}, libvorbis $libvorbisVersion"
				fi
				;;
		esac
	done
}

isFileNewer ()
{
	local a="$1" b="$2" mtimeA mtimeB

	if [ "$a" -nt "$b" ]; then
		return $EX_OK
	else
		if [ "$OS" = 'Linux' ]; then
			mtimeA="$( stat -c '%Y' "$a" )"
			mtimeB="$( stat -c '%Y' "$b" )"
		else
			mtimeA="$( stat -f '%m' "$a" )"
			mtimeB="$( stat -f '%m' "$b" )"
		fi
		if [ "$mtimeA" = "$mtimeB" ]; then
			return $EX_OK
		else
			return $EX_KO
		fi
	fi
}

overwriteDestFile ()
{
	local overwrite=true

	getFileProps "$1" "$2"
	if [ -e "$destFile" ]; then
		if [ $keepExistingFiles = true ]; then
			overwrite=false
		elif [ $keepNewerFiles = true ]; then
			if isFileNewer "$destFile" "$sourceFile"; then
				overwrite=false
			fi
		fi
	fi

	if [ $overwrite = true ]; then
		return $EX_OK
	else
		return $EX_KO
	fi
}

copyOrLinkAllFiles ()
{
	local codec="$1" f otherFileBasename destOtherFile destOtherLinkedFile
	for f in "$sourceDirname"/*; do
		case "$f" in
			*.wav|*.caf|*.aiff|*.flac|*.wv|*.wvc|*.ape|*.ogg|*.mp3|*.m4a|*.opus) continue ;;
		esac
		if [ -f "$f" ]; then
			otherFileBasename="${f##*/}"
			destOtherFile="${destPath}/${otherFileBasename}"
			if [ "$codec" = "WavPackLossy" -a -n "$linkDir" ]; then
				destOtherLinkedFile="${destLinkPath}/${otherFileBasename}"
				ln -f "$destOtherFile" "$destOtherLinkedFile" >/dev/null 2>> "$errorLogFile"
			else
				if [ ! -e "$destOtherFile" ]; then
					if [ -d "$destLinkPath" ]; then
						destLinkOtherFile="${destLinkPath}/${otherFileBasename}"
						rm -f "$destLinkOtherFile" >/dev/null 2>> "$errorLogFile" # for consistency
					fi
					cp "$f" "$destOtherFile" >/dev/null 2>> "$errorLogFile"
				fi
			fi
		fi
	done
}

copyOrLinkCommaSeparatedFiles ()
{
	local codec="$1" pattern="$2" listOfOtherFiles otherFile extOtherFile otherFileBasename destOtherFile destOtherLinkedFile

	OIFS="$IFS"; IFS=','
	read -a listOfOtherFiles <<< "$pattern"
	for otherFile in "${listOfOtherFiles[@]}"; do
		case "$otherFile" in
			.*)
				for extOtherFile in "$sourceDirname"/*"$otherFile"; do
					if [ -f "$extOtherFile" ]; then
						otherFileBasename="${extOtherFile##*/}"
						destOtherFile="${destPath}/${otherFileBasename}"
						if [ "$codec" = "WavPackLossy" -a -n "$linkDir" ]; then
							destOtherLinkedFile="${destLinkPath}/${otherFileBasename}"
							if [ ! -e "$destOtherLinkedFile" ]; then
								ln -f "$destOtherFile" "$destOtherLinkedFile" >/dev/null 2>> "$errorLogFile"
							fi
						else
							if [ -d "$destLinkPath" ]; then
								destLinkOtherFile="${destLinkPath}/${otherFileBasename}"
								rm -f "$destLinkOtherFile" >/dev/null 2>> "$errorLogFile" # for consistency
							fi
							if [ ! -e "${destOtherFile}" ]; then
								cp "$extOtherFile" "${destOtherFile}" >/dev/null 2>> "$errorLogFile"
							fi
						fi
					fi
				done
			;;

			*)
				if [ -f "${sourceDirname}/${otherFile}" ]; then
					destOtherFile="${destPath}/${otherFile}"
					if [ "$codec" = "WavPackLossy" -a -n "$linkDir" ]; then
						destOtherLinkedFile="${destLinkPath}/${destOtherFile}"
						ln -f "$destOtherFile" "$destOtherLinkedFile" >/dev/null 2>> "$errorLogFile"
					else
						if [ ! -e "$destOtherFile" ]; then
							cp "${sourceDirname}/${otherFile}" "$destOtherFile" >/dev/null 2>> "$errorLogFile"
						fi
					fi
				fi
			;;
		esac
	done
	IFS="$OIFS"
}

copyOrLinkFile ()
{
	local codec="$1" otherFile="$2" extOtherFile otherFileBasename destOtherFile destOtherLinkedFile

	case "$otherFile" in
		.*)
			for extOtherFile in "$sourceDirname"/*"$otherFile"; do
				if [ -f "$extOtherFile" ]; then
					otherFileBasename="${extOtherFile##*/}"
					destOtherFile="${destPath}/${otherFileBasename}"
					if [ "$codec" = "WavPackLossy" -a -n "$linkDir" ]; then
						destOtherLinkedFile="${destLinkPath}/${otherFileBasename}"
						ln -f "$destOtherFile" "$destOtherLinkedFile" >/dev/null 2>> "$errorLogFile"
					elif [ ! -e "${destOtherFile}" ]; then
						if [ -d "$destLinkPath" ]; then
							destLinkOtherFile="${destLinkPath}/${otherFileBasename}"
							rm -f "$destLinkOtherFile" >/dev/null 2>> "$errorLogFile" # for consistency
						fi
						cp "$extOtherFile" "${destOtherFile}" >/dev/null 2>> "$errorLogFile"
					fi
				fi
			done
		;;

		*)
			if [ -f "${sourceDirname}/${otherFile}" ]; then
				destOtherFile="${destPath}/${otherFile}"
				if [ "$codec" = "WavPackLossy" -a -n "$linkDir" ]; then
					destOtherLinkedFile="${destLinkPath}/${otherFile}"
					ln -f "$destOtherFile" "$destOtherLinkedFile" >/dev/null 2>> "$errorLogFile"
				else
					if [ ! -e "$destOtherFile" ]; then
						cp "${sourceDirname}/${otherFile}" "$destOtherFile" >/dev/null 2>> "$errorLogFile"
					fi
				fi
			fi
		;;
	esac
}

copyOrLinkOtherFiles ()
{
	local codec="$1" pattern="$2"

	pattern="$( getCodecOtherFiles "$codec" )"

	if [ -n "$pattern" ]; then
		case "$pattern" in
			all) copyOrLinkAllFiles "$codec" ;;
			*,*) copyOrLinkCommaSeparatedFiles "$codec" "$pattern" ;;
			*) copyOrLinkFile "$codec" "$pattern" ;;
		esac
	fi
}

encode ()
{
	local ec=$EX_OK pattern="x${outputCodec}Y" kfm='' statusInfo='' nRunningProcesses nThreads listOfOtherFiles audioFile otherFile otherFileBasename extOtherFile destOtherFile

	compressionTag=''

	if overwriteDestFile "$sourceFile" "$outputCodec"; then
		nThreads=1
		case "$outputCodec" in
			WAV)
				if [ $sourceIsLossyWAV = true ]; then
					destExtension='lossy.wav'; encodedFile="$lossywavFile"
				else
					destExtension='wav'; encodedFile="$wavFile"
				fi
				;;

			AIFF)
				destExtension='aiff'; encodedFile="${SWAPDIR}/${i}-${outputCodec}.${destExtension}"
				sox "$wavFile" "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				;;

			CAF)
				destExtension='caf'; encodedFile="${SWAPDIR}/${i}-${outputCodec}.${destExtension}"
				sox "$wavFile" "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				;;

			FLAC)
				destExtension='flac'; encodedFile="${SWAPDIR}/${i}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${i}.vc.txt" kfm=''
				# Kohlrabi is a very cool dude
				if [ $keepWavMetadata = true ]; then kfm='--keep-foreign-metadata' ; fi
				if [ $tagCompressionSetting = true ]; then compressionTag="ENCODING=$me $VERSION / FLAC $flacVersion / -$compression_FLAC"; fi
				nThreads=$( getNumberOfAvailableThreads $i $maxFlacThreads )
				printf -- "-s`tagline -T`\x00%s" "$wavFile" | xargs -0 flac -j $nThreads -P 4096 $kfm -${compression_FLAC} -o "$encodedFile" >/dev/null 2>> "$errorLogFile" &&
				importArtworkIntoFLAC || ec=$EX_KO
				;;

			WavPack)
				destExtension='wv'; encodedFile="${SWAPDIR}/${i}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${i}.ape.txt" kfm='-r'
				if [ -e "${destFile}c" ]; then
					printMessage 'error' 'usage' 'filesystem' "path:${destDir}" "$me -c wv: correction files are present. Please delete them and try again." ; ec=$EX_KO
				else
					if [ $keepWavMetadata = true ]; then kfm=''; fi
					nThreads=$( getNumberOfAvailableThreads $i $maxWavPackThreads )
					if [ $tagCompressionSetting = true ]; then compressionTag="Encoding=$me $VERSION / WavPack $wavpackVersion / -$compression_WavPack"; fi
					printf -- "-q`tagline -w`\x00%s" "$wavFile" | xargs -0 wavpack --threads=$nThreads -m $kfm -${compression_WavPack} -o "$encodedFile" --no-utf8-convert >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
					if [ $ec -eq $EX_OK -a -f "$destTagFile" ]; then
						importBinariesIntoAPEv2 || ec=$EX_KO
						importArtworkIntoAPEv2 || ec=$EX_KO
					fi
				fi
				;;

			WavPackHybrid)
				destExtension='wv'; encodedFile="${SWAPDIR}/${i}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${i}.ape.txt" kfm='-r'
				if [ $keepWavMetadata = true ]; then kfm=''; fi
				nThreads=$( getNumberOfAvailableThreads $i $maxWavPackThreads )
				if [ $tagCompressionSetting = true ]; then
					if [ "${bitrate_WavPackLossy%.*}" -lt 24 ]; then
						compressionTag="Encoding=$me $VERSION / WavPack $wavpackVersion / -$compression_WavPack / $bitrate_WavPackLossy bits per sample (ABR)"
					else
						compressionTag="Encoding=$me $VERSION / WavPack $wavpackVersion / -$compression_WavPack / $bitrate_WavPackLossy kbps (ABR)"
					fi
				fi
				printf -- "-q`tagline -w`\x00%s" "$wavFile" | xargs -0 wavpack --threads=$nThreads -m $kfm -o "$encodedFile" -c${compression_WavPack} -b${bitrate_WavPackLossy} --no-utf8-convert >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				if [ $ec -eq $EX_OK -a -f "$destTagFile" ]; then
					importBinariesIntoAPEv2 || ec=$EX_KO
					importArtworkIntoAPEv2 || ec=$EX_KO
				fi
				;;

			WavPackLossy)
				destExtension='wv'; encodedFile="${SWAPDIR}/${i}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${i}.ape.txt" kfm='-r'
				if [ -e "${destFile}c" ]; then
					printMessage 'error' 'usage' 'filesystem' "path:${destDir}" "$me -c wv: correction files are present. Please delete them and try again." ; ec=$EX_KO
				else
					if [ $keepWavMetadata = true ]; then kfm=''; fi
					nThreads=$( getNumberOfAvailableThreads $i $maxWavPackThreads )
					if [ $tagCompressionSetting = true ]; then
						if [ -z "$compression_WavPack" ]; then
							compressionTag="Encoding=$me $VERSION / WavPack $wavpackVersion / default / $bitrate_WavPackLossy bits per sample (ABR)"
						else
							compressionTag="Encoding=$me $VERSION / WavPack $wavpackVersion / -$compression_WavPack / $bitrate_WavPackLossy kbps (ABR)"
						fi
					fi
					printf -- "-q`tagline -w`\x00%s" "$wavFile" | xargs -0 wavpack --threads=$nThreads -m $kfm -o "$encodedFile" -$compression_WavPack -b${bitrate_WavPackLossy} --no-utf8-convert >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
					if [ $ec -eq $EX_OK -a -f "$destTagFile" ]; then
						importBinariesIntoAPEv2 || ec=$EX_KO
						importArtworkIntoAPEv2 || ec=$EX_KO
					fi
				fi
				;;

			MonkeysAudio)
				destExtension='ape'; encodedFile="${SWAPDIR}/${i}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${i}.ape.txt"
				nThreads=$( getNumberOfAvailableThreads $i )
				mac "$wavFile" "$encodedFile" -c${compression_MonkeysAudio}000 -threads=${nThreads} >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				if [ $ec -eq $EX_OK -a -f "$destTagFile" ]; then
					if [ $tagCompressionSetting = true ]; then compressionTag="Encoding=$me $VERSION / Monkey's Audio $apeVersion / -c${compression_MonkeysAudio}000"; fi
					printf -- "-R`tagline -t`\x00%s" "$encodedFile" | xargs -0 APEv2 -z >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
					importBinariesIntoAPEv2 || ec=$EX_KO
					importArtworkIntoAPEv2 || ec=$EX_KO
				fi
				;;

			lossyFLAC)
				destExtension='lossy.flac'; encodedFile="${SWAPDIR}/${i}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${i}.vc.txt"
				if [ $tagCompressionSetting = true ]; then compressionTag="ENCODING=$me $VERSION / lossyWAV $lossywavVersion / -q $compression_lossyWAV"; fi
				nThreads=$( getNumberOfAvailableThreads $i $maxFlacThreads )
				printf -- "--totally-silent`tagline -T`\x00%s" "$lossywavFile" | xargs -0 flac -j $nThreads -P 4096 -5 -b 512 --keep-foreign-metadata -o "$encodedFile" >/dev/null 2>> "$errorLogFile" &&
				importArtworkIntoFLAC || ec=$EX_KO
				;;

			lossyWV)
				destExtension='lossy.wv'; encodedFile="${SWAPDIR}/${i}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${i}.ape.txt"
				nThreads=$( getNumberOfAvailableThreads $i $maxWavPackThreads )
				if [ $tagCompressionSetting = true ]; then compressionTag="Encoding=$me $VERSION / lossyWAV $lossywavVersion / -q $compression_lossyWAV"; fi
				printf -- "-q`tagline -w`\x00%s" "$lossywavFile" | xargs -0 wavpack --threads=$nThreads -m -o "$encodedFile" --blocksize=512 --merge-blocks --no-utf8-convert >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				if [ $ec -eq $EX_OK -a -f "$destTagFile" ]; then
					importBinariesIntoAPEv2 || ec=$EX_KO
					importArtworkIntoAPEv2 || ec=$EX_KO
				fi
				;;

			OggVorbis)
				destExtension='ogg'; encodedFile="${SWAPDIR}/${i}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${i}.vc.txt"
				if [ "$OggVorbis_MODE" = 'VBR' ]; then
					if [ $tagCompressionSetting = true ]; then compressionTag="ENCODING=$me $VERSION / oggenc $oggencVersion / -q $compression_OggVorbis"; fi
					printf -- "-Q`tagline -c`\x00%s" "$wavFile" | xargs -0 oggenc -q $compression_OggVorbis -o "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				elif [ "$OggVorbis_MODE" = 'ABR' ]; then
					if [ $tagCompressionSetting = true ]; then compressionTag="ENCODING=$me $VERSION / oggenc $oggencVersion / $average_bitrate_OggVorbis kbps (ABR)"; fi
					printf -- "-Q`tagline -c`\x00%s" "$wavFile" | xargs -0 oggenc --managed -b $average_bitrate_OggVorbis -o "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				else
					if [ $tagCompressionSetting = true ]; then compressionTag="ENCODING=$me $VERSION / oggenc $oggencVersion / $bitrate_OggVorbis kbps (CBR)"; fi
					printf -- "-Q`tagline -c`\x00%s" "$wavFile" | xargs -0 oggenc --managed -b $bitrate_OggVorbis -m $bitrate_OggVorbis -M $bitrate_OggVorbis -o "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				fi
				;;

			MP3)
				destExtension='mp3'; encodedFile="${SWAPDIR}/${i}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${i}.mp3.txt"
				if [ "$compression_MP3" = 'insane' -o "$compression_MP3" = '320' ]; then
					MP3_MODE='CBR' bitrate_MP3=320
				fi
				if [ "$MP3_MODE" = 'VBR' ]; then
					if [ $tagCompressionSetting = true ]; then compressionTag="--text-frame TSSE=$me $VERSION / LAME $lameVersion / -V $compression_MP3"; fi
						lame -S -V $compression_MP3 --noreplaygain --id3v2-only --pad-id3v2-size $ID3Padding --ignore-tag-errors -o "$wavFile" "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				elif [ "$MP3_MODE" = 'ABR' ]; then
					if [ $tagCompressionSetting = true ]; then compressionTag="--text-frame TSSE=$me $VERSION / LAME $lameVersion / $average_bitrate_MP3 kbps (ABR)"; fi
						lame -S --abr $average_bitrate_MP3 --noreplaygain --id3v2-only --pad-id3v2-size $ID3Padding --ignore-tag-errors -o "$wavFile" "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				else
					if [ $tagCompressionSetting = true ]; then compressionTag="--text-frame TSSE=$me $VERSION / LAME $lameVersion / $bitrate_MP3 kbps (CBR)"; fi
					if [ $bitrate_MP3 -eq 320 ]; then
						lame -S --preset insane --noreplaygain --id3v2-only --pad-id3v2-size $ID3Padding --ignore-tag-errors -o "$wavFile" "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
					else
						lame -S -b $bitrate_MP3 --cbr --noreplaygain --id3v2-only --pad-id3v2-size $ID3Padding --ignore-tag-errors -o "$wavFile" "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
					fi
				fi
				if [ $ec -ne $EX_KO ]; then
					printf -- "`tagline`" | xargs -0 eyeD3 --quiet --to-v2.4 --force-update --encoding 'utf8' "$encodedFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
					importArtworkIntoMP3 || ec=$EX_KO
				fi
				;;

			AAC)
				destExtension='m4a'; encodedFile="${SWAPDIR}/${i}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${i}.m4a.txt" aaclib="" aaclibs="aac libfdk_aac aac_at"
				for ((l=0; l < ${#aaclibs[@]}; l++)); do
					aaclib="${aaclibs[$l]}"
					if [ -z "$sourceCoverArtFile" ]; then
						for f in "${SWAPDIR}/picture-${i}-"*_*; do
							if [ ! -e "$f" ]; then continue; fi
							picType="${f#*_}"; picType="${picType%.*}"
							case $picType in
								3) sourceCoverArtFile="$f" ; break ;;
							esac
						done
					fi
					if [ -n "$sourceCoverArtFile" -a -e "$sourceCoverArtFile" ]; then
						printf -- "`tagline`\x00%s\x00%s" "$encodedFile" | xargs -0 ffmpeg -i "$wavFile" -i "$sourceCoverArtFile" -map 0:a -map 1 -codec copy -metadata:s:v title="Album cover" -metadata:s:v comment="Cover (front)" -disposition:v attached_pic -c:a aac -b:a "${average_bitrate_AAC}k" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
					else
						printf -- "`tagline`\x00%s\x00%s" "$encodedFile" | xargs -0 ffmpeg -i "$wavFile" -c:a aac -b:a "${average_bitrate_AAC}k" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
					fi
					if [ $ec -eq $EX_OK ]; then break; fi
				done
				;;

			Opus)
				destExtension='opus'; encodedFile="${SWAPDIR}/${i}-${outputCodec}.${destExtension}" destTagFile="${TDIR}/${i}.vc.txt"
				if [ "$Opus_MODE" = 'VBR' ]; then
					if [ $tagCompressionSetting = true ]; then compressionTag="ENCODING=$me $VERSION / $opusVersion / $compression_Opus kbps (VBR)"; fi
					printf -- "--quiet`tagline --comment`\x00%s`genOpusArtworkCommandLine`\x00%s" "$wavFile" "$encodedFile" | xargs -0 opusenc --vbr --bitrate $compression_Opus >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				elif [ "$Opus_MODE" = 'ABR' ]; then
					if [ $tagCompressionSetting = true ]; then compressionTag="ENCODING=$me $VERSION / $opusVersion / $average_bitrate_Opus kbps (CVBR)"; fi
					printf -- "--quiet`tagline --comment`\x00%s`genOpusArtworkCommandLine`\x00%s" "$wavFile" "$encodedFile" | xargs -0 opusenc --cvbr --bitrate $average_bitrate_Opus >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				else
					if [ $tagCompressionSetting = true ]; then compressionTag="ENCODING=$me $VERSION / $opusVersion / $bitrate_Opus kbps (CBR)"; fi
					printf -- "--quiet`tagline --comment`\x00%s`genOpusArtworkCommandLine`\x00%s" "$wavFile" "$encodedFile" | xargs -0 opusenc --hard-cbr --bitrate $bitrate_Opus >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				fi
				;;
		esac

		if [ $copyPath = true ]; then
			if ! mkdir -p "$destPath" >/dev/null 2>&1 ; then
				ec=$EX_KO
			fi
			if [ -n "$destLinkPath" ]; then
				if ! mkdir -p "$destLinkPath" >/dev/null 2>&1 ; then
					ec=$EX_KO
				fi
			fi
		fi

		if [ "$outputCodec" = 'WAV' ]; then
			statusInfo='decoding'
		else
			statusInfo='encoding'
		fi

		if [ $ec -eq $EX_OK ]; then
			if [ -e "$encodedFile" ]; then
				chmod 0644 "$encodedFile"
				if [ -e "${encodedFile}c" ]; then # WavPack Hybrid correction files
					chmod 0644 "${encodedFile}c"
				fi
				if [ "$outputCodecs" = 'WAV' ]; then
					mv "$encodedFile" "$destFile" >/dev/null 2>> "$errorLogFile"
				elif [ -L "$encodedFile" -o "$outputCodec" = 'WAV' ]; then
					cp "$encodedFile" "$destFile" >/dev/null 2>> "$errorLogFile"
					if [ -e "${encodedFile}c" ]; then
						cp "${encodedFile}c" "${destFile}c" >/dev/null 2>> "$errorLogFile"
					fi
				else
					mv "$encodedFile" "$destFile" >/dev/null 2>> "$errorLogFile"
					if [ -e "${encodedFile}c" ]; then  # WavPack Hybrid correction files
						mv "${encodedFile}c" "${destFile}c" >/dev/null 2>> "$errorLogFile"
					fi
				fi

				if [ "$outputCodec" = "WavPackHybrid" -a -n "$destLinkPath" ]; then
					if [ -e "$destLinkFile" ]; then # delete old link for consistency``
						rm -f "$destLinkFile" >/dev/null 2>> "$errorLogFile"
					fi
					if [ -f "$destFile" ]; then
						ln -f "$destFile" "$destLinkPath" >/dev/null 2>> "$errorLogFile"
					fi
				fi

				copyOrLinkOtherFiles "$outputCodec"
				if [ "$outputCodec" = "WavPackHybrid" -a -d "$destLinkPath" ]; then
					copyOrLinkOtherFiles "WavPackLossy"
				fi

				if [ "$outputCodec" = "WAV" ]; then
					printMessage 'success' "$statusInfo" "file:${destFile}" $p # FIXME DECODE THREADS
				else
					printMessage 'success' "$statusInfo" "file:${destFile}" $p "threads:$nThreads" # FIXME DECODE THREADS
				fi
			fi
		else
			rm -f "$encodedFile" >/dev/null 2>&1 # in case it exists
			printMessage 'error' "$statusInfo" "file:${sourceFile}" $p
		fi
	fi

	return $ec
}

cleanUpCopyLockFile ()
{
	local copyLockFile="$1" pid

	if [ -f "${copyLockFile}.lock" ]; then
		pid="$( cat "${copyLockFile}.lock" )"
		if [ -n "$pid" ]; then
			if ! isProcessRunning $pid ; then
				echo '' > "${copyLockFile}.lock" 2>/dev/null
				mv "${copyLockFile}.lock" "$copyLockFile" >/dev/null 2>&1
			fi
		fi
	fi
}

prepareSource ()
{
	local sourcePath ec=$EX_OK copyLockFile copyDone=false cptimer1 cptimer2 cpseconds attemptNumber=0

	if [ $preloadSources = true -a $touchFiles = false ]; then
		if [ "$OS" = 'Linux' ]; then
			copyLockFile="${iodir}/$( stat -c '%d' "$sourceFile" 2>> "$errorLogFile" )"
		else
			copyLockFile="${iodir}/$( stat -f '%d' "$sourceFile" 2>> "$errorLogFile" )"
		fi
		until test $copyDone = true; do
			# if test -f "$copyLockFile" && mv "$copyLockFile" "${copyLockFile}.lock" >/dev/null 2>&1; then
			if getAndRenameLock "$copyLockFile" "${copyLockFile}.lock"; then
				touch "${instanceDir}/ioLockFiles/${copyLockFile##*/}"
				echo "$$" > "${copyLockFile}.lock"

				if [ $gnudate = true ]; then
					cptimer1="$( $datecmd '+%s.%N' )"
				fi

				cp "$sourceFile" "$copyFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				if [ -e "${sourceFile}c" ]; then # WavPack correction file
					cp "${sourceFile}c" "${copyFile}c" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				fi

				echo '' > "${copyLockFile}.lock" 2>/dev/null
				mv "${copyLockFile}.lock" "$copyLockFile" >/dev/null 2>&1 &&
				rm -f "${instanceDir}/ioLockFiles/${copyLockFile##*/}" >/dev/null 2>&1
				copyDone=true

				if [ -n "$cptimer1" ]; then
					if [ $gnudate = true ]; then
						cptimer2="$( $datecmd '+%s.%N' )"
					fi
					if [ -n "$cptimer2" ]; then
						cpseconds="$( printf 'scale=6; %.6f - %.6f\n' "$cptimer2" "$cptimer1" | bc )"
						echo -n " + $cpseconds" >> "${TDIR}/readTimes"
					fi
				fi
			else
				if [ $attemptNumber -ge 100 ]; then
					cleanUpCopyLockFile "$copyLockFile"
					n=0
				else
					sleep 0.1
					((n++))
				fi
			fi
		done
	else
		if [ "${sourceFile:0:1}" = '/' ]; then # sourceFile is an absolute path
			sourcePath="$sourceFile"
		else # sourceFile is a relative path; prepend current directory
			sourcePath="${PWD}/${sourceFile}"
		fi
		if [ -n "$copyFile" ]; then
			if [ ! -h "$copyFile" ]; then
				ln -s "$sourcePath" "$copyFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
			fi

			if [ -e "${sourcePath}c" ]; then # WavPack correction file
				if [ ! -h "${copyFile}c" ]; then
					ln -s "${sourcePath}c" "${copyFile}c" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				fi
			fi
		fi
	fi

	if [ $ec -ne $EX_OK ]; then
		rm -f "$copyFile" "${copyFile}c" >/dev/null 2>&1
	fi
	return $ec
}

addTranscodingErrorFile ()
{
	echo "$1" >> "${TDIR}/transcodingErrorFiles"
}

transcode ()
{
	local lastCodec="${outputCodecs##* }" allDone=false copyDone=false encodingDone=false ec=$EX_OK lsec=0 bytes i

	until test $allDone = true; do
		allDone=true
		while read bytes i; do
			getFileProps "${sourceFiles[$i]}"
			copyFile="${SWAPDIR}/${i}.${sourceFilename}"

			transcodingLockFile="${TDIR}/${i}"
			wasProcessedFile="${TDIR}/WAS_PROCESSED.${i}"
			decodingLockFile="${TDIR}/DECODING_${i}"
			wavFile="${SWAPDIR}/${i}.wav"
			resampledWavFile="${SWAPDIR}/${i}_resampled.wav"
			lossywavFile="${SWAPDIR}/${i}.lossy.wav"
			wavProcessedStatusFile="${TDIR}/${i}.wavProcessed"
			sourceTagFile="${TDIR}/${i}.txt"
			apeBinariesDir="${TDIR}/${i}.apeBinariesDir"
			trackGainFile="${TDIR}/${i}.trackgain"
			trackPeakFile="${TDIR}/${i}.trackpeak"
			secondsFile="${TDIR}/${i}.seconds"
			millisecondsFile="${TDIR}/${i}.milliseconds"
			sourceCRC32File="${TDIR}/${i}.sourceCRC32"
			sourceMD5File="${TDIR}/${i}.sourceMD5"
			sourceSHA1File="${TDIR}/${i}.sourceSHA1"
			sourceSHA256File="${TDIR}/${i}.sourceSHA256"
			sourceSHA512File="${TDIR}/${i}.sourceSHA512"
			losslessCRC32File="${TDIR}/${i}.losslessCRC32"
			losslessMD5File="${TDIR}/${i}.losslessMD5"
			losslessSHA1File="${TDIR}/${i}.losslessSHA1"
			losslessSHA256File="${TDIR}/${i}.losslessSHA256"
			losslessSHA512File="${TDIR}/${i}.losslessSHA512"
			lossywavCRC32File="${TDIR}/${i}.lossywavCRC32"
			lossywavMD5File="${TDIR}/${i}.lossywavMD5"
			lossywavSHA1File="${TDIR}/${i}.lossywavSHA1"
			lossywavSHA256File="${TDIR}/${i}.lossywavSHA256"
			lossywavSHA512File="${TDIR}/${i}.lossywavSHA512"

			# if test -e "$transcodingLockFile" && mv "$transcodingLockFile" "$decodingLockFile" 2>/dev/null; then
			if getAndRenameLock "$transcodingLockFile" "$decodingLockFile"; then
				allDone=false
				prepareSource &&
				decode || ec=$EX_KO
				if [ $ec -ne $EX_OK ]; then addTranscodingErrorFile "$sourceFile" ; fi
				rm -f "$decodingLockFile" >/dev/null 2>&1
			elif [ -e "$decodingLockFile" ]; then # can't do anything for this track yet, gotta wait for it to be decoded
				allDone=false
				continue # skip to next track
			fi

			lossywavLockFile="${TDIR}/lossyWAV_${i}"
			lossywavEncodingLockFile="${lossywavLockFile}_encoding"
			if [ $nLossyWAV -ge 1 ]; then
				# if test -e "$lossywavLockFile" && mv "$lossywavLockFile" "$lossywavEncodingLockFile" 2>/dev/null ; then
				if getAndRenameLock "$lossywavLockFile" "$lossywavEncodingLockFile"; then
					allDone=false
					encodeLossyWAV || ec=$EX_KO
					if [ $ec -ne $EX_OK ]; then addTranscodingErrorFile "$sourceFile" ; fi
					rm -f "$lossywavEncodingLockFile" "${lossywavLockFile}_WAV_NEEDED"
					ls "${TDIR}/"*"_${i}_WAV_NEEDED" >/dev/null 2>&1 || rm -f "$wavFile"
					ls "${TDIR}/"*"_${i}_LOSSYWAV_NEEDED" >/dev/null 2>&1 || rm -f "$lossywavFile"
				fi
			fi

			for outputCodec in $outputCodecs; do
				test "$outputCodec" = 'lossyWAV' && continue
				if [ "$outputCodec" = 'lossyFLAC' -o "$outputCodec" = 'lossyWV' ]; then
					if [ -e "$lossywavEncodingLockFile" ]; then # lossyWAV encoding in progress, skip to next codec
						allDone=false
						continue
					fi
				fi
				encodingLockFile="${TDIR}/${outputCodec}_${i}"
				# if test -e "$encodingLockFile" && unlink "$encodingLockFile" 2>/dev/null; then
				if test -e "$encodingLockFile" && getLock "$encodingLockFile"; then
					allDone=false
					encode || ec=$EX_KO
					if [ $ec -ne $EX_OK ]; then addTranscodingErrorFile "$sourceFile" ; fi
					rm -f "${encodingLockFile}_WAV_NEEDED"
					ls "${TDIR}/"*"_${i}_WAV_NEEDED" >/dev/null 2>&1 || rm -f "$wavFile"
					if [ "$outputCodec" = 'lossyFLAC' -o "$outputCodec" = 'lossyWV' ]; then
						rm -f "${encodingLockFile}_LOSSYWAV_NEEDED"
						ls "${TDIR}/"*"_${i}_LOSSYWAV_NEEDED" >/dev/null 2>&1 || rm -f "$lossywavFile"
					fi
					touch "$wasProcessedFile"
				fi
			done

			# FIXME: this mysteriously causes some random picture not to be copied (race condition?)
			# if ! ls "${TDIR}/"*"_${i}_LOSSYWAV_NEEDED" >/dev/null 2>&1 ; then
			# 	if ! ls "${TDIR}/"*"_${i}_WAV_NEEDED" >/dev/null 2>&1 ; then
			# 		ls "${SWAPDIR}/picture-${i}"* >/dev/null 2>&1 &&
			# 		rm -f "${SWAPDIR}/picture-${i}"* >/dev/null 2>&1
			# 		if [ -e "$apeBinariesDir" ]; then
			# 			rm -rf "$apeBinariesDir"
			# 		fi
			# 	fi
			# fi
		chmod u+rwX "$destPath" "${destPath}"/* 2>> "$errorLogFile" # FIXME chmod u=rw,go=r
		done < "${TDIR}/bytesAndFileNumbers"
		sleep 0.1 # make sure idling processes don't hog the CPU
	done

	rm -f "${instanceDir}/process.${p}"
	return $ec
}

compareHashes ()
{
	local hashvalA='' hashvalB=''

	case "$testHashType" in
		SHA512) hashvalA="$hashSHA512"; hashvalB="$( computeSHA "$wavFile" 'SHA512' )" ;;
		SHA256) hashvalA="$hashSHA256"; hashvalB="$( computeSHA "$wavFile" 'SHA256' )" ;;
		SHA1) hashvalA="$hashSHA1"; hashvalB="$( computeSHA "$wavFile" 'SHA1' )" ;;
		MD5) hashvalA="$hashMD5"; hashvalB="$( computeMD5 "$wavFile" )" ;;
		CRC32) hashvalA="$hashCRC32"; hashvalB="$( computeCRC32 "$wavFile" )" ;;
	esac

	if [ -z "$hashvalA" -o -z "$hashvalB" ]; then
		return $EX_DATAERR
	elif [ "$hashvalA" = "$hashvalB" ]; then
		return $EX_OK
	else
		return $EX_KO
	fi
}

checkHashAvailability ()
{
	local hashtype="$1" hashval="$2"

	test -z "$hashval" && return $EX_DATAERR
	which 'sox' >/dev/null 2>&1 || return $EX_OSFILE

	case "$hashtype" in
		SHA512)
			if [ "$OS" = 'Linux' ]; then
				which 'sha512sum' >/dev/null 2>&1 || return $EX_OSFILE
			else
				which 'shasum' >/dev/null 2>&1 || return $EX_OSFILE
			fi
			;;

		SHA256)
			if [ "$OS" = 'Linux' ]; then
				which 'sha256sum' >/dev/null 2>&1 || return $EX_OSFILE
			else
				which 'shasum' >/dev/null 2>&1 || return $EX_OSFILE
			fi
			;;

		SHA1)
			if [ "$OS" = 'Linux' ]; then
				which 'sha1sum' >/dev/null 2>&1 || return $EX_OSFILE
			else
				which 'shasum' >/dev/null 2>&1 || return $EX_OSFILE
			fi
			;;

		MD5)
			if [ "$OS" = 'Linux' ]; then
				which 'md5sum' >/dev/null 2>&1 || return $EX_OSFILE
			else
				which 'md5' >/dev/null 2>&1 || return $EX_OSFILE
			fi
			;;

		CRC32)
			which 'cksfv' >/dev/null 2>&1 || return $EX_OSFILE
			;;
	esac

	return $EX_OK
}

getSuitableHash ()
{
	local errType=$EX_DATAERR

	if [ -z "$hashtags" ]; then
		return $EX_DATAERR
	fi

	checkHashAvailability 'SHA512' "$hashSHA512"; ec=$?
	if [ $ec -eq $EX_OK ]; then
		testHashType='SHA512'
		return $EX_OK
	elif [ $ec -eq $EX_OSFILE ]; then
		errType=$EX_OSFILE
	fi

	checkHashAvailability 'SHA256' "$hashSHA256"; ec=$?
	if [ $ec -eq $EX_OK ]; then
		testHashType='SHA256'
		return $EX_OK
	elif [ $ec -eq $EX_OSFILE ]; then
		errType=$EX_OSFILE
	fi


	checkHashAvailability 'SHA1' "$hashSHA1"; ec=$?
	if [ $ec -eq $EX_OK ]; then
		testHashType='SHA1'
		return $EX_OK
	elif [ $ec -eq $EX_OSFILE ]; then
		errType=$EX_OSFILE
	fi

	checkHashAvailability 'MD5' "$hashMD5"; ec=$?
	if [ $ec -eq $EX_OK ]; then
		testHashType='MD5'
		return $EX_OK
	elif [ $ec -eq $EX_OSFILE ]; then
		errType=$EX_OSFILE
	fi

	checkHashAvailability 'CRC32' "$hashCRC32"; ec=$?
	if [ $ec -eq $EX_OK ]; then
		testHashType='CRC32'
		return $EX_OK
	elif [ $ec -eq $EX_OSFILE ]; then
		errType=$EX_OSFILE
	fi

	return $errType
}

getHashTags ()
{
	hashtags='' hashSHA512='' hashSHA256='' hashSHA1='' hashMD5='' hashCRC32=''
	if [ ! -e "$sourceTagFile" ]; then return $EX_DATAERR; fi

	$sedcmd -i'' -e 's@crc=@CRC32=@i' "$sourceTagFile" >/dev/null 2>&1
	hashtags="$( grep -iE '^SHA512=|^SHA256=|^SHA1=|^MD5=|^CRC32=' "$sourceTagFile" 2>/dev/null | sort -u 2>/dev/null )"
	if [ -z "$hashtags" ]; then
		return $EX_DATAERR
	fi

	hashSHA512="$( echo "$hashtags" | grep -Fi 'SHA512=' 2>/dev/null | cut -d '=' -f 2 2>/dev/null )"
	hashSHA256="$( echo "$hashtags" | grep -Fi 'SHA256=' 2>/dev/null | cut -d '=' -f 2 2>/dev/null )"
	hashSHA1="$( echo "$hashtags" | grep -Fi 'SHA1=' 2>/dev/null | cut -d '=' -f 2 2>/dev/null )"
	hashMD5="$( echo "$hashtags" | grep -Fi 'MD5=' 2>/dev/null | cut -d '=' -f 2 2>/dev/null )"
	hashCRC32="$( echo "$hashtags" | grep -Fi 'CRC32=' 2>/dev/null | cut -d '=' -f 2 2>/dev/null )"

	return $EX_OK
}

testFile ()
{
	local ec=$EX_OK nThreads=1

	if [ -e "$copyFile" ]; then
		case "$copyFile" in
			*.flac)
				flac -st "$copyFile" >/dev/null 2>&1; ec=$?
				saveDurations
				;;

			*.wv)
				nThreads=$( getNumberOfAvailableThreads $i $maxWavPackThreads )
				wvunpack --threads=$nThreads -qmv "$copyFile" >/dev/null 2>&1; ec=$?
				saveDurations
				;;

			*.ape)
				nThreads=$( getNumberOfAvailableThreads $i )
				mac "$copyFile" -threads=$nThreads -V >/dev/null 2>&1; ec=$?
				saveDurations
				;;

			*) printMessage 'warning' 'testing' 'unsupported' "file:${sourceFile}" $p 'unsupported format' ; return $EX_KO ;;
		esac
	else
		ec=$EX_KO
	fi

	if [ -e "$wavFile" ]; then rm -f "$wavFile"; fi
	if [ -e "$copyFile" ]; then rm -f "$copyFile" "${copyFile}c" >/dev/null 2>&1; fi

	if [ $ec -eq $EX_OK ]; then
		printMessage 'success' 'testing' $p "threads:$nThreads" "file:${sourceFile}"
	else
		printMessage 'error' 'testing' $p "file:${sourceFile}"
	fi
	return $ec
}

getLock ()
{
	local lockFile="$1"
	if [ "$OS" = 'Darwin' ]; then
		lockf -s -n -t 1 "$lockFile" test -e "$lockFile" &>/dev/null
	else
		unlink "$lockFile" 2>/dev/null
	fi
}

getAndRenameLock ()
{
	local lockFileOne="$1" lockFileTwo="$2"
	if [ "$OS" = 'Darwin' ]; then
		lockf -k -s -n -t 1 "$lockFileOne" mv "$lockFileOne" "$lockFileTwo" &>/dev/null
	else
		test -e "$lockFileOne" && mv "$lockFileTwo" 2>/dev/null
	fi
}

testFiles ()
{
	local ec=$EX_OK bytes i
	while read bytes i; do
		sourceFile="${sourceFiles[$i]}"
		sourceFilename="${sourceFile##*/}"
		copyFile="${SWAPDIR}/${i}.${sourceFilename}"
		wavFile="${SWAPDIR}/${i}.wav"
		sourceTagFile="${TDIR}/${i}.txt"
		testingLockFile="${TDIR}/${i}"
		wasProcessedFile="${TDIR}/WAS_PROCESSED.${i}"

		if getLock "$testingLockFile"; then
			prepareSource &&
			testFile || ec=$EX_KO
			if [ -e "$wavFile" ]; then rm -f "$wavFile" >/dev/null 2>&1; fi
			if [ -e "$copyFile" ]; then rm -f "$copyFile" "${copyFile}c" >/dev/null 2>&1; fi
			touch "$wasProcessedFile"
		fi
	done < "${TDIR}/bytesAndFileNumbers"

	rm -f "${instanceDir}/process.${p}"
	return $ec
}

getInternalMD5 ()
{
	local f="$1" dn bn

	sourceMD5=''
	case "$f" in
		*.flac) sourceMD5="$( metaflac --show-md5sum "$f" 2>/dev/null )" ;;

		*.wv)
			sourceMD5="$( wvunpack -f "$f" 2>/dev/null | cut -d ';' -f 7 )"
			;;
	esac
}

computeHash ()
{
	local ec=$EX_OK ereg nThreads=1

	if [ -e "$copyFile" ]; then
		sourceMD5=''
		case "$copyFile" in
			*.flac)
				metaflac --no-utf8-convert --export-tags-to="$sourceTagFile" "$copyFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				if [ $ec -eq $EX_OK ]; then
					getInternalMD5 "$copyFile"
					flac -s -d -o "$wavFile" "$copyFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				fi
				;;

			*.wv)
				touch "$sourceTagFile"
				if [ $ec -eq $EX_OK ]; then
					getInternalMD5 "$copyFile"
					nThreads=$( getNumberOfAvailableThreads $i $maxWavPackThreads )
					wvunpack -q -m --threads=$nThreads -o "$wavFile" "$copyFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				fi
				;;

			*.ape)
				touch "$sourceTagFile"
				if [ $ec -eq $EX_OK ]; then
					nThreads=$( getNumberOfAvailableThreads $i )
					mac "$copyFile" "$wavFile" -d -threads=$nThreads >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				fi
				;;

			*) printMessage 'warning' 'hashing' 'unsupported' "file:${sourceFile}" $p 'unsupported format' ; return $EX_KO ;;
		esac

		if [ -e "$copyFile" ]; then rm -f "$copyFile" "${copyFile}c" >/dev/null 2>&1; fi

		if [ $ec -eq $EX_OK ]; then
			processSourceTagFile
			ereg=""
			for h in $hashes; do
				ereg="${ereg}|^${h}="
				if [ "$h" = 'CRC32' ]; then
					ereg="${ereg}|^crc="
				fi
			done
			# filter out existing hashes
			grep -viE "${ereg:1}" "$sourceTagFile" > "${sourceTagFile}.tmp"
			mv "${sourceTagFile}.tmp" "$sourceTagFile"

			for h in $hashes; do
				case "$h" in
					CRC32)
						{
						hline="$( computeCRC32 "$wavFile" )"
						test -n "$hline" && echo "CRC32=$hline" >> "$sourceTagFile"
						test -n "$hline" && printMessage 'info' "$h" "${h}=${hline}" "file:${sourceFile}" $p
						} & ;;

					MD5)
						{
						hline="$( computeMD5 "$wavFile" )"
						test -n "$hline" && printMessage 'info' "$h" "${h}=${hline}" "file:${sourceFile}" $p
						if [ -n "$hline" ]; then
							echo "MD5=${hline}" >> "$sourceTagFile"
							if [ -n "$sourceMD5" -a "$sourceMD5" != "$hline" ]; then
								printMessage 'warning' 'hashing' 'bad_internal_hash' $p "file:${sourceFile}" 'internal MD5 hash is incorrect (possible bug in the codec)!'
								printMessage 'info' 'hashing' 'stderr' 'Please file a bug report: https://github.com/gcocatre/caudec/issues'
							fi
						fi
						} & ;;

					SHA1|SHA256|SHA512)
						{
						hline="$( computeSHA "$wavFile" "$h" )"
						test -n "$hline" && echo "${h}=${hline}" >> "$sourceTagFile"
						test -n "$hline" && printMessage 'info' "$h" "${h}=${hline}" "file:${sourceFile}" $p
						} & ;;
				esac
			done
			wait
		fi

		if [ -e "$wavFile" ]; then rm -f "$wavFile" >/dev/null 2>&1; fi

		if [ $ec -eq $EX_OK ]; then
			case "$copyFile" in
				*.flac)
					destTagFile="${TDIR}/${i}.vc.txt" outputCodec="FLAC"
					cp "$sourceTagFile" "$destTagFile" >/dev/null 2>&1 &&
					printf -- "--no-utf8-convert`tagline --set-tag`\x00%s" "$sourceFile" | xargs -0 metaflac --remove-all-tags >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
					;;

				*.wv|*.ape)
					destTagFile="${TDIR}/${i}.ape.txt" outputCodec="WavPack"
					cp "$sourceTagFile" "$destTagFile" >/dev/null 2>&1 &&
					printf -- "-z`tagline -t`\x00%s" "$sourceFile" | xargs -0 APEv2 >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
					;;
			esac
		fi
	else
		ec=$EX_KO
	fi

	if [ $ec -eq $EX_OK ]; then
		printMessage 'success' 'hashing' $p "threads:$nThreads" "file:${sourceFile}"
	else
		printMessage 'error' 'decoding' $p "file:${sourceFile}"
	fi
	return $ec
}

computeHashes ()
{
	local ec=$EX_OK
	for ((i=0; i < ${#sourceFiles[@]}; i++)); do
		sourceFile="${sourceFiles[$i]}"
		sourceFilename="${sourceFile##*/}"
		sourceTagFile="${TDIR}/${i}.txt"
		sourceMD5File="${TDIR}/${i}.md5"
		copyFile="${SWAPDIR}/${i}.${sourceFilename}"
		wavFile="${SWAPDIR}/${i}.wav"
		hashingLockFile="${TDIR}/${i}"
		wasProcessedFile="${TDIR}/WAS_PROCESSED.${i}"

		if getLock "$hashingLockFile"; then
			prepareSource || ec=$EX_KO
			if [ $ec -eq $EX_OK ]; then
				computeHash || ec=$EX_KO
			fi
			if [ -e "$wavFile" ]; then rm -f "$wavFile" >/dev/null 2>&1; fi
			if [ -e "$copyFile" ]; then rm -f "$copyFile" "${copyFile}c" >/dev/null 2>&1; fi
			touch "$wasProcessedFile"
		fi
	done

	rm -f "${instanceDir}/process.${p}"
	return $ec
}

saveReplaygainToMP3 ()
{
	local ec=$EX_OK

	eyeD3 -2 --user-text-frame="REPLAYGAIN_${gainType}_GAIN:${gain} dB" \
		--user-text-frame="REPLAYGAIN_${gainType}_PEAK:${peak}" "$destFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO

	return $ec
}

saveGain ()
{
	local gainType="$1" gainTypeText ec=$EX_OK gain peak uGain

	if [ "$gainType" = 'TRACK' ]; then
		gain="$trackGain" peak="$trackPeak" uGain="$trackGain"
	else
		gain="$albumGain" peak="$albumPeak" uGain="$albumGain"
	fi

	if [ "${gain:0:1}" != '-' ]; then
		gain="+${gain}"
	fi

	case "$destFile" in
		*.flac)
			metaflac --remove-tag="REPLAYGAIN_${gainType}_GAIN" --remove-tag="REPLAYGAIN_${gainType}_PEAK" \
				--set-tag="REPLAYGAIN_${gainType}_GAIN=${gain} dB" --set-tag="REPLAYGAIN_${gainType}_PEAK=${peak}" "$destFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
			;;

		*.wv)
			if [ "$gainType" = 'TRACK' ]; then
				gainTypeText='Track'
			else
				gainTypeText='Album'
			fi
			destTagFile="${TDIR}/${i}.ape.txt"
			if [ "$gainType" = 'ALBUM' ]; then
				echo "Replaygain_${gainTypeText}_Gain=${gain} dB" >> "$destTagFile"
				echo "Replaygain_${gainTypeText}_Peak=${peak}" >> "$destTagFile"
			fi
			printf -- "-z`tagline -t`\x00%s" "$destFile" | xargs -0 APEv2 >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
			;;

		*.ape)
			destTagFile="${TDIR}/${i}.ape.txt"
			if [ "$gainType" = 'TRACK' ]; then
				gainTypeText='Track'
			else
				gainTypeText='Album'
			fi
			echo "Replaygain_${gainTypeText}_Gain=${gain} dB" >> "$destTagFile"
			echo "Replaygain_${gainTypeText}_Peak=${peak}" >> "$destTagFile"
			printf -- "-z`tagline -t`\x00%s" "$destFile" | xargs -0 APEv2 >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
			;;

		*.ogg)
			destTagFile="${TDIR}/${i}.vc.txt"
			echo "REPLAYGAIN_${gainType}_PEAK=${peak}" >> "$destTagFile"
			echo "REPLAYGAIN_${gainType}_GAIN=${gain} dB" >> "$destTagFile"
			printf -- "-w`tagline -t`\x00%s" "$destFile" | xargs -0 vorbiscomment >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
			;;

		*.mp3)
			if [ $applyGain = true ]; then
				if [ "$applyGainType" = 'ALBUM' -o "$applyGainType" = 'TRACK' -o "$applyGainType" = 'ALBUM_PEAK' -o "$applyGainType" = 'TRACK_PEAK' ]; then
					if [ "$gainType" = "${applyGainType%_*}" ]; then
						gainX="$( echo "scale=2; $uGain / 1.5" | bc )"
						gainX="$( printf '%.0f' "$gainX" )"
						mp3gain -c -g "$gainX" "$destFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
					fi
				elif [ "$gainType" = 'TRACK' ]; then
					uGain="${applyGainType#+}"
					gainX="$( echo "scale=2; $uGain / 1.5" | bc )"
					gainX="$( printf '%.0f' "$gainX" )"
					mp3gain -c -g "$gainX" "$destFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				fi
			else
				saveReplaygainToMP3 || ec=$EX_KO
			fi
			;;

		*) ec=$EX_KO ;;
	esac

	return $ec
}

saveSeconds ()
{
	local samples sampleRate seconds=0 duration hours minutes centiseconds ec=$EX_OK line msec milliseconds=0 data file nThreads infoExe

	if [ $touchFiles = true ]; then
		file="$sourceFile"
	else
		file="$copyFile"
	fi

	case "$file" in
		*.flac)
			data="$( metaflac --show-total-samples --show-sample-rate "$file" 2>> "$errorLogFile" )"
			if [ -n "$data" ]; then
				for v in $data; do
					if [ -z "$samples" ]; then
						samples="$v"
					else
						sampleRate="$v"
					fi
				done
				seconds=$(( (samples + (sampleRate / 2)) / sampleRate )) # (sampleRate / 2) is for rounding
				milliseconds="$( echo "scale=3; $samples / $sampleRate" | bc )"
			fi
			;;

		*.wv)
			nThreads=$( getNumberOfAvailableThreads $i $maxWavPackThreads )
			data="$( wvunpack  -f "$file" 2>/dev/null )"
			if [ -n "$data" ]; then
				samples="$( echo "$data" | cut -d ';' -f 6 )"
				sampleRate="$( echo "$data" | cut -d ';' -f 1 )"
				if [ -n "$samples" -a -n "$sampleRate" ]; then
					seconds=$(( (samples + (sampleRate / 2)) / sampleRate )) # (sampleRate / 2) is for rounding
					milliseconds="$( echo "scale=3; $samples / $sampleRate" | bc )"
				fi
			fi
			;;

		*.ogg|*.opus)
			case "$file" in
				*.ogg) infoExe="ogginfo" ;;
				*.opus) infoExe="opusinfo" ;;
			esac
			line="$( $infoExe "$file" 2>> "$errorLogFile" | grep -F 'Playback length:' | tr -d '\t ' | cut -d ':' -f 2-3 )"
			if [ -n "$line" ]; then
				minutes="${line%:*}" ; minutes="${minutes%m}"
				seconds="${line#*:}" ; seconds="${seconds%s}"; seconds="${seconds%\.*}"
				msec="${line#*\.}" ; msec="${msec%s}"
				seconds="${seconds%.*}" ; seconds="${seconds#0}"
				milliseconds="$( echo "scale=3; (($minutes * 60) + $seconds + 0.$msec) / 1" | bc -l )"
				if [ "${msec:0:1}" -ge 5 ]; then
					((seconds++))
				fi
				seconds=$(( (minutes * 60) + seconds ))
			fi
			;;

		*.ape|*.m4a)
			line="$( ffprobe -print_format 'default' -show_streams -select_streams 'a:0' "$file" 2>/dev/null | grep -F 'duration=' 2>/dev/null | cut -d '=' -f 2 | tr -cd '0-9.' )"
			if [ -n "$line" ]; then
				seconds="${line%.*}" milliseconds="${line#*.}"
				if [ "${milliseconds:0:1}" -ge 5 ]; then
					((seconds++))
				fi
				milliseconds="$( echo "scale=3; ($seconds + 0.${milliseconds}) / 1" | bc )"
			fi
			;;

		*.mp3)
			getSoxSeconds "$file"
			;;

		*)
			getSoxSeconds "$wavFile"
			;;
	esac

	echo "$seconds" > "$secondsFile"
	echo "$milliseconds" > "$millisecondsFile"
	echo -n " + $seconds" >> "${TDIR}/durations"
	return $ec
}

computeTrackGain ()
{
	local ec=$EX_OK line nLines=0 decimals sGain

	if [ -e "$copyFile" ]; then
		case "$copyFile" in
			*.flac)
				metaflac --add-replay-gain "$copyFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				if [ $ec -eq $EX_OK ]; then
					trackGain="$( metaflac --show-tag="REPLAYGAIN_TRACK_GAIN" "$copyFile" 2>> "$errorLogFile" | cut -d '=' -f 2 | cut -d ' ' -f 1 | tr -d '+' )"
					trackPeak="$( metaflac --show-tag="REPLAYGAIN_TRACK_PEAK" "$copyFile" 2>> "$errorLogFile" | cut -d '=' -f 2 )"
				fi
				if [ -n "$trackGain" -a -n "$trackPeak" ]; then
					echo "$trackGain" > "$trackGainFile"
					echo "$trackPeak" > "$trackPeakFile"
					saveSeconds
				else
					ec=$EX_KO
				fi
				;;

			*.wv)
				APEv2 -z -r 'replaygain_track_gain' -r 'replaygain_album_gain' -r 'replaygain_track_peak' -r 'replaygain_album_peak' "$copyFile" >/dev/null 2>&1
				wvgain -q "$copyFile" >/dev/null 2>> "$errorLogFile" || ec=$EX_KO
				if [ $ec -eq $EX_OK ]; then
					APEv2 -z "$copyFile" 2>> "$errorLogFile" | grep -iE '^replaygain_track_' | $sedcmd \
						-e 's@replaygain_track_gain@Replaygain_Track_Gain@i' \
						-e 's@replaygain_track_peak@Replaygain_Track_Peak@i' > "$sourceTagFile" 2>/dev/null || ec=$EX_KO
					if [ $ec -eq $EX_OK ]; then
						processSourceTagFile
						destTagFile="${TDIR}/${i}.ape.txt"
						convertTags 'ape' 'ape'
						trackGain="$( grep -i 'Replaygain_Track_Gain=' "$destTagFile" | cut -d '=' -f 2 | cut -d ' ' -f 1 | tr -d '+' )"
						trackPeak="$( grep -i 'Replaygain_Track_Peak=' "$destTagFile" | cut -d '=' -f 2 )"
						if [ -n "$trackGain" -a -n "$trackPeak" ]; then
							echo "$trackGain" > "$trackGainFile"
							echo "$trackPeak" > "$trackPeakFile"
							saveSeconds
						else
							ec=$EX_KO
						fi
					fi
				fi
				;;

			*.ogg)
				line="$( vorbisgain -d "$copyFile" 2>/dev/null | grep -F "$copyFile" | tr -cd '.|\-0-9' )"
				if [ -z "$line" ]; then ec=$EX_KO; fi
				if [ $ec -eq $EX_OK ]; then
					trackGain="$( echo "$line" | cut -d '|' -f 1 )"
					trackGain="${trackGain#+}"
					decimals="${trackGain#*.}"
					trackGain="${trackGain%.*}.${decimals:0:2}"
					trackPeak="$( echo "$line" | cut -d '|' -f 2 )"
					trackPeak="$( echo "scale=8; $trackPeak / 32767" | bc )"
					if [ "${trackPeak:0:1}" = '.' ]; then
						trackPeak="0${trackPeak}"
					fi
					if [ -n "$trackGain" -a -n "$trackPeak" ]; then
						vorbiscomment -l "$copyFile" | grep -ivE '^replaygain_' 2>> "$errorLogFile" > "$sourceTagFile" || ec=$EX_KO
						if [ $ec -eq $EX_OK ]; then
							processSourceTagFile
							destTagFile="${TDIR}/${i}.vc.txt"
							cp "$sourceTagFile" "$destTagFile" >/dev/null 2>&1
							echo "$trackGain" > "$trackGainFile"
							echo "$trackPeak" > "$trackPeakFile"
							saveSeconds
						fi
					else
						ec=$EX_KO
					fi
				fi
				;;

			*.opus) saveSeconds ;;

			*.mp3)
				if [ -L "$copyFile" ]; then # make a real copy so that APE metadata doesn't get added to the source
					rm -f "$copyFile" >/dev/null 2>&1 && cp "$sourceFile" "$copyFile" >/dev/null 2>&1 ; ec=$?
				fi
				if [ $ec -eq $EX_OK ]; then
					line="$( mp3gain -e -k -o -q "$copyFile" 2>> "$errorLogFile" | grep -Fv 'MP3 gain' | tr '\t' '|' | tr -d '+' | cut -d '|' -f 3-4 )" ; ec=$?
					if [ $ec -eq $EX_OK -a -n "$line" ]; then
						trackGain="${line%|*}"
						decimals="${trackGain#*.}"
						trackGain="${trackGain%.*}.${decimals:0:2}"
						trackPeak="${line#*|}"; trackPeak="${trackPeak%.*}"
						trackPeak="$( echo "scale=8; $trackPeak / 32767" | bc )"
						if [ "${trackPeak:0:1}" = '.' ]; then
							trackPeak="0${trackPeak}"
						fi
						if [ -n "$trackGain" -a -n "$trackPeak" ]; then
							if [ $applyGain = true -a "$applyGainType" = 'TRACK_PEAK' ]; then
								trackGain="$( printf "%.2f" "$( echo  "20 * (l(${trackPeak}) / l(10))" | bc -l )" )"
								if [ "${trackGain:0:1}" = '-' ]; then
									trackGain="${trackGain:1}"
									if [ "${peakReference:0:1}" = '-' ]; then
										trackGain="$( printf "%.2f" "$( echo "$trackGain + ($peakReference)" | bc -l )" )"
									fi
								elif [ "${peakReference:0:1}" = '-' ]; then
									trackGain="$peakReference"
								else
									trackGain="-0"
								fi
							elif [ $applyGain = true -a "$applyGainType" = 'TRACK' -a -n "$preamp" ]; then
								if [ "${preamp:0:1}" = '-' ]; then
									trackGain="$( printf "%.2f" "$( echo "$trackGain - ${preamp:1}" | bc -l 2>/dev/null )" )"
								elif [ "${preamp:0:1}" = '+' ]; then
									trackGain="$( printf "%.2f" "$( echo "$trackGain + ${preamp:1}" | bc -l 2>/dev/null )" )"
								fi
							fi
							echo "$trackGain" > "$trackGainFile"
							echo "$trackPeak" > "$trackPeakFile"
							saveSeconds || ec=$EX_KO
						else
							ec=$EX_KO
						fi
					else
						ec=$EX_KO
					fi
				fi
				;;

			*) printMessage 'warning' 'track_gain' 'unsupported' "file:${sourceFile}" $p 'unsupported format' ; return $EX_KO ;;
		esac
	else
		ec=$EX_KO
	fi

	if [ "$sourceFileExt" != "opus" ]; then
		if [ $ec -eq $EX_OK ]; then
			saveGain 'TRACK' || ec=$EX_KO
		fi

		if [ -e "$wavFile" ]; then rm -f "$wavFile" >/dev/null 2>&1; fi
		if [ -e "$copyFile" ]; then rm -f "$copyFile" "${copyFile}c" >/dev/null 2>&1; fi

		if [ $ec -eq $EX_OK ]; then
			if [ $verbose = true ]; then
				if [ -n "$applyGainType" ]; then
					if [ "$applyGainType" = 'ALBUM' -o "$applyGainType" = 'TRACK' -o "$applyGainType" = 'ALBUM_PEAK' -o "$applyGainType" = 'TRACK_PEAK' ]; then
						sGain="$trackGain"
					else
						sGain="$applyGainType"
					fi
				else
					sGain="$trackGain"
				fi
				if [ "${sGain:0:1}" != '-' -a "${sGain:0:1}" != '+' ]; then
					sGain="+${sGain}"
				fi
				printMessage 'success' 'track_gain' $p "$sGain dB" "file:${sourceFile}"
			fi
		else
			printMessage 'error' 'track_gain' "file:${sourceFile}" $p
		fi
	fi
	return $ec
}

computeTrackGains ()
{
	local ec=$EX_OK bytes index

	while read bytes index; do
		sourceFile="${sourceFiles[$index]}"
		sourceFilename="${sourceFile##*/}"
		sourceFileExt="${sourceFile##*.}"
		copyFile="${SWAPDIR}/${index}.${sourceFilename}"
		gainLockFile="${TDIR}/${index}"
		wasProcessedFile="${TDIR}/WAS_PROCESSED.${index}"
		sourceTagFile="${TDIR}/${index}.txt"
		trackGainFile="${TDIR}/${index}.trackgain"
		trackPeakFile="${TDIR}/${index}.trackpeak"
		secondsFile="${TDIR}/${index}.seconds"
		millisecondsFile="${TDIR}/${index}.milliseconds"
		destFile="$sourceFile"
		wavFile="${SWAPDIR}/${index}.wav"

		if getLock "$gainLockFile"; then
			prepareSource &&
			computeTrackGain || ec=$EX_KO
			if [ -e "$wavFile" ]; then rm -f "$wavFile" >/dev/null 2>&1; fi
			if [ -e "$copyFile" ]; then rm -f "$copyFile" "${copyFile}c" >/dev/null 2>&1; fi
			touch "$wasProcessedFile"
		fi
	done < "${TDIR}/bytesAndFileNumbers"

	rm -f "${instanceDir}/process.${p}"
	return $ec
}

# rm -f /tmp/REPLAYGAIN_ALBUM_GAIN_DIFF.txt; for d in */*; do f="$( gls "$d" | head -n 1 )"; correctGain="$( metaflac --show-tag=REPLAYGAIN_ALBUM_GAIN "${d}/${f}" | sed -e 's@.*=@@' -e 's@^+\.@+0.@' -e 's@^-\.@-0.@' -e 's@ dB@@' )"; newGain="$( metaflac --show-tag=REPLAYGAIN_ALBUM_GAIN "~/replaygain/${d}/${f}" | sed -e 's@.*=@@' -e 's@^+\.@+0.@' -e 's@^-\.@-.@' -e 's@ dB@@' )"; diff="$( echo -e "(${correctGain}) - (${newGain})" | tr -d "+" | bc -z )"; if [ "${diff:0:1}" != '-' ]; then diff="+${diff}"; fi ; echo -e "${diff}\t${correctGain}\t${newGain}\t${d}" >> /tmp/REPLAYGAIN_ALBUM_GAIN_DIFF.txt ; done
computeAlbumGain ()
{
	# This is a very fast way of computing the album gain, but it is also less precise than the official implementation.
	# A comparison between gains on 754 albums revealed max differences ranging from -2.06 dB to +1.50 dB.
	# PINK_REF="64.82" is from flac/src/share/replaygain_analysis/replaygain_analysis.c
	local ec=$EX_OK PINK_REF_COMPLEMENT="35.18" i j s rank trackGain trackSeconds=1 increment=0
	local trackGainFile trackPeakFile trackSecondsFile trackMillisecondsFile albumPeak albumGain

	for ((i=0; i < ${#sourceFiles[@]}; i++)); do
		trackGainFile="${TDIR}/${i}.trackgain"
		trackPeakFile="${TDIR}/${i}.trackpeak"
		trackSecondsFile="${TDIR}/${i}.seconds"
		trackMillisecondsFile="${TDIR}/${i}.milliseconds"
		if [ -e "$trackGainFile" -a -e "$trackSecondsFile" ]; then
			trackGain="$( cat "$trackGainFile" )"
			trackSeconds="$( cat "$trackSecondsFile" )"
			if [ -z "$trackSeconds" ]; then
				trackSeconds=1
			fi
			for (( s=0; s < trackSeconds; s++ )); do
				echo "$trackGain" >> "${TDIR}/trackgains"
				((increment++))
			done
			cat "$trackPeakFile" >> "${TDIR}/trackpeaks" 2>/dev/null
		else
			printMessage 'error' 'album_gain' "Album gain"
			return $EX_KO
		fi
	done

	albumPeak="$( sort -n "${TDIR}/trackpeaks" 2>/dev/null | tail -n 1 )"
	if [ -z "$albumPeak" ]; then
		return $EX_KO
	fi

	if [ $applyGain = true -a "$applyGainType" = 'ALBUM_PEAK' ]; then
		albumGain="$( printf "%.2f" "$( echo "scale=3; (20 * (l(${albumPeak}) / l(10))) / 1" | bc -l 2>> "$errorLogFile" )" )"
		if [ "${albumGain:0:1}" = '-' ]; then
			albumGain="${albumGain:1}"
			if [ "${peakReference:0:1}" = '-' ]; then
				albumGain="$( printf "%.2f" "$( echo "scale=3; ($albumGain + ($peakReference)) / 1" | bc -l 2>> "$errorLogFile" )" )"
			fi
		elif [ "${peakReference:0:1}" = '-' ]; then
			albumGain="$peakReference"
		else
			albumGain="-0"
		fi
	else
		sort -n "${TDIR}/trackgains" > "${TDIR}/trackgains.tmp" 2>/dev/null
		mv "${TDIR}/trackgains.tmp" "${TDIR}/trackgains"

		# By using PINK_REF_COMPLEMENT instead of PINK_REF, running 'head' MIGHT be slightly faster than
		# running 'tail' with PINK_REF because 'head' will output fewer lines than 'tail'.
		rank="$( printf "%.0f" "$( echo "scale=5; (${PINK_REF_COMPLEMENT} / 100) * $increment + (1 / 2)" | bc )" )"
		albumGain="$( head -n $rank "${TDIR}/trackgains" 2>/dev/null | tail -n 1 )"
		if [ -z "$albumGain" ]; then
			printMessage 'error' 'album_gain' "Album gain"
			return $EX_KO
		elif [ $applyGain = true -a "$applyGainType" = 'ALBUM' -a -n "$preamp" ]; then
			if [ "${preamp:0:1}" = '-' ]; then
				albumGain="$( printf "%.2f" "$( echo "$albumGain - ${preamp:1}" | bc -l 2>/dev/null )" )"
			elif [ "${preamp:0:1}" = '+' ]; then
				albumGain="$( printf "%.2f" "$( echo "$albumGain + ${preamp:1}" | bc -l 2>/dev/null )" )"
			fi
		fi
	fi

	for ((i=0, j=0; i < ${#sourceFiles[@]}; i++, j++)); do
		if [ $j -lt $nProcesses ]; then
			destFile="${sourceFiles[$i]}"
			saveGain 'ALBUM' &
		else
			wait
			j=0
			destFile="${sourceFiles[$i]}"
			saveGain 'ALBUM' &
		fi
	done
	wait

	if [ "${albumGain:0:1}" != '-' ]; then
		albumGain="+${albumGain}"
	fi
	printMessage 'success' 'album_gain' "${albumGain} dB" "Album gain: $albumGain dB"

	return $ec
}

# https://github.com/FrancisRussell/zoog
computeOpusAlbumGain ()
 {
	local ec=$EX_OK list sourceFile albumPlaybackGain trackPlaybackGain trackDecibels signedTrackGain signedAlbumGain

	for sourceFile in "${sourceFiles[@]}"; do
		if [ -z "$list" ]; then
			list="$sourceFile"
		else
			list="${list}\x00${sourceFile}"
		fi
	done
	echo -en "$list" | xargs -0 opusgain -j $nProcesses -a -p rg 1>/dev/null 2>> "$errorLogFile" || ec=$EX_KO
	if [ $ec -ne $EX_KO ]; then
		# opusgain changes the rights on the files it touches, to u=rw,go=
		chmod u=rw,go=r "${sourceFiles[@]}" 1>/dev/null 2>> "$errorLogFile"

		albumPlaybackGain="$( opusinfo "$sourceFile" 2>> "$errorLogFile" | grep -F "Playback gain: " | cut -d ':' -f 2 | cut -d ' ' -f 2 )"
		albumPlaybackGain="$( printf "%.2f" "$albumPlaybackGain" )"
		for sourceFile in "${sourceFiles[@]}"; do
			trackPlaybackGain="$( opusinfo "$sourceFile" | grep -F "R128_TRACK_GAIN=" | cut -d '=' -f 2 | cut -d ' ' -f 1 )"
			trackPlaybackGain="${trackPlaybackGain#+*}"
			trackDecibels="$( echo "scale=3; ($albumPlaybackGain + ($trackPlaybackGain / 256) + 5) / 1" | bc 2>> "$errorLogFile" )"
			trackDecibels="$( printf "%.2f" "$trackDecibels" )"
			signedTrackGain="$trackDecibels"
			if [ "${signedTrackGain:0:1}" != '-' -a "${signedTrackGain:0:1}" != '+' ]; then
				signedTrackGain="+${signedTrackGain}"
			fi
			printMessage 'success' 'track_gain' 0 "$signedTrackGain dB" "file:${sourceFile}"
		done
		signedAlbumGain="$albumPlaybackGain"
		if [ "${signedAlbumGain:0:1}" != '-' -a "${signedAlbumGain:0:1}" != '+' ]; then
			signedAlbumGain="+${signedAlbumGain}"
		fi
		printMessage 'success' 'album_gain' "$signedAlbumGain dB"
	else
		printMessage 'error' 'album_gain' "Album gain"
	fi

	return $ec
 }

echoTouchString ()
{
  local trackDate="$1" hours="$2" minutes="$3" seconds="$4"
  if [ ${#hours} -lt 2 ]; then hours="0${hours}"; fi
  if [ ${#minutes} -lt 2 ]; then minutes="0${minutes}"; fi
  if [ ${#seconds} -lt 2 ]; then seconds="0${seconds}"; fi
  echo "${trackDate}${hours}${minutes}.${seconds}"
}

getTouchString ()
{
  local trackDate="$1" totalSeconds="$2" str="" fDays fHours fMinutes fSeconds fMilliseconds=0

  fSeconds=$totalSeconds
  fDays="$( echo "scale=0; $fSeconds / 86400" | bc )"
  fSeconds="$( echo "$fSeconds - ($fDays * 86400)" | bc )"
  fHours="$( echo "scale=0; $fSeconds / 3600" | bc )"
  fSeconds="$( echo "$fSeconds - ($fHours * 3600)" | bc )"
  fMinutes="$( echo "scale=0; $fSeconds / 60" | bc )"
  fSeconds="$( echo "scale=0; ($fSeconds - ($fMinutes * 60)) / 1" | bc )" # divide by 1 because "scale" only works on divisions
  fMilliseconds="$( echo "$totalSeconds" | cut -d "." -f 2 )"

	if [ "$fMilliseconds" == "" ]; then fMilliseconds=0; fi
  if [ $fMilliseconds -ge 500 ]; then
    fSeconds="$( echo "$fSeconds + 1" | bc )"
  fi

  echoTouchString $trackDate $fHours $fMinutes $fSeconds
}

computeTrackDateTime ()
{
	local ec=0 trackYear trackMonth trackDay


	case "$sourceFile" in
		*.flac|*ogg|*.m4a|*.wv|*.ape|*.opus)
			case "$sourceFile" in
				*.flac) date=$( metaflac --no-filename --show-tag=date "$sourceFile" | tr -cd "[:digit:]-" ) ;;
				*.ogg) date=$( vorbiscomment "$sourceFile" | grep -iF "date=" | tr -cd "[:digit:]-" ) ;;
				*.m4a) date=$( ffprobe -show_format -print_format flat "$sourceFile" 2>/dev/null | grep -iE '^format.tags.date' | cut -d '.' -f 3- | tr -cd "[:digit:]-" ) ;;
				*.wv) date=$( wvtag -x Year "$sourceFile" 2>/dev/null | tr -cd "[:digit:]-" ) ;;
				*.ape) date=$( APEv2 -z "$sourceFile" 2>/dev/null | grep -iF year= | tr -cd "[:digit:]-" ) ;;
				*.opus) date=$( opusinfo "$sourceFile" | grep -iF "date=" | tr -cd "[:digit:]-" ) ;;
			esac
			if [ ${#date} -eq 4 ]; then
				trackYear="$date"
				trackMonth="01"
				trackDay="01"
			elif [ ${#date} -eq 7 ]; then
				trackYear=$( echo "$date" | cut -d "-" -f 1 )
				trackMonth=$( echo "$date" | cut -d "-" -f 2 )
				trackDay="01"
			elif [ ${#date} -eq 10 ]; then
				trackYear=$( echo "$date" | cut -d "-" -f 1 )
				trackMonth=$( echo "$date" | cut -d "-" -f 2 )
				trackDay=$( echo "$date" | cut -d "-" -f 3 )
			else
				trackYear="$( date "+%Y" )"
				trackMonth="$( date "+%m" )"
				trackDay="$( date "+%d" )"
			fi

			echo "${trackYear}${trackMonth}${trackDay}" > "$sourceTagFile"

			saveSeconds; ec=$?
			;;

		*) continue ;;
	esac

	if [ $ec -eq $EX_OK ]; then
		printMessage 'success' 'touch_file' $p "dateTime:${trackYear}-${trackMonth}-${trackDay}" "file:${sourceFile}"
	else
		printMessage 'error' 'touch_file' $p "dateTime:${trackYear}-${trackMonth}-${trackDay}" "file:${sourceFile}"
	fi

	return $ec
}

computeTrackDateTimes ()
{
	local ec=$EX_OK


	for ((i=0; i < ${#sourceFiles[@]}; i++)); do
		sourceFile="${sourceFiles[$i]}"
		sourceFilename="${sourceFile##*/}"
		sourceTagFile="${TDIR}/${i}.txt"
		touchLockFile="${TDIR}/${i}"
		wasProcessedFile="${TDIR}/WAS_PROCESSED.${i}"
		secondsFile="${TDIR}/${i}.seconds"
		millisecondsFile="${TDIR}/${i}.milliseconds"

		if getLock "$touchLockFile"; then
			prepareSource &&
			computeTrackDateTime || ec=$EX_KO
			touch "$wasProcessedFile"
		fi
	done

	rm -f "${instanceDir}/process.${p}"
	return $ec
}

# FIXME handle multiple directories
touchAllFiles ()
{
	local ec=$EX_OK i a o
	local trackYear trackMonth trackDay trackDate totalSeconds trackMilliseconds albumHours
	local albumMinutes albumSeconds defaultTrackDate dir dirPath inode linkedFile linkPath touchString
	local audioFiles otherFiles audioFile sourceFile otherFile sourceTagFile secondsFile millisecondsFile

	trackYear="$( date "+%Y" )"
	trackMonth="$( date "+%m" )"
	trackDay="$( date "+%d" )"
	trackDate="${trackYear}${trackMonth}${trackDay}"
	defaultTrackDate="$trackDate"
	trackMilliseconds=0
	touchString="${trackDate}0000.00"
	totalSeconds=0

	dir="$( dirname "${sourceFiles[0]}" )"

	audioFiles=()
	otherFiles=()

	for ((i=0, a=0, o=0; i < ${#sourceFiles[@]}; i++)); do
		sourceFile="${sourceFiles[$i]}"
		case "$sourceFile" in
    	*.flac|*ogg|*.m4a|*.wv|*.ape|*.opus) audioFiles[$a]="$sourceFile" ; a=$(( a + 1 )) ;;
			*.wvc) continue ;; # will be touched when the matching .wv file is touched
			*.aiff|*.caf|*.mp3) continue ;; # unsupported audio files
			*) otherFiles[$o]="$sourceFile" ; o=$(( o + 1 )) ;; # all non-audio files
		esac
	done

	for audioFile in "${audioFiles[@]}"; do
		if [ $gotLinkedDir = true -a -z "$linkPath" ]; then
			inode="$( ls -i "$audioFile" 2>/dev/null | cut -d " " -f 1 2>/dev/null )"
			if [ -n "$inode" ]; then
				while read linkedFile; do
					if [ -z "$linkPath" ]; then
						linkPath="$( dirname "$linkedFile" )"
						break
					fi
				done < <( find "$linkDir" -inum "$inode" )
			fi
		else
			break
		fi
	done

	for ((i=0; i < ${#sourceFiles[@]}; i++)); do
		sourceFile="${sourceFiles[$i]}"
		sourceTagFile="${TDIR}/${i}.txt"
		secondsFile="${TDIR}/${i}.seconds"
		millisecondsFile="${TDIR}/${i}.milliseconds"

	  case "$sourceFile" in
    	*.flac|*ogg|*m4a|*.wv|*.ape|*.opus)
				read trackDate < "$sourceTagFile"
				if [ -z "$trackDate" ]; then trackDate="$defaultTrackDate"; fi
				read trackMilliseconds < "$millisecondsFile"
				if [ -z "$trackMilliseconds" ]; then trackMilliseconds=0; fi
				trackMilliseconds="$( printf "%.3f" "$trackMilliseconds" )"
				;;

			*.wvc) continue ;;

			*) continue ;;
		esac

		touchString="$( getTouchString $trackDate $totalSeconds )"
		touch -t "$touchString" "$sourceFile" || ec=$EX_IOERR
		if [ -e "${sourceFile}c" ]; then  # WavPack correction file
			touch -t "$touchString" "${sourceFile}c" || ec=$EX_IOERR
		fi
		if [ -e "$millisecondsFile" ]; then
			read trackMilliseconds < "$millisecondsFile"
		else
			trackMilliseconds=0
		fi
		totalSeconds="$( echo "scale=3; $totalSeconds + $trackMilliseconds" | bc )"
	done

	for otherFile in "${otherFiles[@]}"; do
		touchString="$( getTouchString $trackDate $totalSeconds )"
		touch -t "$touchString" "$otherFile" 2>> "$errorLogFile" || ec=$EX_IOERR
	done

	if [ ! -w "$dir" ]; then
		dirPath="$( readlink -f "$dir" )"
		printMessage 'warning' 'usage' 'filesystem' "path:${dirPath}" 'refusing to touch directory that is read-only.'
	else
		touchString="$( getTouchString $trackDate $totalSeconds )"
		touch -t "$touchString" "$dir" || ec=$EX_IOERR
	fi

	if [ -n "$linkPath" ]; then
		if [ ! -w "$linkPath" ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${linkPath}" 'refusing to touch directory that is read-only.'
		else
			touchString="$( getTouchString $trackDate $totalSeconds )"
			touch -t "$touchString" "$linkPath" || ec=$EX_IOERR
		fi
	fi

	if [ $ec -eq $EX_OK ]; then
		touchString="$( getTouchString $trackDate $totalSeconds )"
		albumHours="${touchString:8:2}"
		albumMinutes="${touchString:10:2}"
		albumSeconds="${touchString:13:2}"
		printMessage 'success' 'touch_files' "albumTime:${albumHours}:${albumMinutes}:${albumSeconds}"
	else
		printMessage 'error' 'touch_files' "Album length"
	fi

	return $ec
}

getCodecExtension ()
{
	local codec="$1" ext

	case "$codec" in
		WAV)           ext='wav' ;;
		AIFF)          ext='aiff' ;;
		CAF)           ext='caf' ;;
		FLAC)          ext='flac' ;;
		WavPack)       ext='wv' ;;
		WavPackHybrid) ext='wv' ;;
		MonkeysAudio)  ext='ape' ;;
		WavPackLossy)  ext='wv' ;;
		lossyWAV)      ext='lossy.wav' ;;
		lossyFLAC)     ext='lossy.flac' ;;
		lossyWV)       ext='lossy.wv' ;;
		OggVorbis)     ext='ogg' ;;
		MP3)           ext='mp3' ;;
		AAC)           ext='m4a' ;;
		Opus)          ext='opus' ;;
	esac

	echo "$ext"
}

getCodecFullName ()
{
	local codec="$1" codecFullName

	case "$codec" in
		WAV)           codecFullName='WAV' ;;
		AIFF)          codecFullName='AIFF' ;;
		CAF)           codecFullName='CAF' ;;
		FLAC)          codecFullName='FLAC' ;;
		WavPack)       codecFullName='WavPack' ;;
		WavPackHybrid) codecFullName='WavPack Hybrid' ;;
		MonkeysAudio)  codecFullName="Monkey's Audio" ;;
		WavPackLossy)  codecFullName='WavPack Lossy' ;;
		lossyWAV)      codecFullName='lossyWAV' ;;
		lossyFLAC)     codecFullName='lossyFLAC' ;;
		lossyWV)       codecFullName='lossyWV' ;;
		OggVorbis)     codecFullName='Ogg Vorbis' ;;
		MP3)           codecFullName='MP3' ;;
		AAC)           codecFullName='AAC' ;;
		Opus)          codecFullName='Opus' ;;
	esac

	echo "$codecFullName"
}

getFileProps ()
{
	local outputCodec="$2"

	sourceFile="$1"
	sourceFilename="${sourceFile##*/}"
	sourceDirname="$( dirname "$sourceFile" )"
	sourceBasename="${sourceFilename%.*}"
	if [ "$sourceBasename" != "${sourceBasename%.lossy}" ]; then
		sourceIsLossyWAV=true
	else
		sourceIsLossyWAV=false
	fi
	sourceBasename="${sourceBasename%.lossy}";
	sourceExtension="${sourceFilename##*.}"

	if [ -n "$outputCodec" ]; then
		destExtension="$( getCodecExtension "$outputCodec" )"
		outputCodecFullName="$( getCodecFullName "$outputCodec" )"
		destDir="$( getDestDir "$outputCodec" )"
		if [ "$outputCodec" = 'WAV' -a $sourceIsLossyWAV = true ]; then
			destExtension='lossy.wav'
		fi
		destFilename="${sourceBasename}.${destExtension}"

		sourceCoverArtFile=""
		coverArtFilename="$( getCodecCoverArtFile "$outputCodec" )"
		if [ -n "$coverArtFilename" ]; then
			sourceCoverArtFile="${sourceDirname}/${coverArtFilename}"
			if [ ! -e "$sourceCoverArtFile" ]; then
				sourceCoverArtFile=""
				# printMessage 'warning' 'usage' 'filesystem' "path:${coverArtFilename}" 'no such file.'
			elif [ ! -r "$sourceCoverArtFile" ]; then
				sourceCoverArtFile=""
				# printMessage 'warning' 'usage' 'filesystem' "path:${coverArtFilename}" 'cannot open file for reading (permission denied).'
			fi
		fi

		if [ $copyPath = true ]; then
			destPath="${destDir}/${sourceDirname#/}"
			destFile="${destPath}/${destFilename}"
			if [ -n "$linkDir" ]; then
				destLinkPath="${linkDir}/${sourceDirname#/}"
				destLinkFile="${destLinkPath}/${destFilename}"
			fi
		else
			destPath="$destDir"
			destFile="${destDir}/${destFilename}"
			if [ -n "$linkDir" ]; then
				destLinkPath="$linkDir"
				destLinkFile="${linkDir}/${destFilename}"
			fi
		fi
	fi
}

printMachineStats ()
{
	local f c sourceCoverArtBytes audio_bytes_compressed=0 destExtension dest bcmd seconds slist bytes_compressed duration='0' rate=''

	seconds="$( printf 'scale=6; %.6f - %.6f\n' "$time2" "$time1" | bc )"
	if [ "$seconds" = '0' ]; then seconds='1'; fi # prevent division by 0 situations
	if [ -f "${TDIR}/durations" ]; then
		duration="$( { echo -n 'scale=2; ' ; cat "${TDIR}/durations" ; echo ; } | bc )"
		if [ "$duration" != '0' ]; then
			duration="$( printf "%.0f" "$duration" )"
			rate="$( echo "scale=1; $duration / $seconds" | bc )"
		fi
	fi

	if [ -z "$outputCodecs" ]; then
		if [ -n "$rate" ]; then
			printMessage 'info' "${rate}x"
		fi
		return
	fi

	if [ -n "$rate" ]; then
		printMessage 'info' "${rate}x"
	fi

	if [ "$outputCodecs" = 'WAV' ]; then return; fi

	bcmd=''
	for outputCodec in $outputCodecs; do
		for sourceFile in "${sourceFiles[@]}"; do
			getFileProps "$sourceFile" "$outputCodec"
			if [ -e "$destFile" ]; then
				bcmd="${bcmd}\x00${destFile//%/%%}"
				if [ -e "${destFile}c" ]; then # WavPack correction file
					bcmd="${bcmd}\x00${destFile//%/%%}c"
				fi
			fi
		done
	done

	if [ "$OS" = 'Linux' ]; then
		bytes_compressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %s' | xargs -0 stat -L --printf; echo; } | bc )"
	else
		bytes_compressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %z' | xargs -0 stat -L -n -f; echo; } | bc )"
	fi

	for outputCodec in $outputCodecs; do
		bcmd=''
		for sourceFile in "${sourceFiles[@]}"; do
			getFileProps "$sourceFile" "$outputCodec"
			if [ -e "$destFile" ]; then
				bcmd="${bcmd}\x00${destFile//%/%%}"
				if [ -e "${destFile}c" ]; then # WavPack correction file
					bcmd="${bcmd}\x00${destFile//%/%%}c"
				fi
			fi
		done

		if [ "$OS" = 'Linux' ]; then
			bytes_compressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %s' | xargs -0 stat -L --printf; echo; } | bc )"
		else
			bytes_compressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %z' | xargs -0 stat -L -n -f; echo; } | bc )"
		fi


		if [ $duration -gt 0 ]; then
			bitrate_compressed="$( echo "scale=0; ($bytes_compressed * 8) / ${duration}" | bc )"
			printMessage 'info' "bitrate_${outputCodec}" "${bitrate_compressed}bps"
		fi
	done

	return $EX_OK
}

printHumanStats ()
{
	local f c sourceCoverArtBytes audio_bytes_compressed=0 destExtension dest bcmd seconds slist bytes_wav bytes_compressed imbsec ombsec mib_compressed ratio duration='0' rate='' readDuration

	seconds="$( printf 'scale=6; %.6f - %.6f\n' "$time2" "$time1" | bc )"
	if [ "$seconds" = '0' ]; then seconds='1'; fi # prevent division by 0 situations
	if [ -f "${TDIR}/durations" ]; then
		duration="$( { echo -n 'scale=2; ' ; cat "${TDIR}/durations" ; echo ; } | bc )"
		if [ "$duration" != '0' ]; then
			duration="$( printf "%.0f" "$duration" )"
			rate="$( echo "scale=1; $duration / $seconds" | bc )"
		fi
	fi
	printf "${GR} * ${NM}%.2f seconds" $seconds

	readDuration="$( { echo -n 'scale=6; ' ; cat "${TDIR}/readTimes" ; echo ; } | bc )"
	if [ "$readDuration" = '0' ]; then # prevent division by 0 situations
		if [ "$seconds" = '0' ]; then
			readDuration='1'
		else
			readDuration="$seconds"
		fi
	fi

	for f in "${sourceFiles[@]}"; do
		slist="${slist}\x00${f//%/%%}"
		if [ -e "${f}c" ]; then # WavPack correction file
			slist="${slist}\x00${f//%/%%}c"
		fi
	done

	if [ "$OS" = 'Linux' ]; then
		bytes_source="$( { echo -n 'scale=0; 0'; printf "%s${slist}" ' + %s' | xargs -0 stat -L --printf; echo; } | bc )"
	else
		bytes_source="$( { echo -n 'scale=0; 0'; printf "%s${slist}" ' + %z' | xargs -0 stat -L -n -f; echo; } | bc )"
	fi
	imbsec="$( echo "scale=3; $bytes_source / ($readDuration * 1000000)" | bc )"

	if [ -z "$outputCodecs" ]; then
		if [ -z "$rate" ]; then
			printf ' (read: %.1f MB/s)\n' "$imbsec"
		else
			printf ' (read: %.1f MB/s, rate: %sx)\n' "$imbsec" "$rate"
		fi
		return
	fi

	bcmd=''
	for outputCodec in $outputCodecs; do
		for sourceFile in "${sourceFiles[@]}"; do
			getFileProps "$sourceFile" "$outputCodec"
			if [ -e "$destFile" ]; then
				bcmd="${bcmd}\x00${destFile//%/%%}"
				if [ -e "${destFile}c" ]; then # WavPack correction file
					bcmd="${bcmd}\x00${destFile//%/%%}c"
				fi
			fi
		done
	done

	if [ "$OS" = 'Linux' ]; then
		bytes_compressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %s' | xargs -0 stat -L --printf; echo; } | bc )"
	else
		bytes_compressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %z' | xargs -0 stat -L -n -f; echo; } | bc )"
	fi
	ombsec="$( echo "scale=3; $bytes_compressed / ($seconds * 1000000)" | bc )"

	if [ -n "$rate" ]; then
		printf ' (read: %.1f MB/s, write: %.1f MB/s, rate: %sx)\n' "$imbsec" "$ombsec" "$rate"
	else
		printf ' (read: %.1f MB/s, write: %.1f MB/s)\n' "$imbsec" "$ombsec"
	fi

	if [ "$outputCodecs" = 'WAV' ]; then return; fi

	bytes_wav="$( { echo -n 'scale=0; 0' ; cat "${TDIR}/bytes" ; echo ; } | bc )"
	mib_source="$( echo "scale=3; $bytes_source / 1048576" | bc )"
	mib_uncompressed="$( echo "scale=3; $bytes_wav / 1048576" | bc )"
	ratio="$( echo "scale=3; $bytes_source * 100 / $bytes_wav" | bc )"

	if [ $duration -gt 0 ]; then
		bitrate_source="$( echo "scale=0; (${bytes_source} * 8) / ${duration} / 1000" | bc )"
	else
		bitrate_source='?'
	fi

	# each item is separated by 4 spaces
	printf '\n%-15s    %6.1f MiB    %5.1f%%' 'WAV:' "$mib_uncompressed" '100'
	printf '\n%-15s    %6.1f MiB    %5.1f%%    %4s kbps\n' 'Source:' "$mib_source" "$ratio" "$bitrate_source"

	for outputCodec in $outputCodecs; do
		bcmd=''
		for sourceFile in "${sourceFiles[@]}"; do
			getFileProps "$sourceFile" "$outputCodec"
			if [ -e "$destFile" ]; then
				bcmd="${bcmd}\x00${destFile//%/%%}"
				if [ -e "${destFile}c" ]; then # WavPack correction file
					bcmd="${bcmd}\x00${destFile//%/%%}c"
				fi
			fi
		done

		if [ "$OS" = 'Linux' ]; then
			bytes_compressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %s' | xargs -0 stat -L --printf; echo; } | bc )"
		else
			bytes_compressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %z' | xargs -0 stat -L -n -f; echo; } | bc )"
		fi

		if [ $duration -gt 0 ]; then
			bitrate_compressed="$( echo "scale=0; (${bytes_compressed} * 8) / ${duration} / 1000" | bc )"
		else
			bitrate_compressed='?'
		fi

		mib_compressed="$( echo "scale=3; $bytes_compressed / 1048576" | bc )"
		ratio="$( echo "scale=3; $bytes_compressed * 100 / $bytes_wav" | bc )"

		# each item is separated by 4 spaces
		printf '%-15s    %6.1f MiB    %5.1f%%    %4s kbps\n' "${outputCodecFullName}:"	$mib_compressed "$ratio" "$bitrate_compressed"
	done

	return $EX_OK
}

setDestDir ()
{
	local outputCodec="$1" codecDestDir="$2" listOfCodecs codec

	if [ -z "$outputCodec" ]; then
		read -a listOfCodecs <<< "$allCodecsString"
	else
		read -a listOfCodecs <<< "$outputCodec"
	fi

	for codec in "${listOfCodecs[@]}"; do
		case "$codec" in
			WAV) dir_WAV="$codecDestDir" ;;
			AIFF) dir_AIFF="$codecDestDir" ;;
			CAF) dir_CAF="$codecDestDir" ;;
			FLAC) dir_FLAC="$codecDestDir" ;;
			WavPack) dir_WavPack="$codecDestDir" ;;
			WavPackHybrid) dir_WavPackHybrid="$codecDestDir" ;;

			WavPackLossy) dir_WavPackLossy="$codecDestDir" ;;
			MonkeysAudio) dir_MonkeysAudio="$codecDestDir" ;;
			lossyWAV) dir_lossyWAV="$codecDestDir" ;;
			lossyFLAC) dir_lossyFLAC="$codecDestDir" ;;
			lossyWV) dir_lossyWV="$codecDestDir" ;;
			MP3) dir_MP3="$codecDestDir" ;;
			AAC) dir_AAC="$codecDestDir" ;;
			OggVorbis) dir_OggVorbis="$codecDestDir" ;;
			Opus) dir_Opus="$codecDestDir" ;;
			*) codecDestDir="$defaultDestDir" ;;
		esac
	done
}

getDestDir ()
{
	local outputCodec="$1" codecDestDir=""

	case "$outputCodec" in
		WAV) codecDestDir="$dir_WAV" ;;
		AIFF) codecDestDir="$dir_AIFF" ;;
		CAF) codecDestDir="$dir_CAF" ;;
		FLAC) codecDestDir="$dir_FLAC" ;;
		WavPack) codecDestDir="$dir_WavPack" ;;
		WavPackHybrid) codecDestDir="$dir_WavPackHybrid" ;;
		MonkeysAudio) codecDestDir="$dir_MonkeysAudio" ;;

		WavPackLossy) codecDestDir="$dir_WavPackLossy" ;;
		lossyWAV) codecDestDir="$dir_lossyWAV" ;;
		lossyFLAC) codecDestDir="$dir_lossyFLAC" ;;
		lossyWV) codecDestDir="$dir_lossyWV" ;;
		MP3) codecDestDir="$dir_MP3" ;;
		AAC) codecDestDir="$dir_AAC" ;;
		OggVorbis) codecDestDir="$dir_OggVorbis" ;;
		Opus) codecDestDir="$dir_Opus" ;;
		*) codecDestDir="$defaultDestDir" ;;
	esac

	if [ -n "$codecDestDir" ]; then
		echo "$codecDestDir"
	else
		echo "$defaultDestDir"
	fi

}

setCodecOtherFiles ()
{
	local outputCodec="$1" pattern="$2" listOfCodecs codec

	case "$outputCodec" in
		default) read -a listOfCodecs <<< "$allCodecsString" ;;
		lossless) read -a listOfCodecs <<< "$losslessCodecsString" ;;
		lossy) read -a listOfCodecs <<< "$lossyCodecsString" ;;
		*) read -a listOfCodecs <<< "$outputCodec" ;;
	esac

	for codec in "${listOfCodecs[@]}"; do
		case "$codec" in
			WAV) copyOtherFiles_WAV="$pattern" ;;
			AIFF) copyOtherFiles_AIFF="$pattern" ;;
			CAF) copyOtherFiles_CAF="$pattern" ;;
			FLAC) copyOtherFiles_FLAC="$pattern" ;;
			WavPack) copyOtherFiles_WavPack="$pattern" ;;
			WavPackHybrid) copyOtherFiles_WavPackHybrid="$pattern" ;;
			MonkeysAudio) copyOtherFiles_MonkeysAudio="$pattern" ;;

			WavPackLossy) copyOtherFiles_WavPackLossy="$pattern" ;;
			lossyWAV) copyOtherFiles_lossyWAV="$pattern" ;;
			lossyFLAC) copyOtherFiles_lossyFLAC="$pattern" ;;
			lossyWV) copyOtherFiles_lossyWV="$pattern" ;;
			MP3) copyOtherFiles_MP3="$pattern" ;;
			AAC) copyOtherFiles_AAC="$pattern" ;;
			OggVorbis) copyOtherFiles_OggVorbis="$pattern" ;;
			Opus) copyOtherFiles_Opus="$pattern" ;;
		esac
	done
}

getCodecOtherFiles ()
{
	local outputCodec="$1" otherFilesPattern=""

	case "$outputCodec" in
		WAV) otherFilesPattern="$copyOtherFiles_WAV" ;;
		AIFF) otherFilesPattern="$copyOtherFiles_AIFF" ;;
		CAF) otherFilesPattern="$copyOtherFiles_CAF" ;;
		FLAC) otherFilesPattern="$copyOtherFiles_FLAC" ;;
		WavPack) otherFilesPattern="$copyOtherFiles_WavPack" ;;
		WavPackHybrid) otherFilesPattern="$copyOtherFiles_WavPackHybrid" ;;
		MonkeysAudio) otherFilesPattern="$copyOtherFiles_MonkeysAudio" ;;

		WavPackLossy) otherFilesPattern="$copyOtherFiles_WavPackLossy" ;;
		lossyWAV) otherFilesPattern="$copyOtherFiles_lossyWAV" ;;
		lossyFLAC) otherFilesPattern="$copyOtherFiles_lossyFLAC" ;;
		lossyWV) otherFilesPattern="$copyOtherFiles_lossyWV" ;;
		MP3) otherFilesPattern="$copyOtherFiles_MP3" ;;
		AAC) otherFilesPattern="$copyOtherFiles_AAC" ;;
		OggVorbis) otherFilesPattern="$copyOtherFiles_OggVorbis" ;;
		Opus) otherFilesPattern="$copyOtherFiles_Opus" ;;
	esac

	echo "$otherFilesPattern"
}

setCodecCoverArtFile ()
{
	local outputCodec="$1" coverArtFile="$2" listOfCodecs codec

	case "$outputCodec" in
		default) read -a listOfCodecs <<< "$allCodecsString" ;;
		lossless) read -a listOfCodecs <<< "$losslessCodecsString" ;;
		lossy) read -a listOfCodecs <<< "$lossyCodecsString" ;;
		*) read -a listOfCodecs <<< "$outputCodec" ;;
	esac

	for codec in "${listOfCodecs[@]}"; do
		case "$codec" in
			WAV) coverArtFile_WAV="$coverArtFile" ;;
			AIFF) coverArtFile_AIFF="$coverArtFile" ;;
			CAF) coverArtFile_CAF="$coverArtFile" ;;
			FLAC) coverArtFile_FLAC="$coverArtFile" ;;
			WavPack) coverArtFile_WavPack="$coverArtFile" ;;
			WavPackHybrid) coverArtFile_WavPackHybrid="$coverArtFile" ;;
			MonkeysAudio) coverArtFile_MonkeysAudio="$coverArtFile" ;;

			WavPackLossy) coverArtFile_WavPackLossy="$coverArtFile" ;;
			lossyWAV) coverArtFile_lossyWAV="$coverArtFile" ;;
			lossyFLAC) coverArtFile_lossyFLAC="$coverArtFile" ;;
			lossyWV) coverArtFile_lossyWV="$coverArtFile" ;;
			MP3) coverArtFile_MP3="$coverArtFile" ;;
			AAC) coverArtFile_AAC="$coverArtFile" ;;
			OggVorbis) coverArtFile_OggVorbis="$coverArtFile" ;;
			Opus) coverArtFile_Opus="$coverArtFile" ;;
		esac
	done
}

getCodecCoverArtFile ()
{
	local outputCodec="$1" coverArtFile=""

	case "$outputCodec" in
		WAV) coverArtFile="$coverArtFile_WAV" ;;
		AIFF) coverArtFile="$coverArtFile_AIFF" ;;
		CAF) coverArtFile="$coverArtFile_CAF" ;;
		FLAC) coverArtFile="$coverArtFile_FLAC" ;;
		WavPack) coverArtFile="$coverArtFile_WavPack" ;;
		WavPackHybrid) coverArtFile="$coverArtFile_WavPackHybrid" ;;
		MonkeysAudio) coverArtFile="$coverArtFile_MonkeysAudio" ;;

		WavPackLossy) coverArtFile="$coverArtFile_WavPackLossy" ;;
		lossyWAV) coverArtFile="$coverArtFile_lossyWAV" ;;
		lossyFLAC) coverArtFile="$coverArtFile_lossyFLAC" ;;
		lossyWV) coverArtFile="$coverArtFile_lossyWV" ;;
		MP3) coverArtFile="$coverArtFile_MP3" ;;
		AAC) coverArtFile="$coverArtFile_AAC" ;;
		OggVorbis) coverArtFile="$coverArtFile_OggVorbis" ;;
		Opus) coverArtFile="$coverArtFile_Opus" ;;
	esac

	echo "$coverArtFile"
}

getNumberOfCpuCores ()
{
	local x lastCpuID currentCpuID totalNumberOfCores=0

	while read line; do
		x="$( echo "$line" | tr -cd '0-9' 2>/dev/null )"
		case "$line" in
			'physical id'*)
				lastCpuID="$currentCpuID"
				currentCpuID="$x"
				;;

			'cpu cores'*)
				if [ "$currentCpuID" != "$lastCpuID" ]; then
					totalNumberOfCores=$(( totalNumberOfCores + x ))
				fi
				;;
		esac
	done < <( grep -E '^(physical id|cpu cores)' '/proc/cpuinfo' 2>/dev/null )

	echo $totalNumberOfCores
}

# main() =======================================================================

if [ -n "$LC_ALL" ]; then
#	export LANG="$LC_ALL"
	unset LC_ALL
fi
export LANG='en_US.UTF-8'
export LC_NUMERIC='C'


sedcmd='gsed' datecmd='date' gnudate=false
if which 'uname' >/dev/null 2>&1 ; then
	OS="$( uname -s )"
	if [ "$OS" = 'Linux' ]; then
		sedcmd='sed' gnudate=true
	elif which 'gdate' >/dev/null 2>&1; then
		datecmd='gdate' gnudate=true
	fi
fi

checkBinaries

maxProcesses=''
if which 'nproc' >/dev/null 2>&1; then # GNU Coreutils installed
	maxProcesses="$( nproc 2>/dev/null )"
elif which 'gnproc' >/dev/null 2>&1; then # GNU Coreutils installed on macOS
	maxProcesses="$( gnproc 2>/dev/null )"
elif [ -e '/proc/cpuinfo' ]; then # Linux
	maxProcesses="$( grep -cF 'cpu MHz' /proc/cpuinfo 2>/dev/null )"
elif [ "$OS" = 'Darwin' ]; then # macOS
	# Many thanks to Tobias Link for helping me port caudec to macOS
	maxProcesses="$( system_profiler -detailLevel full SPHardwareDataType 2>/dev/null | grep -F 'Total Number of Cores:' 2>/dev/null | cut -d ':' -f 2 2>/dev/null | tr -d ' ' | cut -d '(' -f 1 2>/dev/null )"
fi

nProcesses=1
case "$maxProcesses" in
	[1-9]*) nProcesses=$maxProcesses ;;
esac
maxProcessesSetByUser=$nProcesses

losslessCodecsString="WAV AIFF CAF FLAC WavPack WavPackHybrid MonkeysAudio"
lossyCodecsString="WavPackLossy lossyWAV lossyFLAC lossyWV MP3 AAC OggVorbis Opus"
allCodecsString="${losslessCodecsString} ${lossyCodecsString}"

# Set default values
outputCodecs='' lastCodec='' nCodecs=0 copyWAV=false verbose=true
defaultDestDir="$PWD" linkDir='' gotLinkedDir=false copyPath=false
nLossyWAV=0 copyLossyWAV=false
bitDepth='' samplingRate='' preserveMetadata='' computeReplaygain=false
applyGain=false applyGainType='' convertToStereo='false'
keepExistingFiles=false keepNewerFiles=false macHasVerify=false outputMode='human'
checkFiles=false actionHash=false touchFiles=false peakReference=0 allFilesAreOpus=true
setCoverArtworkFile=false

if [ "$calledAs" = 'decaude' ]; then
	lastCodec='WAV'
	outputCodecs="$outputCodecs $lastCodec"
	((nCodecs++))
	copyWAV=true
fi

if [ -n "$hashes" ]; then
	hashes="$( echo -n "$hashes" | tr '[:lower:]' '[:upper:]' )"
fi

getCompressionSetting 'FLAC' "$compression_FLAC" 'caudecrc'
getCompressionSetting 'WavPack' "$compression_WavPack" 'caudecrc'
getCompressionSetting 'MonkeysAudio' "$compression_MonkeysAudio" 'caudecrc'
getCompressionSetting 'lossyWAV' "$compression_lossyWAV" 'caudecrc'
getCompressionSetting 'MP3' "$compression_MP3" 'caudecrc'
getCompressionSetting 'OggVorbis' "$compression_OggVorbis" 'caudecrc'
getCompressionSetting 'Opus' "$compression_Opus" 'caudecrc'

getConstantBitrate 'WavPackLossy' "$bitrate_WavPackLossy" 'caudecrc'
getConstantBitrate 'MP3' "$bitrate_MP3" 'caudecrc'
getConstantBitrate 'OggVorbis' "$bitrate_OggVorbis" 'caudecrc'
getConstantBitrate 'Opus' "$bitrate_Opus" 'caudecrc'

getAverageBitrate 'MP3' "$average_bitrate_MP3" 'caudecrc'
getAverageBitrate 'AAC' "$average_bitrate_AAC" 'caudecrc'
getAverageBitrate 'OggVorbis' "$average_bitrate_OggVorbis" 'caudecrc'
getAverageBitrate 'Opus' "$average_bitrate_Opus" 'caudecrc'

getBitrateMode 'MP3' "$MP3_MODE" 'caudecrc'
getBitrateMode 'AAC' "$AAC_MODE" 'caudecrc'
getBitrateMode 'OggVorbis' "$OggVorbis_MODE" 'caudecrc'
getBitrateMode 'Opus' "$Opus_MODE" 'caudecrc'

if which 'mac' >/dev/null 2>&1; then
	if mac 2>&1 | grep -F 'Verify:' >/dev/null 2>&1; then # mac has the patch that adds the -v parameter
		macHasVerify=true
	fi
fi

if [ -n "$setCoverArtworkFileByDefault" ]; then
	setCodecCoverArtFile "default" "$setCoverArtworkFileByDefault"
fi
if [ -n "$setCoverArtworkFileForLosslessByDefault" ]; then
	setCodecCoverArtFile "lossless" "$setCoverArtworkFileForLosslessByDefault"
fi
if [ -n "$setCoverArtworkFileForLossyByDefault" ]; then
	setCodecCoverArtFile "lossy" "$setCoverArtworkFileForLossyByDefault"
fi

if [ -n "$copyOtherFilesByDefault" ]; then
	setCodecOtherFiles "default" "$copyOtherFilesByDefault"
	copyOtherFiles=true
fi
if [ -n "$copyOtherFilesForLosslessByDefault" ]; then
	setCodecOtherFiles "lossless" "$copyOtherFilesForLosslessByDefault"
	copyOtherFiles=true
fi
if [ -n "$copyOtherFilesForLossyByDefault" ]; then
	setCodecOtherFiles "lossy" "$copyOtherFilesForLossyByDefault"
	copyOtherFiles=true
else
	setCodecOtherFiles "default" ""
	copyOtherFiles=false
fi

while getopts 'zsn:o:O:P:l:L:a:f:kKtTdc:C:H:q:b:B:r:2gG:S:huV' o ; do
	case $o in
		s) verbose=false ;;

		n)
			case "$OPTARG" in
				[0-9]|[0-9][0-9])
					if [ $OPTARG -le $maxProcesses ]; then
						nProcesses=$OPTARG
						maxProcessesSetByUser=$OPTARG
					else
						printMessage 'error' 'usage' 'bad_value' "$me -n: the number of processes must be an integer between 1 and $maxProcesses" ; exit $EX_USAGE
					fi
					;;

				*) printMessage 'error' 'usage' 'bad_value' "$me -n: the number of processes must be an integer between 1 and $maxProcesses" ; exit $EX_USAGE ;;
			esac
			;;

		a)
			setArtworkFilename="$OPTARG"
			case "$OPTARG" in
				*.jpg|*.jpeg|*.png)
					if [ -z "$lastCodec" ]; then
						setCodecCoverArtFile "default" "$OPTARG"
					elif [ -n "$lastCodec" ]; then
						setCodecCoverArtFile "$lastCodec" "$OPTARG"
					fi
				;;

				*) printMessage 'error' 'usage' 'bad_value' "$me -a: the argument must be a JPEG or PNG file" ; exit $EX_USAGE ;;
			esac
			;;

		f)
			copyOtherFiles=true
			if [ -z "$lastCodec" ]; then
				setCodecOtherFiles "default" "$OPTARG"
			elif [ -n "$lastCodec" ]; then
				if [ "$lastCodec" = "WavPackHybrid" ]; then
					if [ $gotLinkedDir = true ]; then
						setCodecOtherFiles "WavPackLossy" "$OPTARG"
					else
						setCodecOtherFiles "WavPackHybrid" "$OPTARG"
					fi
				else
					setCodecOtherFiles "$lastCodec" "$OPTARG"
				fi
			fi
			;;

		o)
			lastCodecDestDir="$OPTARG"
			if [ "$lastCodecDestDir" != '/' -a "${lastCodecDestDir%/}" != "$lastCodecDestDir" ]; then
				lastCodecDestDir="${lastCodecDestDir%/}"
			fi
			if [ ! -e "$lastCodecDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${lastCodecDestDir}" "$me -o: directory doesn't exist. Either create it manually, or try again with -O." ; exit $EX_CANTCREAT
			elif [ ! -d "$lastCodecDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${lastCodecDestDir}" "$me -o: not a directory." ; exit $EX_CANTCREAT
			elif [ ! -w "$lastCodecDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${lastCodecDestDir}" "$me -o: directory is not writable (permission denied)." ; exit $EX_CANTCREAT
			fi
			setDestDir "$lastCodec" "$lastCodecDestDir"
			;;

		# from an original idea by Porcus on https://hydrogenaudio.org/index.php/topic,127856.msg1062957.html#msg1062957
		l)
			if [ "$lastCodec" != "WavPackHybrid" -a $touchFiles = false ]; then
				printMessage 'error' 'usage' 'command_line' "$me -l: it must be preceded by -c wvh or -T." ; exit $EX_USAGE
			fi
			gotLinkedDir=false
			linkDir="$OPTARG"
			if [ "$linkDir" != '/' -a "${linkDir%/}" != "$linkDir" ]; then
				linkDir="${linkDir%/}"
			fi
			if [ ! -e "$linkDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${linkDir}" "$me -l: directory doesn't exist. Either create it manually, or try again with -L." ; exit $EX_CANTCREAT
			elif [ ! -d "$linkDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${linkDir}" "$me -l: not a directory." ; exit $EX_CANTCREAT
			elif [ ! -w "$linkDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${linkDir}" "$me -l: directory is not writable (permission denied)." ; exit $EX_CANTCREAT
			fi
			gotLinkedDir=true
			copyPath=true # for obtaining the same behavior as -P
			;;

		# from an original idea by Porcus on https://hydrogenaudio.org/index.php/topic,127856.msg1062957.html#msg1062957
		L)
			if [ "$lastCodec" != "WavPackHybrid" -a $touchFiles = false ]; then
				printMessage 'error' 'usage' 'command_line' "$me -L: it must be preceded by -c wvh or -T." ; exit $EX_USAGE
			fi
			gotLinkedDir=false
			linkDir="$OPTARG"
			if [ "$linkDir" != '/' -a "${linkDir%/}" != "$linkDir" ]; then
				linkDir="${linkDir%/}"
			fi
			if [ ! -e "$linkDir" ]; then
				if ! mkdir -p "$linkDir" >/dev/null 2>&1 ; then
					printMessage 'error' 'usage' 'filesystem' "path:${linkDir}" "$me -L: failed to create directory (do you have write permissions?)." ; exit $EX_CANTCREAT
				fi
			elif [ ! -d "$linkDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${linkDir}" "$me -L: not a directory." ; exit $EX_CANTCREAT
			elif [ ! -w "$linkDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${linkDir}" "$me -L: directory is not writable (permission denied)." ; exit $EX_CANTCREAT
			fi
			gotLinkedDir=true
			copyPath=true # for the same behavior as -P
			;;

		O|P)
			lastCodecDestDir="$OPTARG"
			if [ "$lastCodecDestDir" != '/' -a "${lastCodecDestDir%/}" != "$lastCodecDestDir" ]; then
				lastCodecDestDir="${lastCodecDestDir%/}"
			fi
			if [ ! -e "$lastCodecDestDir" ]; then
				if ! mkdir -p "$lastCodecDestDir" >/dev/null 2>&1 ; then
					printMessage 'error' 'usage' 'filesystem' "path:${lastCodecDestDir}" "$me -O/P: failed to create directory (do you have write permissions?)." ; exit $EX_CANTCREAT
				fi
			elif [ ! -d "$lastCodecDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${lastCodecDestDir}" "$me -O/P: not a directory." ; exit $EX_CANTCREAT
			elif [ ! -w "$lastCodecDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${lastCodecDestDir}" "$me -O/P: directory is not writable (permission denied)." ; exit $EX_CANTCREAT
			fi
			if [ "$o" = 'P' ]; then copyPath=true; fi
			setDestDir "$lastCodec" "$lastCodecDestDir"
			;;

		k)
			keepExistingFiles=true
			if [ $keepNewerFiles = true ]; then
				printMessage 'error' 'usage' 'command_line' "$me -k: parameters -k and -K are mutually exclusive. Choose one or the other." ; exit $EX_USAGE
			fi
			;;

		K)
			keepNewerFiles=true
			if [ $keepExistingFiles = true ]; then
				printMessage 'error' 'usage' 'command_line' "$me -K: parameters -k and -K are mutually exclusive. Choose one or the other." ; exit $EX_USAGE
			fi
			;;

		t) checkFiles=true copyOtherFiles=false ;;

		T) touchFiles=true copyOtherFiles=false ;;

		c|C)
			case "$OPTARG" in
				wav)                 lastCodec='WAV' copyWAV=true ;;
				aiff)                lastCodec='AIFF' ;;
				caf)                 lastCodec='CAF' ;;
				flac)                lastCodec='FLAC' ;;
				wv)                  lastCodec='WavPack' ;;
				wvh)                 lastCodec='WavPackHybrid' ;;
				wvl)                 lastCodec='WavPackLossy' ;;
				ape)                 lastCodec='MonkeysAudio' ;;
				lossyWAV|lossywav)   lastCodec='lossyWAV'; ((nLossyWAV++)) ; copyLossyWAV=true ;;
				lossyFLAC|lossyflac) lastCodec='lossyFLAC'; ((nLossyWAV++)) ;;
				lossyWV|lossywv)     lastCodec='lossyWV'; ((nLossyWAV++)) ;;
				mp3)                 lastCodec='MP3' ;;
				aac)                 lastCodec='AAC' ;;
				ogg|vorbis)          lastCodec='OggVorbis' ;;
				opus)                lastCodec='Opus' ;;
				*) printMessage 'error' 'usage' 'bad_value' "$me -c: invalid codec (try $me -h)" ; exit $EX_USAGE ;;
			esac
			outputCodecs="$outputCodecs $lastCodec"; ((nCodecs++))
			if [ "$o" = 'c' ]; then
				preserveMetadata="${preserveMetadata}x${lastCodec}Y"
			fi
			;;

		d) lastCodec='WAV'; outputCodecs="$outputCodecs $lastCodec"; ((nCodecs++)); copyWAV=true ;;

		H)
			copyOtherFiles=false
			case "$OPTARG" in
				crc32|CRC32)   hashes="${hashes}CRC32 "  ;;
				md5|MD5)   hashes="${hashes}MD5 "  ;;
				sha1|SHA1) hashes="${hashes}SHA1 " ;;
				sha256|SHA256) hashes="${hashes}SHA256 " ;;
				sha512|SHA512) hashes="${hashes}SHA512 " ;;
				^crc32|^CRC32)   hashes="${hashes//CRC32/}"  ;;
				^md5|^MD5)   hashes="${hashes//MD5/}"  ;;
				^sha1|^SHA1) hashes="${hashes//SHA1/}" ;;
				^sha256|^SHA256) hashes="${hashes//SHA256/}" ;;
				^sha512|^SHA512) hashes="${hashes//SHA512/}" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$me -H: hash algorithm must be one of CRC32, MD5, SHA1, SHA256 or SHA512" ; exit $EX_USAGE ;;
			esac
			actionHash=true
			;;

		q)
			if [ -z "$lastCodec" ]; then
				printMessage 'error' 'usage' 'command_line' "$me -q: you must specify a codec first (-c)" ; exit $EX_USAGE
			fi

			case "$lastCodec" in
				FLAC) getCompressionSetting 'FLAC' "$OPTARG" ;;
				WavPack|WavPackHybrid) getCompressionSetting 'WavPack' "$OPTARG" ;;
				WavPackLossy) getCompressionSetting 'WavPackLossy' "$OPTARG" ;;
				MonkeysAudio) getCompressionSetting 'MonkeysAudio' "$OPTARG" ;;
				lossyWAV|lossyFLAC|lossyWV) getCompressionSetting 'lossyWAV' "$OPTARG" ;;
				MP3) getCompressionSetting 'MP3' "$OPTARG" ; MP3_MODE='VBR' ;;
				OggVorbis) getCompressionSetting 'OggVorbis' "$OPTARG" ; OggVorbis_MODE='VBR' ;;
				Opus) getCompressionSetting 'Opus' "$OPTARG" ; Opus_MODE='VBR' ;;
				*) printMessage 'error' 'usage' 'command_line' "$me -q: parameter not available with the selected codec" ; exit $EX_USAGE ;;
			esac ;;

		b)
			if [ -z "$lastCodec" ]; then
				case "$OPTARG" in
					16|24) bitDepth=$OPTARG ;;
					*) printMessage 'error' 'usage' 'bad_value' "$me -b: bit depth must be either 16 or 24" ; exit $EX_USAGE
				esac
			else
				case "$lastCodec" in
					WavPackHybrid|WavPackLossy) getConstantBitrate 'WavPackLossy' "$OPTARG" ;;
					Opus) getConstantBitrate 'Opus' "$OPTARG" ; Opus_MODE='CBR' ;;
					MP3) getConstantBitrate 'MP3' "$OPTARG" ; MP3_MODE='CBR' ;;
					OggVorbis) getConstantBitrate 'OggVorbis' "$OPTARG" ; OggVorbis_MODE='CBR' ;;
					*) printMessage 'error' 'usage' 'command_line' "$me -b: parameter not available with the selected codec" ; exit $EX_USAGE ;;
				esac
			fi
			;;

		B)
			if [ -z "$lastCodec" ]; then
				printMessage 'error' 'usage' 'command_line' "$me -B: you must select a codec first (-c)" ; exit $EX_USAGE
			fi
			case "$lastCodec" in
				MP3) getAverageBitrate 'MP3' "$OPTARG" ; MP3_MODE='ABR' ;;
				AAC) getAverageBitrate 'AAC' "$OPTARG" ; AAC_MODE='ABR' ;;
				OggVorbis) getAverageBitrate 'OggVorbis' "$OPTARG" ; OggVorbis_MODE='ABR' ;;
				Opus) getAverageBitrate 'Opus' "$OPTARG" ; Opus_MODE='ABR' ;;
				*) printMessage 'error' 'usage' 'command_line' "$me -B: parameter not available with the selected codec" ; exit $EX_USAGE ;;
			esac
			;;

		r)
			if [ -n "$lastCodec" -a "$calledAs" != 'decaude' ]; then
				printMessage 'error' 'usage' 'command_line' "$me -r: parameter must be given before -c" ; exit $EX_USAGE
			fi
			case "$OPTARG" in
				44|44.1) samplingRate=44100 ;;
				88|88.2) samplingRate=88200 ;;
				176|176.4) samplingRate=176400 ;;
				352|352.8) samplingRate=352800 ;;
				48|96|192|384) samplingRate="${OPTARG}000" ;;
				44100|48000|88200|96000|176400|192000|352800|384000) samplingRate=$OPTARG ;;
				cd|CD) bitDepth=16 samplingRate=44100 convertToStereo='flat' ;;
				dvd|DVD) bitDepth=16 samplingRate=48000 ;;
				sacd|SACD) bitDepth=24 samplingRate=88200 ;;
				dvda|DVDA|dvdaudio|DVDAUDIO|DVDAudio|bd|BD|bluray|BLURAY|BluRay) bitDepth=24 samplingRate=96000 ;;
				pono|Pono|PONO) bitDepth=24 samplingRate=192000 ;;
				dxd|DXD) bitDepth=24 samplingRate=352800 ;;
				*) printMessage 'error' 'usage' 'bad_value' "$me -r: sampling rate must be one of 44[100], 48[000], 88[200], 96[000], 176[400], 192[000], 352[800], 384[000], cd, dvd, sacd, dvda, bluray, pono or dxd" ; exit $EX_USAGE
			esac
			;;

		2) convertToStereo='flat' ;;

		g) computeReplaygain=true copyOtherFiles=false ;;

		G)
			copyOtherFiles=false
			if [ -z "$lastCodec" ]; then
				computeReplaygain=true
			fi
			case "$OPTARG" in
				album) gainValue='ALBUM' ;;
				track) gainValue='TRACK' ;;
				albumpeak) gainValue='ALBUM_PEAK' ;;
				trackpeak) gainValue='TRACK_PEAK' ;;
				+[0-9]|+[1-9][0-9]) gainValue="${OPTARG}.00" ;; # integer
				+[0-9].[0-9]|+[1-9][0-9].[0-9]) gainValue="${OPTARG}0" ;; # floating point, 1 decimal
				+[0-9].[0-9][0-9]|+[1-9][0-9].[0-9][0-9]) gainValue="$OPTARG" ;; # floating point, 2 decimals
				-[0-9]|-[1-9][0-9]) gainValue="${OPTARG}.00" ;; # integer
				-[0-9].[0-9]|-[1-9][0-9].[0-9]) gainValue="${OPTARG}0" ;; # floating point, 1 decimal
				-[0-9].[0-9][0-9]|-[1-9][0-9].[0-9][0-9]) gainValue="$OPTARG" ;; # floating point, 2 decimals
				*) printMessage 'error' 'usage' 'bad_value' "$me -G: gain type must be either album or track, albumpeak or trackpeak, or a signed number between -99.99 and +99.99" ; exit $EX_USAGE
			esac
			if [ $applyGain = true ]; then
				case "$applyGainType" in
					ALBUM|TRACK)
						preamp="$gainValue"
						;;

					ALBUM_PEAK|TRACK_PEAK)
						if [ "${gainValue:0:1}" = '-' ]; then
							peakReference="$gainValue"
						fi
						;;
				esac
			else
				applyGainType="$gainValue"
			fi
			applyGain=true
			if [ "${gainValue:1}" = '0.00' ]; then
				printMessage 'error' 'usage' 'bad_value' "$me -G: gain value must not be equal to 0" ; exit $EX_USAGE
			fi
			unset gainValue
			;;

		h) printUsage; exit $EX_OK ;;

		V) echo "$me $VERSION"; exit $EX_OK ;;

		z) outputMode='machine' ;;

		*) printMessage 'error' 'usage' 'command_line' "Try '$me -h' for more information." ; exit $EX_USAGE ;;
	esac
done

shift $(( OPTIND - 1 ))
if [ $# -lt 1 ]; then
	if [ "$outputMode" = 'machine' ]; then
		printMachineSyntax
		exit $EX_OK
	else
		printUsage 1>&2
		exit $EX_USAGE
	fi
fi

outputCodecs="${outputCodecs# }"
if [ -z "$outputCodecs" ]; then
	gotPCMCodecsOnly=false
else
	gotPCMCodecsOnly=true
	for outputCodec in $outputCodecs; do
		case "$outputCodec" in
			WAV|AIFF|CAF) continue ;;
			*) gotPCMCodecsOnly=false ; break ;;
		esac
	done
fi
if [ $gotPCMCodecsOnly = true ]; then
	hashes=''
else
	hashCRC32=false hashMD5=false hashSHA1=false hashSHA256=false hashSHA512=false
	hashes="${hashes//  / }"
	if [ "${hashes:0:1}" = ' ' ]; then hashes="${hashes:1}"; fi
	hashes="${hashes% }"
	newHashes=''
	for h in $hashes; do
		case "$h" in
			CRC32) if [ $hashCRC32 = false ]; then newHashes="${newHashes}${h} "; hashCRC32=true; fi ;;
			MD5) if [ $hashMD5 = false ]; then newHashes="${newHashes}${h} "; hashMD5=true; fi ;;
			SHA1) if [ $hashSHA1 = false ]; then newHashes="${newHashes}${h} "; hashSHA1=true; fi ;;
			SHA256) if [ $hashSHA256 = false ]; then newHashes="${newHashes}${h} "; hashSHA256=true; fi ;;
			SHA512) if [ $hashSHA512 = false ]; then newHashes="${newHashes}${h} "; hashSHA512=true; fi ;;
		esac
	done
	hashes="${newHashes% }"
fi
unset gotPCMCodecsOnly
if [ -z "$hashes" ]; then actionHash=false; fi

if [ -z "$outputCodecs" -a $checkFiles = false -a $computeReplaygain = false -a $actionHash = false -a $touchFiles = false ]; then
	printMessage 'error' 'usage' 'command_line' "$me: no action specified"
	exit $EX_USAGE
elif [ -n "$outputCodecs" -a $checkFiles = true ]; then
	printMessage 'error' 'usage' 'command_line' "$me: -c/-d and -t are mutually exclusive. Try again with either one alone."
	exit $EX_USAGE
elif [ -n "$outputCodecs" -a $touchFiles = true ]; then
	printMessage 'error' 'usage' 'command_line' "$me: -c/-d and -T are mutually exclusive. Try again with either one alone."
	exit $EX_USAGE
elif [ -z "$outputCodecs" -a $setCoverArtworkFile = true ]; then
	printMessage 'error' 'usage' 'command_line' "$me: -a is only available when transcoding (-c)."
	exit $EX_USAGE
elif [ -z "$outputCodecs" -a $copyOtherFiles = true ]; then
	printMessage 'error' 'usage' 'command_line' "$me: -f is only available when transcoding (-c)."
	exit $EX_USAGE
elif [ $computeReplaygain = true -a $touchFiles = true ]; then
	printMessage 'error' 'usage' 'command_line' "$me: -g/-G/-S and -T are mutually exclusive. Try again with either one alone."
	exit $EX_USAGE
elif [ $actionHash = true -a $touchFiles = true ]; then
	printMessage 'error' 'usage' 'command_line' "$me: -H and -T are mutually exclusive. Try again with either one alone."
	exit $EX_USAGE
elif [ -n "$outputCodecs" -a $computeReplaygain = true ]; then
	printMessage 'error' 'usage' 'command_line' "$me: -c/-d and -g/-S are mutually exclusive. Try again with either one alone."
	exit $EX_USAGE
elif [ $checkFiles = true -a $computeReplaygain = true ]; then
	printMessage 'error' 'usage' 'command_line' "$me: -g/-G/-S and -t are mutually exclusive. Try again with either one alone."
	exit $EX_USAGE
elif [ $checkFiles = true -a $actionHash = true ]; then
	printMessage 'error' 'usage' 'command_line' "$me: -H and -t are mutually exclusive. Try again with either one alone."
	exit $EX_USAGE
elif [ $checkFiles = true -a $touchFiles = true ]; then
	printMessage 'error' 'usage' 'command_line' "$me: -t and -T are mutually exclusive. Try again with either one alone."
	exit $EX_USAGE
elif [ $computeReplaygain = true -a $actionHash = true ]; then
	printMessage 'error' 'usage' 'command_line' "$me: -g/-G/-S and -H are mutually exclusive. Try again with either one alone."
	exit $EX_USAGE
fi

nTracks=$# ec=$EX_OK
declare -a inputFilesAndDirs=("$@")
declare -a inputFiles=()
declare -a sourceFiles=()
numberOfInputFiles=0

getInputFiles && checkInputFiles && checkBinaries && handleInstance && setupSwapdir

for signal in INT TERM ABRT PIPE; do
	trap "cleanAbort" $signal
done

if [ -n "$outputCodecs" -a $tagCompressionSetting = true ]; then
	getEncoderVersions
fi

if [ $nCodecs -gt 0 ]; then # action: transcode files
	checkOutputDirectories

	nJobs=$(( nTracks * nCodecs ))
	if [ $nProcesses -gt $nJobs ]; then setNumberOfProcesses $nJobs ; fi
	if [ $gnudate = true ]; then
		time1="$( $datecmd '+%s.%N' )"
	else
		time1="$( date '+%s' ).0"
	fi
	for ((p=0; p < nProcesses; p++)); do
		transcode &
	done
elif [ $checkFiles = true ]; then
	if [ $nProcesses -gt $nTracks ]; then setNumberOfProcesses $nTracks ; fi
	if [ $gnudate = true ]; then
		time1="$( $datecmd '+%s.%N' )"
	else
		time1="$( date '+%s' ).0"
	fi
	for ((p=0; p < nProcesses; p++)); do
		testFiles &
	done
elif [ $computeReplaygain = true ]; then
	if [ $nProcesses -gt $nTracks ]; then setNumberOfProcesses $nTracks ; fi
	if [ $gnudate = true ]; then
		time1="$( $datecmd '+%s.%N' )"
	else
		time1="$( date '+%s' ).0"
	fi
	for ((p=0; p < nProcesses; p++)); do
		computeTrackGains &
	done
elif [ $touchFiles = true ]; then
	if [ $nProcesses -gt $nTracks ]; then setNumberOfProcesses $nTracks ; fi
	if [ $gnudate = true ]; then
		time1="$( $datecmd '+%s.%N' )"
	else
		time1="$( date '+%s' ).0"
	fi
	for ((p=0; p < nProcesses; p++)); do
		computeTrackDateTimes &
	done
elif [ $actionHash = true ]; then
	if [ $nProcesses -gt $nTracks ]; then setNumberOfProcesses $nTracks ; fi
	if [ $gnudate = true ]; then
		time1="$( $datecmd '+%s.%N' )"
	else
		time1="$( date '+%s' ).0"
	fi
	for ((p=0; p < nProcesses; p++)); do
		computeHashes &
	done
fi
ec=$EX_OK ; for p in $( jobs -p ); do wait $p || ec=$EX_KO ; done

if [ $ec -eq $EX_OK ]; then
	if [ $computeReplaygain = true ]; then
		if [ $allFilesAreOpus = true ]; then
			computeOpusAlbumGain || ec=$EX_KO
		else
			if [ $applyGain = false -o "${applyGainType%_*}" = 'ALBUM' ]; then
				computeAlbumGain || ec=$EX_KO
			fi
		fi
	elif [ $touchFiles = true ]; then
		touchAllFiles || ec=$EX_KO
	fi
fi

if [ $gnudate = true ]; then
	time2="$( $datecmd '+%s.%N' )"
else
	time2="$( date '+%s' ).0"
fi

# print transcoding stats if applicable
if [ $ec -eq $EX_OK -a $verbose = true ]; then
	if [ "$outputMode" = 'machine' ]; then
		printMachineStats
	else
		printHumanStats
	fi
fi

cleanExit $ec
