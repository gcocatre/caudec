#!/bin/bash

# Copyright © 2012 - 2025 Guillaume Cocatre-Zilgien <guillaume@cocatre.net>
# https://github.com/gcocatre/caudec
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Global variables =============================================================

declare -r Self_Name='caudec'
declare -r Self_Decode_Name='decaude'
declare -r Self_Called_As="${0##*/}"
declare -r Self_Version='4.0.0'

# Ex_Usage: The command was used incorrectly, e.g., with the wrong number of arguments, a bad flag, a bad syntax in a parameter, or whatever.
# Ex_Data_Err: The input data was incorrect in some way. This should only be used for user's data & not system files.
# Ex_No_Input: An input file (not a system file) did not exist or was not readable. This could also include errors like "No message" to a mailer (if it cared to catch it).
# Ex_No_User: The user specified did not exist. This might be used for mail addresses or remote logins.
# Ex_No_Host: The host specified did not exist. This is used in mail addresses or network requests.
# Ex_Unavailable: A service is unavailable. This can occur if a support program or file does not exist. This can also be used as a catchall message when something you wanted to do doesn't work, but you don't know why.
# Ex_Software: An internal software error has been detected. This should be limited to non-operating system related errors as possible.
# Ex_Os_Err: An operating system error has been detected. This is intended to be used for such things as "cannot fork", "cannot create pipe", or the like. It includes things like getuid returning a user that does not exist in the passwd file.
# Ex_Os_File: Some system file (e.g., /etc/passwd, /etc/utmp, etc.) does not exist, cannot be opened, or has some sort of error (e.g., syntax error).
# Ex_Cant_Create: A (user specified) output file cannot be created.
# Ex_Io_Err: An error occurred while doing I/O on some file.
# Ex_Temp_Fail: temporary failure, indicating something that is not really an error. In sendmail, this means that a mailer (e.g.) could not create a connection, and the request should be reattempted later.
# Ex_Protocol: the remote system returned something that was "not possible" during a protocol exchange.
# Ex_No_Perm: You did not have sufficient permission to perform the operation. This is not intended for file system problems, which should use NOINPUT or CANTCREAT, but rather for higher level permissions.

declare -r Ex_Ok=0            # successful termination
declare -r Ex_Ko=1            # unsuccessful termination
declare -r Ex_Usage=64        # command line usage error
declare -r Ex_Data_Err=65     # data format error
declare -r Ex_No_Input=66     # cannot open input
declare -r Ex_No_User=67      # addressee unknown
declare -r Ex_No_Host=68      # host name unknown
declare -r Ex_Unavailable=69  # service unavailable
declare -r Ex_Software=70     # internal software error
declare -r Ex_Os_Err=71       # system error (e.g., can't fork)
declare -r Ex_Os_File=72      # critical OS file missing
declare -r Ex_Cant_Create=73	# can't create (user) output file
declare -r Ex_Io_Err=74       # input/output error
declare -r Ex_Temp_Fail=75    # temp failure; user is invited to retry
declare -r Ex_Protocol=76     # remote error in protocol
declare -r Ex_No_Perm=77      # permission denied
declare -r Ex_Config_Err=78   # configuration error
declare -r Ex_Interrupt=143   # user interruption (Ctrl+C)

# https://dev.to/ifenna__/adding-colors-to-bash-scripts-48g4

# Clr_El="\\033[2K\\033[0G" # FIXME: can't remember what that does
Clr_Ok="\\033[1;32m" # bright green
Clr_Ko="\\033[1;31m" # bright red
Clr_Wg="\\033[1;33m" # bright yellow

Clr_Rst="\\033[0m" # reset (normal color)

Clr_N_Bk="\\033[0;30m" # black
Clr_B_Bk="\\033[1;30m" # dark gray
Clr_N_Rd="\\033[0;31m" # dark red
Clr_B_Rd="\\033[1;31m" # bright red
Clr_N_Gr="\\033[0;32m" # dark green
Clr_B_Gr="\\033[1;32m" # bright green
Clr_N_Yl="\\033[0;33m" # brown
Clr_B_Yl="\\033[1;33m" # yellow
Clr_N_Bl="\\033[0;34m" # dark blue
Clr_B_Bl="\\033[1;34m" # bright blue
Clr_N_Pp="\\033[0;35m" # dark purple
Clr_B_Pp="\\033[1;35m" # bright purple
Clr_N_Cy="\\033[0;36m" # dark cyan
Clr_B_Cy="\\033[1;36m" # bright cyan
Clr_N_Wh="\\033[0;37m" # bright gray
Clr_B_Wh="\\033[1;37m" # white

# Temporary dirs:
# ${TMPDIR}/caudec.XXXXXXXX
# ${TMPDIR}/caudec.XXXXXXXX/control/
# ${TMPDIR}/caudec.XXXXXXXX/data/
# ${TMPDIR}/caudec.XXXXXXXX/io/
# ${TMPDIR}/caudec.XXXXXXXX/jobs/
# ${TMPDIR}/caudec.XXXXXXXX/PID
# ${TMPDIR}/caudec.XXXXXXXX/swap/

declare -r Self_Permissions='u=rwX,go=rX'

declare -r Flac_Max_Threads=128
declare -r WavPack_Max_Threads=12

if [ -n "$LC_ALL" ]; then
#	export LANG="$LC_ALL"
	unset LC_ALL
fi
export LANG='en_US.UTF-8'
export LC_NUMERIC='C'

datecmd='date' gnudate='true'
findcmd='find' gnufind='true'
sedcmd='sed' gnused='true'
statcmd='stat' gnustat='true'
if which 'uname' 1>/dev/null 2>&1 ; then
	OS="$( uname -s )"
	if [ "$OS" = 'Darwin' ]; then
		gnudate='false' gnufind='false' gnused='false' gnustat='false'
		if which 'gdate' 1>/dev/null 2>&1; then
			datecmd='gdate' gnudate='true'
		fi
		if which 'gfind' 1>/dev/null 2>&1; then
			findcmd='gfind' gnufind='true'
		fi
		if which 'gsed' 1>/dev/null 2>&1; then
			sedcmd='gsed' gnused='true'
		fi
		if which 'gstat' 1>/dev/null 2>&1; then
			statcmd='gstat' gnustat='true'
		fi
	fi
fi


# User settings ================================================================

if [ -r '/etc/caudecrc' ]; then
	. '/etc/caudecrc'
	test -n "$maxInstances" && rootMaxInstances="$maxInstances"
	test -n "$maxInputFiles" && rootMaxInputFiles="$maxInputFiles"
	test -n "$preloadSources" && rootPreloadSources="$preloadSources"
fi

if [ -r "${HOME}/.caudecrc" ]; then
	. "${HOME}/.caudecrc"
fi

# sanitize caudecrc input

case "$FLACPadding" in
	[0-9]*) true ;; # nothing to do
	*) FLACPadding=8192 ;; # FLAC default
esac

case "$OpusPadding" in
	[0-9]*) true ;; # nothing to do
	*) OpusPadding=512 ;;  # Opus default
esac

case "$ID3Padding" in
	[0-9]*) true ;; # nothing to do
	*) ID3Padding=512 ;;  # LAME default
esac

# true by default
if [ "$preventClipping" = 'false' ]; then preventClipping='false'; else preventClipping='true'; fi

# false by default
if [ "$computeAudioPeaks" = 'true' ]; then computeAudioPeaks='true'; else computeAudioPeaks='false'; fi
if [ "$ignoreUnsupportedFiles" = 'true' ]; then ignoreUnsupportedFiles='true'; else ignoreUnsupportedFiles='false'; fi
if [ "$keepWavMetadata" = 'true' ]; then keepWavMetadata='true'; else keepWavMetadata='false'; fi
if [ "$setCompilationFlagWithAlbumArtist" = 'true' ]; then setCompilationFlagWithAlbumArtist='true'; else setCompilationFlagWithAlbumArtist='false'; fi
if [ "$tagCompressionSetting" = 'true' ]; then tagCompressionSetting='true'; else tagCompressionSetting='false'; fi

test -z "$tagWhitelist" && tagWhitelist=''
if [ -n "$tagWhitelist" ]; then
	tagWhitelist="${tagWhitelist//, /,}"
	tagWhitelist="${tagWhitelist%,}"
fi

test -z "$tagBlacklist" && tagBlacklist=''
if [ -n "$tagBlacklist" ]; then
	tagBlacklist="${tagBlacklist//, /,}"
	tagBlacklist="${tagBlacklist%,}"
fi

if [ -n "$rootMaxInstances" ]; then maxInstances="$rootMaxInstances"; fi
case "$maxInstances" in
	[0-9]*) if [ $maxInstances -lt 1 ]; then maxInstances=1 ; fi ;;
	*) maxInstances=1 ;;
esac

if [ -n "$rootMaxInputFiles" ]; then maxInputFiles="$rootMaxInputFiles"; fi
case "$maxInputFiles" in
	[0-9]*) if [ $maxInputFiles -lt 1 ]; then maxInputFiles=100 ; fi ;;
	*) maxInputFiles=100 ;;
esac

# true by default
if [ -n "$rootPreloadSources" ]; then preloadSources="$rootPreloadSources"; fi
if [ "$preloadSources" = 'false' ]; then preloadSources='false'; else preloadSources='true'; fi

# FIXME: handle preloadSources
preloadSources='false'

# true by default
if [ "$enableColors" = 'false' ]; then
	Clr_Ok="" Clr_Ko="" Clr_Wg="" Clr_Rst="" Clr_N_Bk="" Clr_B_Bk="" Clr_N_Rd="" Clr_B_Rd="" Clr_N_Gr="" Clr_B_Gr=""
	Clr_N_Yl="" Clr_B_Yl="" Clr_N_Bl="" Clr_B_Bl="" Clr_N_Pp="" Clr_B_Pp="" Clr_N_Cy="" Clr_B_Cy="" Clr_N_Wh=""
	Clr_B_Wh=""
fi

# true by default
if [ "$useBrightColors" = 'false' ]; then
	useBrightColors='false'
	Clr_Ok="$Clr_N_Gr" Clr_Ko="$Clr_N_Rd" Clr_Wg="$Clr_N_Yl" Clr_N_Cy="$Clr_N_Bl"
else
	useBrightColors='true'
fi

# Functions ====================================================================

debug () {
	local str="$1"
	echo -e "${Clr_Wg}>>> DEBUG:${Clr_Rst} $str" 1>&2
}

printUsage () {
	if [ "$Self_Called_As" = "$Self_Decode_Name" ]; then
		echo "$Self_Name ${Self_Version}: multiprocess audio converter
Copyright © 2012 - 2025 Guillaume Cocatre-Zilgien
https://github.com/gcocatre/caudec

Usage: $Self_Decode_Name FILES
Decodes FILES to WAV (same as '$Self_Name -d' and '$Self_Name -c wav').
Instead of multiple files, one or more directories may be specified.
See also: $Self_Name -h"
	else
		echo "$Self_Name ${Self_Version}: multiprocess audio converter
Copyright © 2012 - 2025 Guillaume Cocatre-Zilgien
https://github.com/gcocatre/caudec

Usage: $Self_Name [ GLOBAL PARAMETERS ] [ PROCESSING [ PARAMETERS ] ] FILES
Operate on multiple audio files at once, in parallel.
Instead of multiple files, one or more directories may be specified.
Multiple codec switches (optionally paired with a -q switch) may be specified.
Supported input files: .wav, .aiff, .caf, .flac, .wv, .ape, .m4a

-------------------------------------------------------------------------------

Global parameters:

  -n N      launch N processes concurrently (1-${maxProcesses});
            by default, the number of CPU cores.

  -i        ignore unsupported files

  -s        be silent, only print errors

  -S ARG    strategy for processing tracks in the given order, by duration:
            'l' / 'longest', 's' / 'shortest', 'n' / 'none' (default)

  -z        produce machine-parsable output; must be the first parameter on the
            command line to take effect. Run 'caudec -z' on its own to print
            a description of the syntax.

  -Z        produce human-readable output to STDOUT, and machine-parsable
            output to STDERR

-------------------------------------------------------------------------------

Applying gain after decoding and before encoding:

  -G ARG    apply ReplayGain ('album' or 'track') if found in source file
            metadata. Note: it is possible to specify a preamp value with an
            additional -G GAIN parameter (see below), for instance
            '-G album -G -3' or '-G track -G +2'.

  -G ARG    apply peak normalization ('albumpeak' or 'trackpeak'); same as
            above, except album or track peak values are used as a starting
            point instead of album or track gain values. An additional preamp
            value may be specified as well (see -G GAIN below).

  -G GAIN   apply arbitrary GAIN (signed number from -99.99 to +99.99)

-------------------------------------------------------------------------------

Resampling after decoding and before encoding:

  -b BITS   bit depth (16, 24)
  -r HZ     sampling rate in Hz (44100, 48000, 88200, 96000, 176400, 192000,
            352800, 384000)
  -r KHZ    sampling rate in kHz (44[.1], 48, 88[.2], 96, 176[.4], 192, 352[.8],
            384)
  -r cd     equivalent to -b 16 -r 44100 -2 (includes conversion to stereo)
  -r dvd    equivalent to -b 16 -r 48000
  -r sacd   equivalent to -b 24 -r 88200
  -r dvda   equivalent to -b 24 -r 96000
  -r bluray equivalent to -b 24 -r 96000
  -r pono   equivalent to -b 24 -r 192000
  -r dxd    equivalent to -b 24 -r 352800
  -2        convert to stereo: 2.1, 4.0, 5.0, 5.1 and 7.1 audio will be
            downmixed, using proper channel mappings; mono audio will be
            upmixed to dual-mono (stereo with two identical channels)

-------------------------------------------------------------------------------

Encoding parameters (mutually exclusive from all other actions):

  -c CODEC  use specified CODEC: wav, aiff, caf,
            flac, wv (WavPack), wvh (WavPack Hybrid), wvl (WavPack lossy),
            lossyFLAC, ape (Monkey's Audio), alac (m4a), aac (m4a), mp3,
            ogg / vorbis, opus.

            IMPORTANT NOTE: when encoding to lossyFLAC with a quality setting
            of 'S' or lower, the input is upscaled to 24 bit and the signal is
            scaled down by lossyWAV (volume reduction) in order to improve
            quality and compression. It is thus strongly advised to run
            'caudec -g' on the resulting files in order to compute ReplayGain
            values that will bring back the volume to a normal level.
            The 'transcaude' utility will do that automatically.

  -C CODEC  use specified CODEC, but discard existing metadata

  -q ARG    set compression level (variable bitrate mode; try -q help for
            a list of valid values)

  -b ARG    constant or target bitrate in bits per sample (for -c wvh/wvl)
            or in kilobits per second (for all lossy codecs)
  -B ARG    average bitrate in kilobits per second (for all lossy codecs)

  -o DIR    set existing output directory
  -O DIR    set output directory, create it if it doesn't exist already
  -P DIR    set and create output directory, and mirror the source file's
            path components (e.g. 'a/b/file.flac' => 'DIR/a/b/file.ogg')

  -l DIR    set existing directory for hard linking lossy .wv files from
            WavPackHybrid's output directory
  -L DIR    set and create a directory for hard linking lossy .wv files from
            WavPackHybrid's output directory

  -a FILE   embed cover art FILE into supported files. Specify -a first
            to embed the same file for all supported codecs specified by -c,
            or specify -a after -c to embed cover art only for that codec,
            if supported. FILE must be a filename and that file must be
            located in the source directory. If FILE is an empty string,
            no artwork will be embedded, not even the source file's
            embedded artwork.

  -f ARG    copy certain files to the output directory. ARG may be a 'all',
            a comma separated list of files, and / or file extensions preceded
            by a dot. If ARG is a list of files, they must be filenames and
            those files must be located in the source directory. If ARG is
            an empty string, no files will be copied.

  -k        keep existing destination files (don't overwrite them)
  -K        keep existing destination files if they're newer than their source


When transcoding to multiple codecs at once (multiple -c parameters),
specify a -o/O/P parameter after each -c parameter in order to set per-codec
output directories. For instance:
\$ caudec -c flac -P ~/Music/FLAC -c mp3 -P ~/Music/MP3 \"Artist/Album\"/*.flac


Similarly, specifying -a/-f after a -c parameter will affect only that codec.
For instance:
\$ caudec -c flac -P ~/Music/FLAC -f cover.jpg \\
  -c mp3 -P ~/Music/MP3 -f folder.jpg \"Artist/Album\"/*.flac


Creating a WavPack Hybrid collection with a different root directory for lossy:
\$ caudec -c wvh -P ~/Music/Lossless -L ~/Music/Lossy \"Artist/Album\"/*.flac
That will create a mirrored directory structure with hard linked lossy files.
~/Music/Lossless will contain the full lossless collection, which can be safely
backed up and ~/Music/Lossy will contain only the lossy part of the collection.
Little to no extra storage will be used (just extra inodes).

-------------------------------------------------------------------------------

Decoding parameters (all mutually exlusive from each other and other actions):

  -d        decode to WAV (input: AIFF, ALAC, APE, CAF, FLAC, WavPack)
  -t        test file integrity
  -H        show internal hash, if available

-------------------------------------------------------------------------------

ReplayGain parameters (mutually exclusive from all other actions):

  -g        generate ReplayGain metadata

  -G ARG    MP3: apply ReplayGain ('album' or 'track') using MP3's gain header.
            It is the standard way for MP3 and is reversible.

  -G undo   MP3: reverse ReplayGain using MP3's gain header.
            Other codecs: remove ReplayGain metadata.

-------------------------------------------------------------------------------

Touching file times (mutually exclusive from all other actions):

  -T        touch files using metadata to reflect the music's release date
            and duration. Provide all files as arguments, not just audio files,
            although at least one audio file is required for this to work.
            Use with -l when dealing with a hard linked collection (-c wvh).
            Ex: $Self_Name -T ~/Music/Lossless/Artist/Album/*
            Ex: $Self_Name -T ~/Music/Lossless/Artist/Album/* -l ~/Music/Lossy

-------------------------------------------------------------------------------

Information:

  -h        display this help and exit
  -I        display channels, sample size and sampling rate
  -V        output version information and exit

-------------------------------------------------------------------------------

caudec uses a temporary directory for processing files (\$TMPDIR or /tmp by
default). If you wish to use another directory, set the CAUDEC_SWAP_DIR
environment variable to its path (export CAUDEC_SWAP_DIR=\"/some/dir\"), or set
CAUDEC_SWAP_DIR in your configuration file (~/.caudecrc or /etc/caudecrc).

To enable debugging, set the CAUDECDEBUG environment variable to 'true'
(export CAUDECDEBUG='true'). caudec will output some additional information,
as well as a log of errors that occurred while using external tools.

For more help, see the online documentation:
https://github.com/gcocatre/caudec"
	fi
}

printMachineSyntax () {
	echo "-------------------------------------------------------------------------------
         Format specification of caudec's machine-parsable output (-z)
-------------------------------------------------------------------------------

Fields are separated with pipes ('|', Unicode: U+007C); pipe characters present
in messages are replaced with the visually similar 'broken bar' sign ('¦',
Unicode: U+00A6).

processId|status|context|data|message|path

processId: identifier (PID) of the caudec process.

status: one of info, success, error, warning, abort.

context: optional additional information about the status (usage,
    initialization, decoding, processing, encoding, testing, hash, debugging,
    track_gain, album_gain, checking_version, aborting, hash_type,
    bitrate_codecName, processing_rate, touch_file, touch_files).

data: optional data about the status (hash type, hash value, hash error,
    gain value in dB, bitrate in bits per second, processing rate, version
    status, file characteristics). Some data keywords:
    * filesystem (filesystem related error or information),
    * server (server related error or information),
    * command_line (command line related error or information),
    * bad_value (user provided a parameter with a bad argument),
    * quota (some limit has been reached),
    * internal (internal software error / warning),
    * no_hash (no internal hash found),
    * bad_internal_hash (internal MD5 hash is incorrect),

message: optional human-readable information about the status.

file: path of the file that is affected by the status (if applicable)."
}

# processId|status|context|data|message|path
getMachineParsableString () {
	local pid=''

	if [ -n "$BASHPID" ]; then
		pid="$BASHPID"
	elif [ -n "$$" ]; then
		pid="$$"
	fi

	# replace pipes ('|', Unicode: U+007C) with 'broken bar' signs ('¦', Unicode: U+00A6)
	msg="${msg//|/¦}"

	case "$msgType" in
		abort) str="$( printf "%s|%s|%s|%s|%s|%s\n" '0' "$msgType" 'aborting' '' 'Aborting.' '' )" ;;

		info)
			if [ -n "$bitrate" ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$pid" "$msgType" "bitrate_${codec}" "$bitrate" "$msg" '' )"
			elif [ -n "$processingRate" ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$pid" "$msgType" 'processing_rate' "${processingRate%% x}" "$msg" '' )"
			elif [ "$statusInfo" = 'hashing' -a -n "$statusData" ]; then
			str="$( printf "%s|%s|%s|%s|%s|%s\n" "$pid" "$msgType" "hash" "$statusData" "$msg" "$file" )"
			else
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$pid" "$msgType" "$statusInfo" "$statusData" "$msg" '' )"
			fi
			;;

		success)
			if [ "$statusInfo" = 'track_gain' ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$pid" "$msgType" "$statusInfo" "$gain" "$msg" "$file" )"
			elif [ "$statusInfo" = 'album_gain' ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$pid" "$msgType" "$statusInfo" "$gain" "$msg" "$file" )"
			elif [ "$statusInfo" = 'touch_file' ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$pid" "$msgType" "$statusInfo" "$dateTime" "$msg" "$file" )"
			elif [ "$statusInfo" = 'touch_files' ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$pid" "$msgType" "$statusInfo" "$albumTime" "$path" "$msg" )"
			elif [ "$statusInfo" = 'testing' ]; then
				if [ -n "$hashError" ]; then
					str="$( printf "%s|%s|%s|%s|%s|%s\n" "$pid" "$msgType" "$statusInfo" "$hashError" '' "$file" )"
				else
					str="$( printf "%s|%s|%s|%s|%s|%s\n" "$pid" "$msgType" "$statusInfo" "$hashType" '' "$file" )"
				fi
			elif [ "$statusInfo" = 'characteristics' ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$pid" "$msgType" "$statusInfo" "$characteristics" "$msg" "$file" )"
			else
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$pid" "$msgType" "$statusInfo" "$statusData" "$msg" "$file" )"
			fi
			;;

		error)
			if [ "$statusInfo" = 'testing' ]; then
				if [ -n "$hashError" ]; then
					str="$( printf "%s|%s|%s|%s|%s|%s\n" "$pid" "$msgType" "$statusInfo" "$hashError" '' "$file" )"
				else
					str="$( printf "%s|%s|%s|%s|%s|%s\n" "$pid" "$msgType" "$statusInfo" "$hashType" '' "$file" )"
				fi
			elif [ "$statusInfo" = 'album_gain' ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$pid" "$msgType" "$statusInfo" '' '' "$msg" )"
			else
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$pid" "$msgType" "$statusInfo" "$statusData" "$msg" "$file" )"
			fi
			;;

		warning)
			if [ "$statusInfo" = 'testing' ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$pid" "$msgType" "$statusInfo" "$hashError" "$msg" "$file" )"
			elif [ -n "$hashError" ]; then
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$pid" "$msgType" "$statusInfo" "$hashError" "$msg" "$file" )"
			else
				str="$( printf "%s|%s|%s|%s|%s|%s\n" "$pid" "$msgType" "$statusInfo" "$statusData" "$msg" "$file" )"
			fi
			;;
	esac

	if [ -n "$str" ]; then
		echo -e "$str"
	fi
}

getHumanReadableString () {
	local data

	if [ -z "$numberOfThreads" ]; then
		numberOfThreads=0
	fi

	case "$msgType" in
		info)
			if [ "$statusInfo" = 'hashing' -a -n "$statusData" ]; then
				str="$( printf "${Clr_B_Bk}%2u ${Clr_Ok}%s ${Clr_Rst}%s ${Clr_N_Cy}%s${Clr_Rst}\n" $processNumber "$msg" "${statusData}" "$fileName" )"
			elif [ -n "$msg" ]; then
				str="$( printf "${Clr_B_Bk} * ${Clr_Rst}%s\n" "$msg" )"
			fi ;;

		abort) str="$( printf "${Clr_Wg} * ${Clr_Rst}%s\n" 'Aborting.' )" ;;

		success)
			if [ "$statusInfo" = 'track_gain' ]; then
				str="$( printf "${Clr_B_Bk}%2u ${Clr_Ok}OK ${Clr_Rst}%9s ${Clr_N_Cy}%s${Clr_Rst}\n" $processNumber "$gain dB" "$fileName" )"
			elif [ "$statusInfo" = 'album_gain' ]; then
				str="$( printf "${Clr_B_Bk} * ${Clr_Ok}OK ${Clr_Rst}%9s ${Clr_Rst}%s\n" "$gain dB" 'Album gain' )"
			elif [ "$statusInfo" = 'touch_file' ]; then
				str="$( printf "${Clr_B_Bk}%2u ${Clr_Ok}OK ${Clr_Rst}%s ${Clr_N_Cy}%s${Clr_Rst}\n" $processNumber "$dateTime" "$fileName" )"
			elif [ "$statusInfo" = 'touch_files' ]; then
				str="$( printf "${Clr_B_Bk} * ${Clr_Ok}OK ${Clr_Rst}%10s ${Clr_Rst}%s\n" "$albumTime" "Album length" )"
			elif [ "$statusInfo" = 'testing' ]; then
				if [ -n "$numberOfThreads" ]; then
					if [ $numberOfThreads -lt 2 ]; then
						str="$( printf "${Clr_B_Bk}%2u ${Clr_B_Bk}%2ux ${Clr_Ok}OK ${Clr_Rst}%s ${Clr_N_Cy}%s${Clr_Rst}\n" $processNumber "$numberOfThreads" "$hashType" "$fileName" )"
					elif [ $numberOfThreads -ge 2 -a $numberOfThreads -lt 4 ]; then
						str="$( printf "${Clr_B_Bk}%2u ${Clr_N_Gr}%2ux ${Clr_Ok}OK ${Clr_Rst}%s ${Clr_N_Cy}%s${Clr_Rst}\n" $processNumber "$numberOfThreads" "$hashType" "$fileName" )"
					elif [ $numberOfThreads -ge 4 ]; then
						str="$( printf "${Clr_B_Bk}%2u ${Clr_Ok}%2ux ${Clr_Ok}OK ${Clr_Rst}%s ${Clr_N_Cy}%s${Clr_Rst}\n" $processNumber "$numberOfThreads" "$hashType" "$fileName" )"
					fi
				else
					str="$( printf "${Clr_B_Bk}%2u ${Clr_Ok}OK ${Clr_Rst}%s ${Clr_N_Cy}%s${Clr_Rst}\n" $processNumber "$hashType" "$fileName" )"
				fi
			elif [ "$statusInfo" = 'characteristics' ]; then
				data="${characteristics}"
				data="${data//;/|}"
				if [ "${msg}" = "CDDA" ]; then
					str="$( printf "${Clr_B_Bk}%2u ${Clr_Ok}CD ${Clr_Rst}%s ${Clr_N_Cy}%s${Clr_Rst}\n" $processNumber "${data}" "$fileName" )"
				else
					str="$( printf "${Clr_B_Bk}%2u ${Clr_B_Bl}OM ${Clr_Rst}%s ${Clr_N_Cy}%s${Clr_Rst}\n" $processNumber "${data}" "$fileName" )"
				fi
			elif [ -n "$file" ]; then # transcoding or hashing
				if [ -n "$processNumber" ]; then
					if [ -n "$numberOfThreads" ]; then
						if [ $numberOfThreads -lt 2 ]; then
							str="$( printf "${Clr_B_Bk}%2u ${Clr_B_Bk}%2ux ${Clr_Ok}OK ${Clr_N_Cy}%s${Clr_Rst}\n" $processNumber "$numberOfThreads" "$fileName" )"
						elif [ $numberOfThreads -ge 2 -a $numberOfThreads -lt 4 ]; then
							str="$( printf "${Clr_B_Bk}%2u ${Clr_N_Gr}%2ux ${Clr_Ok}OK ${Clr_N_Cy}%s${Clr_Rst}\n" $processNumber "$numberOfThreads" "$fileName" )"
						elif [ $numberOfThreads -ge 4 ]; then
							str="$( printf "${Clr_B_Bk}%2u ${Clr_Ok}%2ux ${Clr_Ok}OK ${Clr_N_Cy}%s${Clr_Rst}\n" $processNumber "$numberOfThreads" "$fileName" )"
						fi
					else
						str="$( printf "${Clr_B_Bk}%2u ${Clr_Ok}OK ${Clr_N_Cy}%s${Clr_Rst}\n" $processNumber "$fileName" )"
					fi
				else
					str="$( printf "${Clr_B_Bk} * ${Clr_Ok}OK ${Clr_N_Cy}%s${Clr_Rst}\n" "$fileName" )"
				fi
			elif [ -n "$msg" ]; then
				str="$( printf "${Clr_B_Bk} * ${Clr_Ok}OK${Clr_Rst}: %s\n" "$msg" )"
			fi
			;;

		error)
			if [ "$statusInfo" = 'decoding' ]; then
				str="$( printf "${Clr_B_Bk}%2u ${Clr_B_Bk}%2ux ${Clr_Ko}DC ${Clr_N_Cy}%s${Clr_Rst}\n" $processNumber "$numberOfThreads" "$fileName" )"
			elif [ "$statusInfo" = 'encoding' ]; then
				if [ -n "$msg" ]; then
					str="$( printf "${Clr_B_Bk}%2u ${Clr_B_Bk}%2ux ${Clr_Ko}EC ${Clr_N_Cy}%s ${Clr_Rst}: %s\n" $processNumber "$numberOfThreads" "$fileName" "$msg" )"
				else
					str="$( printf "${Clr_B_Bk}%2u ${Clr_B_Bk}%2ux ${Clr_Ko}EC ${Clr_N_Cy}%s${Clr_Rst}\n" $processNumber "$numberOfThreads" "$fileName" )"
				fi
			elif [ "$statusInfo" = 'processing' ]; then
				str="$( printf "${Clr_B_Bk}%2u ${Clr_Ko}PR ${Clr_N_Cy}%s${Clr_Rst}\n" $processNumber "$fileName" )"
			elif [ "$statusInfo" = 'testing' ]; then
				if [ -n "$hashType" ]; then
					str="$( printf "${Clr_B_Bk}%2u ${Clr_Ko}ER ${Clr_Rst}%s ${Clr_N_Cy}%s${Clr_Rst}\n" $processNumber "$hashType" "$fileName" )"
				elif [ -n "$msg" ]; then
					str="$( printf "${Clr_B_Bk}%2u ${Clr_Ko}ER ${Clr_N_Cy}%s${Clr_Rst}: %s\n" $processNumber "$fileName" "$msg" )"
				else
					str="$( printf "${Clr_B_Bk}%2u ${Clr_Ko}ER ${Clr_N_Cy}%s${Clr_Rst}\n" $processNumber "$fileName" )"
				fi
			elif [ "$statusInfo" = 'characteristics' ]; then
				str="$( printf "${Clr_B_Bk}%2u ${Clr_Ko}ER ${Clr_Rst}%s ${Clr_N_Cy}%s${Clr_Rst}\n" $processNumber "$characteristics" "$fileName" )"
			elif [ -n "$file" ]; then
				if [ -n "$msg" ]; then
					if [ -n "$processNumber" ]; then
						str="$( printf "${Clr_B_Bk}%2u ${Clr_Ko}ER ${Clr_N_Cy}%s${Clr_Rst}: %s\n" $processNumber "$fileName" "$msg" )"
					else
						str="$( printf "${Clr_B_Bk} * ${Clr_Ko}ER ${Clr_N_Cy}%s${Clr_Rst}: %s\n" "$fileName" "$msg" )"
					fi
				else
					if [ -n "$processNumber" ]; then
						str="$( printf "${Clr_B_Bk}%2u ${Clr_Ko}ER ${Clr_N_Cy}%s${Clr_Rst}\n" $processNumber "$fileName" )"
					else
						str="$( printf "${Clr_B_Bk} * ${Clr_Ko}ER ${Clr_N_Cy}%s${Clr_Rst}\n" "$fileName" )"
					fi
				fi
			elif [ -n "$msg" ]; then
				if [ -n "$processNumber" ]; then
					str="$( printf "${Clr_B_Bk}%2u ${Clr_Ko}ER${Clr_Rst}: %s\n" $processNumber "$msg" )"
				else
					str="$( printf "${Clr_B_Bk} * ${Clr_Ko}ER${Clr_Rst}: %s\n" "$msg" )"
				fi
			fi
			;;

		warning)
			if [ -n "$file" ]; then
				if [ -n "$processNumber" ]; then
					if [ -n "$numberOfThreads" ]; then
						str="$( printf "${Clr_B_Bk}%2u ${Clr_B_Bk}%2ux ${Clr_Wg}WG ${Clr_N_Cy}%s${Clr_Rst}: %s\n" $processNumber "$numberOfThreads" "$fileName" "$msg" )"
					else
						str="$( printf "${Clr_B_Bk}%2u ${Clr_Wg}WG ${Clr_N_Cy}%s${Clr_Rst}: %s\n" $processNumber "$fileName" "$msg" )"
					fi
				else
					str="$( printf "${Clr_B_Bk} * ${Clr_Wg}WG ${Clr_N_Cy}%s${Clr_Rst}: %s\n" "$fileName" "$msg" )"
				fi
			else
				if [ -n "$processNumber" ]; then
					str="$( printf "${Clr_B_Bk}%2u ${Clr_Wg}WG${Clr_Rst}: %s\n" $processNumber "$msg" )"
				else
					str="$( printf "${Clr_B_Bk} * ${Clr_Wg}WG${Clr_Rst}: %s\n" "$msg" )"
				fi
			fi
			;;
	esac

	if [ -n "$str" ]; then
		echo -e "$str"
	fi
}

printMessageToStdoutOrStderr () {
	local str="$1" stdOut="$2"

	if [ -n "$str" ]; then
		if [ "$stdOut" = 'stderr' ]; then
			echo -e "$str" 1>&2
		else
			echo -e "$str"
		fi
	fi
}

printMessage () {
	local msgType='info' msgVerbose='default' msgDebug='normal' msgOut='stdout' statusInfo='' statusData=''
	local file='' path='' fileDir='' msg='' p='' numberOfThreads='' hashError='' gain='' bitrate=''
	local codec='' outputCodec='' str='' characteristics='' processingRate='' msgArg

	for msgArg in "$@"; do
		case "$msgArg" in
			info) msgType="$msgArg" msgVerbose='verbose' ;;
			success) msgType="$msgArg" msgVerbose='verbose' ;;
			warning|error|abort) msgType="$msgArg" msgOut='stderr' ;;
			verbose) msgVerbose='verbose' ;;
			debug) msgDebug='debug' statusInfo='debugging' ;;
			stderr) msgOut='stderr' ;;
			initialization|usage|encoding|processing|decoding|hashing|testing|album_gain|track_gain|touch_file|touch_files|characteristics) statusInfo="$msgArg" ;;
			unsupported|quota|bad_value|filesystem|command_line|internal) statusData="$msgArg" ;;
			file:*) file="${msgArg#file:}"; fileDir="${file%/*}"; fileName="${file##*/}" ;;
			path:*) path="${msgArg#path:}" ;;
			outputCodec:*) statusData="${msgArg#outputCodec:}" ;;
			hash:*) statusData="${msgArg#hash:}" ;;
			hashType:*) msg="${msgArg#hashType:}" ;;
			+*dB|-*dB) gain="${msgArg% dB}" ;;
			*bps) bitrate="${msgArg%bps}" ;;
			*x) processingRate="$msgArg" ;;
			bitrate_*) codec="${msgArg#bitrate_}" ;;
			[0-9]*) p="$msgArg" ;;
			threads:[0-9]*) numberOfThreads="${msgArg#threads:}" ;;
			dateTime:[0-9]*) dateTime="${msgArg#dateTime:}" ;;
			albumTime:[0-9:]*) albumTime="${msgArg#albumTime:}" ;;
			characteristics:*) characteristics="${msgArg#characteristics:}" ;;
			mediaType:*) msg="${msgArg#mediaType:}" ;;
			no_hash|bad_internal_hash) hashError="$msgArg" ;;
			*) msg="$msgArg" ;;
		esac
	done

	if [ "$msgVerbose" = 'verbose' -a "$verbose" != 'true' ]; then return $Ex_Ok; fi
	if [ "$msgDebug" = 'debug' -a -z "$CAUDECDEBUG" ]; then return $Ex_Ok; fi

	case "$outputMode" in
		human) printMessageToStdoutOrStderr "$( getHumanReadableString )" "$msgOut" ;;
		machine) printMessageToStdoutOrStderr "$( getMachineParsableString )" "$msgOut" ;;
		humanAndMachine)
			printMessageToStdoutOrStderr "$( getHumanReadableString )" 'stdout'
			printMessageToStdoutOrStderr "$( getMachineParsableString )" 'stderr'
			;;
	esac

	return $Ex_Ok
}

getCompressionSetting () {
	local codec="$1" value="$2" source="$3" errormsg

	if [ -n "$source" ]; then
		errormsg="Configuration error (caudecrc):"
	else
		errormsg="$Self_Name -q:"
	fi

	case "$codec" in
		FLAC)
			if [ -z "$value" ]; then value=5; fi
			case "$value" in
				[0-8]) compression_FLAC="$value" ;;
				f|fast) compression_FLAC=0 ;;
				b|best) compression_FLAC=8 ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg compression level for $codec must be an integer between 0 and 8, or one of fast or best" ; exit $Ex_Usage ;;
			esac
			;;

		lossyFLAC)
			if [ -z "$value" ]; then value="S"; fi
			case "$value" in
				x|p|c|s|h|e|i) compression_lossyWAV="$( echo "$value" | tr '[:lower:]' '[:upper:]' )" ;;
				X|P|C|S|H|E|I) compression_lossyWAV="$value" ;;
				extraportable) compression_lossyWAV='X' ;;
				portable) compression_lossyWAV='P' ;;
				economic) compression_lossyWAV='C' ;;
				standard) compression_lossyWAV='S' ;;
				high) compression_lossyWAV='H' ;;
				extreme) compression_lossyWAV='E' ;;
				insane) compression_lossyWAV='I' ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg compression level for $codec must be one of X, P, C, S, H, E, I, or one of extraportable, portable, economic, standard, high, extreme or insane" ; exit $Ex_Usage ;;
			esac

			case "$compression_lossyWAV" in
				U|D) lossyWAV_scale="0.125" ;; # lossyWAV 1.5.0
				Q|A) lossyWAV_scale="0.25" ;;  # lossyWAV 1.5.0
				X|P|C|S) lossyWAV_scale="0.5" ;;
				H|E|I) lossyWAV_scale="1" ;;
			esac
			;;

		MonkeysAudio)
			if [ -z "$value" ]; then value="2"; fi
			case "$value" in
				[1-5]) compression_MonkeysAudio="$value" ;;
				fast) compression_MonkeysAudio=1 ;;
				normal) compression_MonkeysAudio=2 ;;
				high) compression_MonkeysAudio=3 ;;
				extra*) compression_MonkeysAudio=4 ;;
				insane) compression_MonkeysAudio=5 ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg compression level for $codec must be a number between 1 and 5, or one of fast, normal, high, extra, insane" ; exit $Ex_Usage ;;
			esac
			;;

		MP3)
			if [ -z "$value" ]; then value="3"; fi
			case "$value" in
				[0-9]) compression_MP3="$value" ;;
				medium) compression_MP3=4 ;;
				standard) compression_MP3=2 ;;
				extreme) compression_MP3=0 ;;
				insane|320) compression_MP3=320 ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg compression level for $codec must be an integer between 0 and 9 or one of medium, standard, extreme, insane or 320" ; exit $Ex_Usage ;;
			esac
			;;

		OggVorbis)
			if [ -z "$value" ]; then value="3"; fi
			case "$value" in
				[0-9]|10) compression_OggVorbis="$value" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg compression level for $codec must be an integer between 0 and 10" ; exit $Ex_Usage ;;
			esac
			;;

		Opus)
			if [ -z "$value" ]; then value="96"; fi
			case "$value" in
				[6-9]|[1-9][0-9]|[1-4][0-9][0-9]|50[0-9]|51[0-2]) compression_Opus="$value" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg target bitrate for $codec must be an integer between 6 and 512 in kilobits per second" ; exit $Ex_Usage ;;
			esac
			;;

		WavPack|WavPackHybrid|WavPackLossy)
			if [ -z "$value" ]; then value="gx1"; fi
			case "$value" in
				x|x[1-6]|g|gx|gx[1-6]|f|fx|fx[1-6]|h|hx|hx[1-6]|hh|hhx|hhx[1-6]) compression_WavPack="$value" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg compression level for $codec must be a combination of [f|g|h|hh][x[1-6]]" ; exit $Ex_Usage ;;
			esac
			;;
	esac
}

getConstantBitrate () {
	local codec="$1" bitrate="$2" source="$3" errormsg

	if [ -n "$source" ]; then
		errormsg="Configuration error (caudecrc):"
	else
		errormsg="$Self_Name -b:"
	fi

	case "$codec" in
		AAC)
			if [ -z "$bitrate" ]; then bitrate=128; fi # ffmpeg default
			case "$bitrate" in
				64|6[5-9]|[7-9][0-9]|[1-2][0-9][0-9]|3[0-1][0-9]|320) bitrate_AAC="$bitrate" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg constant bitrate for $codec must be an integer between 64 and 320 in kilobits per second" ; exit $Ex_Usage ;;
			esac
			;;

		MP3)
			if [ -z "$bitrate" ]; then bitrate=128; fi # LAME default
			case "$bitrate" in
				1[6-9]|[2-9][0-9]|[1-2][0-9][0-9]|3[0-1][0-9]|320) bitrate_MP3="$bitrate" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg constant bitrate for $codec must be an integer between 16 and 320 in kilobits per second" ; exit $Ex_Usage ;;
			esac
			;;

		OggVorbis)
			if [ -z "$bitrate" ]; then bitrate=96; fi # oggenc default
			case "$bitrate" in
				3[2-9]|[4-9][0-9]|[1-4][0-9][0-9]|500) bitrate_OggVorbis="$bitrate" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg target bitrate for $codec must be an integer between 32 and 500 in kilobits per second" ; exit $Ex_Usage ;;
			esac
			;;

		Opus)
			if [ -z "$bitrate" ]; then bitrate=96; fi # opusenc default
			case "$bitrate" in
				[6-9]|[1-9][0-9]|[1-4][0-9][0-9]|50[0-9]|51[0-2]) bitrate_Opus="$bitrate" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg target bitrate for $codec must be an integer between 6 and 512 in kilobits per second" ; exit $Ex_Usage ;;
			esac
			;;

		WavPackHybrid|WavPackLossy) getAverageBitrate "$codec" "$bitrate" "$source" ;; # for backwards compatibility
	esac
}

getAverageBitrate () {
	local codec="$1" bitrate="$2" source="$3" errormsg

	if [ -n "$source" ]; then
		errormsg="Configuration error (caudecrc):"
	else
		errormsg="$Self_Name -B:"
	fi

	case "$codec" in
		AAC)
			if [ -z "$bitrate" ]; then bitrate=128; fi # ffmpeg default
			case "$bitrate" in
				64|6[5-9]|[7-9][0-9]|[1-2][0-9][0-9]|3[0-1][0-9]|320) average_bitrate_AAC="$bitrate" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg average bitrate for $codec must be an integer between 64 and 320 in kilobits per second" ; exit $Ex_Usage ;;
			esac
			;;

		MP3)
			if [ -z "$bitrate" ]; then bitrate=128; fi # LAME default
			case "$bitrate" in
				[8-9]|[1-9][0-9]|[1-2][0-9][0-9]|30[0-9]|310) average_bitrate_MP3="$bitrate" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg average bitrate for $codec must be an integer between 8 and 310 in kilobits per second" ; exit $Ex_Usage ;;
			esac
			;;

		OggVorbis)
			if [ -z "$bitrate" ]; then bitrate=96; fi # oggenc default
			case "$bitrate" in
				3[2-9]|[4-9][0-9]|[1-4][0-9][0-9]|500) average_bitrate_OggVorbis="$bitrate" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg average bitrate for $codec must be an integer between 32 and 500 in kilobits per second" ; exit $Ex_Usage ;;
			esac
			;;

		Opus)
			if [ -z "$bitrate" ]; then bitrate=96; fi # opusenc default
			case "$bitrate" in
				[6-9]|[1-9][0-9]|[1-4][0-9][0-9]|50[0-9]|51[0-2]) average_bitrate_Opus="$bitrate" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg average bitrate for $codec must be an integer between 6 and 512 in kilobits per second" ; exit $Ex_Usage ;;
			esac
			;;

		WavPackHybrid|WavPackLossy)
			if [ -z "$bitrate" ]; then bitrate=256; fi # WavPack default
			case "$bitrate" in
				[2-9]|[2-9].[0-9]|1[0-9]|1[0-9].[0-9]|2[0-3]|2[0-3].[0-9]) average_bitrate_WavPackLossy="$bitrate" ;;
				2[4-9]|[2-9][0-9]|[1-9][0-9][0-9]|[1-8][0-9][0-9][0-9]|9[0-5][0-9][0-9]|9600) average_bitrate_WavPackLossy="$bitrate" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$errormsg target bitrate for $codecodec must be a float between 2.0 and 23.9 in bits per sample, or an integer between 24 and 9600 in kilobits per second" ; exit $Ex_Usage ;;
			esac
			;;
	esac
}

getBitrateMode () {
	local codec="$1" mode="$2"

	case "$mode" in
		cbr|abr|vbr) mode="$( echo "$mode" | tr '[:lower:]' '[:upper:]' )" ;;
		CBR|ABR|VBR) true ;;
		'') mode='VBR' ;;
		*) printMessage 'error' 'usage' 'bad_value' "Configuration error (caudecrc): bitrate mode for $codec must be one of VBR, ABR or CBR" ; exit $Ex_Usage ;;
	esac

	case "$codec" in
		AAC)
			if [ "$mode" != "CBR" -a "$mode" != "ABR" ]; then
				printMessage 'error' 'usage' 'bad_value' "Configuration error (caudecrc): bitrate mode for $codec must be one of ABR or CBR"
				exit $Ex_Usage
			else
				AAC_MODE="$mode"
			fi
			;;
		MP3) MP3_MODE="$mode" ;;
		OggVorbis) OggVorbis_MODE="$mode" ;;
		Opus) Opus_MODE="$mode" ;;
	esac
}

cleanExit () {
	local exitCode=$1 nLines swapDirBasename ioLockFile

	if [ -n "$CAUDECDEBUG" -a "$verbose" = 'true' -a "$outputMode" != 'machine' -a $exitCode -ne $Ex_Ok -a $exitCode -ne $Ex_Interrupt -a -e "$Self_Errors_File" ]; then
		nLines="$( cat "$Self_Errors_File" 2>/dev/null | wc -l | tr -cd '0-9' )"
		if [ $nLines -gt 0 ]; then
			echo -e "\nError Log:\n================================================================================" 1>&2
			cat "$Self_Errors_File" 1>&2
		fi
	fi

	if [ -n "$Self_Swap_Dir" ]; then
		if [ -h "$Self_Swap_Dir" ]; then
			rm -rf "$( readlink -f "$Self_Swap_Dir" )"
		else
			rm -rf "$Self_Swap_Dir"
		fi
	fi

	if [ "$preloadSources" = 'true' ]; then
		# FIXME
		for ioLockFile in "$Self_Instance_Dir"/ioLockFiles/* ; do
			if [ -e "$ioLockFile" ]; then
				echo '' > "${Self_Io_Dir}/${ioLockFile##*/}.lock" 2>/dev/null
				mv "${Self_Io_Dir}/${ioLockFile##*/}.lock" "${Self_Io_Dir}/${ioLockFile##*/}" 1>/dev/null 2>&1
			fi
		done
	fi

	test -d "$Self_Instance_Dir" && rm -rf "$Self_Instance_Dir"

	exit $exitCode
}

cleanAbort () {
	echo
	printMessage 'abort'
	kill $( jobs -p ) 1>/dev/null 2>&1
	cleanExit $Ex_Interrupt
}

findInputFiles () {
	local location="$1"

	if [ "$gnufind" = 'true' ]; then
		$findcmd "$location" -type f -regextype 'posix-egrep' -regex '.*\.(wav|aiff|caf|flac|wv|ape|mp3|m4a|ogg|opus)$' -print0 2>/dev/null
	else
		$findcmd -E "$location" -type f -regex '.*\.(wav|aiff|caf|flac|wv|ape|mp3|m4a|ogg|opus)$' -print0 2>/dev/null
	fi
}

getInputFiles () {
	local exitCode=$Ex_Ok inputDir line fileIndex=0 fileOrDir file fileExtension

	for fileOrDir in "${inputFilesAndDirs[@]}"; do
		if [ -d "$fileOrDir" ]; then
			{
			if [ -r "$fileOrDir" ]; then
				while IFS= read -d $'\0' -r file ; do
					if [ -e "$file" ]; then
						inputFiles[$fileIndex]="$file"
						fileExtension="${fileOrDir##*.}"
						if [ "$fileExtension" != "opus" ]; then
							allFilesAreOpus='false'
						fi
						if [ "$fileExtension" = "wvc" ]; then
							continue
						fi
						(( fileIndex++ ))
					fi
				done < <( findInputFiles "$fileOrDir" )
			else
				printMessage 'warning' 'usage' 'filesystem' "path:${fileOrDir}" 'directory is not readable (permission denied).' ; exitCode=$Ex_No_Input
			fi
			} 2>/dev/null || exitCode=$Ex_Io_Err
			if [ $exitCode -eq $Ex_Io_Err ]; then
				printMessage 'warning' 'usage' 'filesystem' "the operating system cannot handle this many files."
			fi
			if [ $exitCode -ne $Ex_Ok ]; then
				printMessage 'abort' 'verbose'
				cleanExit $exitCode
			fi
		else
			fileExtension="${fileOrDir##*.}"
			if [ "$fileExtension" != "opus" ]; then
				allFilesAreOpus='false'
			fi
			if [ "$fileExtension" = "wvc" ]; then
				continue
			fi
			inputFiles[$fileIndex]="$fileOrDir"
			(( fileIndex++ ))
		fi
	done

	unset inputFilesAndDirs
	if [ $exitCode -eq $Ex_Ok ]; then
		numberOfInputFiles=$fileIndex
		return $Ex_Ok
	else
		printMessage 'abort' 'verbose'
		cleanExit $exitCode
	fi
}

checkInputFiles () {
	local exitCode=$Ex_Ok inputFile fileIndex=0 inputDirName commonFileExtension inputFileExtension
	local inputCodecsAreAllTheSame='true' cdpath pdpath addToSourceFiles dateSourceFile outputCodec copyPath codec

	if [ $numberOfInputFiles -gt $maxInputFiles ]; then
		printMessage 'warning' 'usage' 'quota' "the number of input files ($numberOfInputFiles) is greater than maxInputFiles=${maxInputFiles}."
		printMessage 'abort'
		cleanExit $Ex_Usage
	fi

	for inputFile in "${inputFiles[@]}" ; do
		addToSourceFiles='false'
		inputDirName="${inputFile%/*}"
		if [ ! -e "$inputFile" ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${inputFile}" 'no such file.' ; exitCode=$Ex_No_Input
		elif [ ! -f "$inputFile" ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${inputFile}" 'not a regular file.' ; exitCode=$Ex_Data_Err
		elif [ ! -r "$inputFile" ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${inputFile}" 'cannot open file for reading (permission denied).' ; exitCode=$Ex_No_Input
		elif [ ! -w "$inputFile" -a "$computeReplayGain" = 'true' ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${inputFile}" 'cannot open file for writing (permission denied).' ; exitCode=$Ex_Cant_Create
		elif [ ! -w "$inputFile" -a "$reverseReplayGain" = 'true' ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${inputFile}" 'cannot open file for writing (permission denied).' ; exitCode=$Ex_Cant_Create
		elif [ ! -r "$inputFile" -a "$displayInternalHash" = 'true' ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${inputFile}" 'cannot open file for reading (permission denied).' ; exitCode=$Ex_No_Input
		elif [ ! -w "$inputFile" -a "$touchFiles" = 'true' ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${inputFile}" 'refusing to touch file that is read-only.' ; exitCode=$Ex_Cant_Create
		else

			if [ -n "$outputCodecs" ]; then # transcode
				for outputCodec in $outputCodecs; do
					getOutputCodecDestFile "$inputFile" "$outputCodec"
					copyPath="$( copyPathOrNot "$outputCodec" )"
					if [ "$copyPath" = 'true' ]; then
						cdpath='/./' pdpath='/../'
						if [ "${inputFile:0:2}" = './' -o "${inputFile:0:3}" = '../' -o "$inputDirName" != "${inputDirName//$cdpath/@}" -o "$inputDirName" != "${inputDirName//$pdpath/@}" ]; then
							printMessage 'warning' 'usage' 'filesystem' "path:${inputFile}" "can't use paths containing ./ or ../ with caudec -P." ; exitCode=$Ex_Usage
							continue
						fi
					fi

					case "$inputFile" in
						*.wav|*.aiff|*.caf|*.flac|*.wv|*.ape|*.m4a)
							addToSourceFiles='true'
							case "$inputFile" in
								*.m4a)
									codec="$( ffprobe -v error -select_streams a:0 -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 "$inputFile" 2>/dev/null )"
									if [ "$codec" != "alac" ]; then
										addToSourceFiles='false'
										printMessage 'warning' 'processing' 'unsupported' "file:${inputFile}" "refusing to transcode from lossy codec ($codec)." ; exitCode=$Ex_Data_Err
									fi
									;;
							esac
							if [ "$addToSourceFiles" = 'false' ]; then continue ; fi
							if [ "$keepExistingFiles" = 'true' ]; then
								if [ -e "$destFile" ]; then
									addToSourceFiles='false'
									printMessage 'warning' 'usage' 'filesystem' 'verbose' "-k: \"$destFile\" exists already."
								fi
							fi
							if [ "$keepNewerFiles" = 'true' ]; then
								if [ -e "$destFile" ]; then
									if isFileNewer "$destFile" "$inputFile"; then
										addToSourceFiles='false'
										if [ "$gnudate" = 'true' ]; then
											dateSourceFile="$( $datecmd --date="@"$( $statcmd -c '%Y' "$inputFile" )"" "+%Y-%m-%d %H:%M:%S" )"
											dateDestFile="$( $datecmd --date="@"$( $statcmd -c '%Y' "$destFile" )"" "+%Y-%m-%d %H:%M:%S" )"
										else
											dateSourceFile="$( $datecmd -r $( $statcmd -f '%c' "$inputFile" ) "+%Y-%m-%d %H:%M:%S" )"
											dateDestFile="$( $datecmd -r $( $statcmd -f '%c' "$destFile" ) "+%Y-%m-%d %H:%M:%S" )"
										fi
										printMessage 'warning' 'usage' 'filesystem' 'verbose' "-K: \"$destFile\" is newer that the source."
									fi
								else
									addToSourceFiles='true'
								fi
							fi
							;;

						*)
							if [ "$ignoreUnsupportedFiles" = 'false' ]; then
								printMessage 'warning' 'processing' 'unsupported' "file:${inputFile}" 'unsupported format.'
								exitCode=$Ex_Data_Err
								continue
							fi
							;;
					esac
				done
			fi

			if [ "$displayInternalHash" = 'true' ]; then
				case "$inputFile" in
					*.flac|*.wv) addToSourceFiles='true' ;;
					*)
						if [ "$ignoreUnsupportedFiles" = 'true' ]; then
							continue
						else
							printMessage 'warning' 'processing' 'unsupported' "file:${inputFile}" 'unsupported format.' ; exitCode=$Ex_Data_Err ; continue
						fi
						;;
				esac
			elif [ "$checkFiles" = 'true' ]; then
				case "$inputFile" in
					*.flac|*.wv|*.ape) addToSourceFiles='true' ;;
					*)
						if [ "$ignoreUnsupportedFiles" = 'true' ]; then
							continue
						else
							printMessage 'warning' 'processing' 'unsupported' "file:${inputFile}" 'unsupported format.' ; exitCode=$Ex_Data_Err ; continue
						fi
						;;
				esac
			fi

			if [ "$showInformation" = 'true' ]; then
				case "$inputFile" in
					*.flac|*.wv|*.ape|*.m4a|*.mp3|*.ogg|*.opus) addToSourceFiles='true' ;;
					*)
						if [ "$ignoreUnsupportedFiles" = 'true' ]; then
							continue
						else
							printMessage 'warning' 'processing' 'unsupported' "file:${inputFile}" 'unsupported format.' ; exitCode=$Ex_Data_Err ; continue
						fi
						;;
				esac
			fi

			if [ "$computeReplayGain" = 'true' -o "$reverseReplayGain" = 'true' ]; then
				inputFileExtension="${inputFile##*.}"
				case "$inputFileExtension" in
					flac|wv|ape|ogg|opus|mp3)
						addToSourceFiles='true'
						if [ -z "$commonFileExtension" ]; then
							commonFileExtension="$inputFileExtension"
						elif [ "$inputFileExtension" != "$commonFileExtension" ]; then
							inputCodecsAreAllTheSame='false'
							addToSourceFiles='false'
							if [ "$ignoreUnsupportedFiles" = 'false' ]; then
								printMessage 'error' 'usage' 'filesystem' "file:${inputFile}" "all files must have the same file extension"
							fi
							exitCode=$Ex_Data_Err
							continue
						fi
						;;

					*)
						if [ "$ignoreUnsupportedFiles" = 'false' ]; then
							printMessage 'warning' 'processing' 'unsupported' "file:${inputFile}" 'unsupported format.'
						fi
						exitCode=$Ex_Data_Err
						continue
						;;
				esac
			fi

			if [ "$applyGain" = 'true' ]; then
				case "$inputFile" in
					*.mp3) addToSourceFiles='true' ;;
					*)
						if [ "$ignoreUnsupportedFiles" = 'false' ]; then
							printMessage 'warning' 'processing' 'unsupported' "file:${inputFile}" 'unsupported format.'
						fi
						exitCode=$Ex_Data_Err
						continue
						;;
				esac
			fi

			if [ "$touchFiles" = 'true' ]; then
				addToSourceFiles='true'
			fi
		fi

		if [ "$addToSourceFiles" = 'true' ]; then
			sourceFiles[$fileIndex]="$inputFile"
			(( fileIndex++ ))
		fi
	done

	unset inputFiles
	numberOfSourceFiles=$fileIndex

	if [ $exitCode -ne $Ex_Ok ]; then
		printMessage 'abort'
		cleanExit $exitCode
	elif [ $numberOfSourceFiles -eq 0 ]; then
		if [ "$keepExistingFiles" = 'true' ]; then
			printMessage 'warning' 'usage' 'filesystem' 'verbose' "-k: all or some destination files exist already, nothing to do."
		elif [ "$keepNewerFiles" = 'true' ]; then
			printMessage 'warning' 'usage' 'filesystem' 'verbose' "-K: all or some destination files are newer than their source, nothing to do."
		fi
		printMessage 'warning' 'usage' 'filesystem' 'verbose' "no supported files to work with, nothing to do."
		printMessage 'abort' 'verbose'
		cleanExit $exitCode
	else
		return $Ex_Ok
	fi
}

checkOutputDirectories () {
	local exitCode=$Ex_Ok outputCodec codecFullName codecDestDir

	for outputCodec in $outputCodecs; do
		codecFullName="$( getCodecFullName "$outputCodec" )"
		codecDestDir="$( getDestDir "$outputCodec" )"
		if [ ! -e "$codecDestDir" ]; then
			if ! mkdir -p "$codecDestDir" 1>/dev/null 2>&1 ; then
				printMessage 'error' 'usage' 'filesystem' "path:${codecDestDir}" "$Self_Name -O/P: failed to create directory, do you have write permissions? ($codecFullName)"
				exitCode=$Ex_Cant_Create
			fi
		elif [ ! -d "$codecDestDir" ]; then
			if [ "$codecDestDir" = "$defaultDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${codecDestDir}" "$Self_Name: not a directory ($codecFullName)."
				exitCode=$Ex_Cant_Create
			else
				printMessage 'error' 'usage' 'filesystem' "path:${codecDestDir}" "$Self_Name -O/P: not a directory ($codecFullName)"
				exitCode=$Ex_Cant_Create
			fi
		elif [ ! -w "$codecDestDir" ]; then
			if [ "$codecDestDir" = "$defaultDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${codecDestDir}" "$Self_Name: permission denied, not writable ($codecFullName)"
				exitCode=$Ex_Cant_Create
			else
				printMessage 'error' 'usage' 'filesystem' "path:${codecDestDir}" "$Self_Name -O/P: permission denied, not writable ($codecFullName)"
				exitCode=$Ex_Cant_Create
			fi
		fi
	done

	if [ $exitCode -ne $Ex_Ok ]; then
		cleanExit $exitCode
	fi
}

checkBinary () {
	local exitCode=$Ex_Ok binary listOfBinaries="$@" pattern foundBinaries

	for binary in $listOfBinaries; do
		pattern="x${binary}Y"
		if [ "$searchedBinaries" = "${searchedBinaries//$pattern/@}" ]; then # search for binary hasn't been done before
			searchedBinaries="${searchedBinaries}${pattern}" # make sure we don't check twice for nothing
			if which "$binary" 1>/dev/null 2>&1 ; then
				foundBinaries="${foundBinaries}${pattern}"
				continue
			else
				binaryMissing='true'
				exitCode=$Ex_Ko
				if [ "$binary" = "opusgain" ]; then
					printMessage 'warning' 'initialization' 'filesystem' "Binary \"${binary}\" not found. Make sure it is in your \$PATH, and that you've upgraded it to the latest available version. You may find it at https://github.com/FrancisRussell/zoog"
				elif [ "$binary" = "rsgain" ]; then
					printMessage 'warning' 'initialization' 'filesystem' "Binary \"${binary}\" not found. Make sure it is in your \$PATH, and that you've upgraded it to the latest available version. You may find it at https://github.com/complexlogic/rsgain"
				else
					printMessage 'warning' 'initialization' 'filesystem' "Binary \"${binary}\" not found. Make sure it is in your \$PATH, and that you've upgraded it to the latest available version."
				fi
			fi
		elif [ -z "$foundBinaries" -o "$foundBinaries" = "${foundBinaries//$pattern/@}" ]; then
			# binary was previously searched, but not found
			exitCode=$Ex_Ko
		fi
	done

	return $exitCode
}

checkMainBinaries () {
	local exitCode=$Ex_Ok

	if ! which 'which' 1>/dev/null 2>&1 ; then
		printMessage 'warning' 'initialization' 'filesystem' "Binary \"which\" not found. Make sure it is in your \$PATH."
		printMessage 'abort'
		cleanExit $Ex_Os_File
	fi

	checkBinary 'bc' 'cut' 'date' 'find' 'grep' 'head' 'mktemp' 'ps' 'sed' 'sort' 'soxi' 'stat' 'tail' 'tr' 'uname' 'wc' 'xargs' || exitCode=$Ex_Os_File
	checkBinary "$datecmd" "$findcmd" "$sedcmd" # FIXME

	if [ $exitCode -ne $Ex_Ok ]; then
		printMessage 'abort'
		cleanExit $Ex_Os_File
	else
		return $exitCode
	fi
}

checkBinaries () {
	local exitCode=$Ex_Ok sourceFile hash outputCodec

	searchedBinaries=''
	binaryMissing='false'
	if ! which 'which' 1>/dev/null 2>&1 ; then
		printMessage 'warning' 'initialization' 'filesystem' "Binary \"which\" not found. Make sure it is in your \$PATH."
		printMessage 'abort'
		cleanExit $Ex_Os_File
	fi

	for sourceFile in "${sourceFiles[@]}" ; do
		case "$sourceFile" in
			*.ape|*.m4a) checkBinary 'ffprobe' ;;
		esac
	done

	if [ "$computeReplayGain" = 'true' ]; then
		for sourceFile in "${sourceFiles[@]}" ; do
			case "$sourceFile" in
				*.flac) checkBinary 'metaflac' ;;
				*.wv) checkBinary 'wvunpack' 'wvgain' 'wvtag' ;;
				*.ape) checkBinary 'rsgain' 'APEv2' ;;
				*.ogg) checkBinary 'ogginfo' 'vorbisgain' 'vorbiscomment' ;;
				*.mp3) checkBinary 'ffprobe' 'mp3gain'; if [ "$applyGain" = 'false' ]; then checkBinary 'eyeD3'; fi ;;
				*.opus) checkBinary 'opusinfo' 'opusgain' ;; # https://github.com/FrancisRussell/zoog
			esac
		done
	elif [ "$reverseReplayGain" = 'true' ]; then
		for sourceFile in "${sourceFiles[@]}" ; do
			case "$sourceFile" in
				*.flac) checkBinary 'metaflac' ;;
				*.wv) checkBinary 'wvtag' ;;
				*.ape) checkBinary 'APEv2' ;;
				*.ogg) checkBinary 'vorbiscomment' ;;
				*.opus) checkBinary 'opusgain' ;;
				*.mp3) checkBinary 'mp3gain' ;;
			esac
		done
	elif [ "$checkFiles" = 'true' ]; then
		checkBinary 'sox'
		for sourceFile in "${sourceFiles[@]}" ; do
			case "$sourceFile" in
				*.flac) checkBinary 'flac' 'metaflac' ;;
				*.wv) checkBinary 'wvunpack' ;;
				*.ape) checkBinary 'mac' ;;
			esac
		done
	elif [ "$touchFiles" = 'true' ]; then
		for sourceFile in "${sourceFiles[@]}" ; do
			case "$sourceFile" in
				*.flac) checkBinary 'metaflac' ;;
				*.ogg) checkBinary 'ogginfo' 'vorbiscomment' ;;
				*.m4a) checkBinary 'ffmpeg' 'ffprobe' ;;
				*.opus) checkBinary 'opusinfo' ;;
				*.wv) checkBinary 'wvtag' 'wvunpack' ;;
				*.ape) checkBinary 'mac' 'APEv2' 'ffprobe' ;;
				*.mp3) checkBinary 'ffmpeg' ;;
			esac
		done
	elif [ "$showInformation" = 'true' ]; then
		for sourceFile in "${sourceFiles[@]}" ; do
			case "$sourceFile" in
				*.flac) checkBinary 'metaflac' 'ffprobe' ;;
				*.wv) checkBinary 'wvunpack' ;;
				*) checkBinary 'ffprobe' ;;
			esac
		done
	elif [ "$displayInternalHash" = 'true' ]; then
		for sourceFile in "${sourceFiles[@]}" ; do
			case "$sourceFile" in
				*.flac) checkBinary 'metaflac' ;;
				*.wv) checkBinary 'wvunpack' ;;
			esac
		done
	else # transcode
		for sourceFile in "${sourceFiles[@]}" ; do
			case "$sourceFile" in
				*.aiff|*.caf) checkBinary 'sox' ;;
				*.flac) checkBinary 'flac' 'metaflac' ;;
				*.wv) checkBinary 'wvunpack' 'APEv2' ;;
				*.ape) checkBinary 'mac' 'APEv2' ;;
				*.m4a) checkBinary 'ffmpeg' ;;
			esac
		done

		if [ "$applyGain" = 'true' ]; then
			checkBinary 'sox'
		fi
	fi

	for outputCodec in $outputCodecs; do
		case "$outputCodec" in
			AIFF|CAF) checkBinary 'sox' ;;
			FLAC) checkBinary 'flac' ;;
			WavPack|WavPackHybrid|WavPackLossy) checkBinary 'wavpack' 'APEv2' ;;
			MonkeysAudio) checkBinary 'mac' 'APEv2' ;;
			lossyFLAC) checkBinary 'lossywav' 'sox' 'soxi' 'flac' ;;
			OggVorbis) checkBinary 'oggenc' ;;
			MP3) checkBinary 'lame' 'eyeD3' ;;
			AAC|ALAC) checkBinary 'ffmpeg' ;;
			Opus) checkBinary 'opusenc' ;;
		esac
	done

	if [ -n "$bitDepth" -o -n "$samplingRate" -o "$convertToStereo" != 'false' ]; then
		checkBinary 'sox'
	fi

	if [ "$binaryMissing" = 'true' ]; then
		printMessage 'abort'
		cleanExit $Ex_Os_File
	else
		return $exitCode
	fi
}

adjustNumberOfProcesses () {
	local numberOfFiles=$1 processNumber

	if [ $numberOfFiles -lt $nProcesses ]; then
		nProcesses=$numberOfFiles
	fi

	for (( processNumber=0 ; processNumber < nProcesses; processNumber++ )); do
		touch "${Self_Jobs_Dir}/process.${processNumber}" 1>/dev/null 2>&1
	done
}

isProcessRunning () {
	if ps "$1" 1>/dev/null 2>&1 ; then
		return $Ex_Ok
	else
		return $Ex_Ko
	fi
}

cleanUpInstances () {
	local pid tdir lockFile

	for d in "${Self_Pid_Dir}/instance".???????? ; do
		if [ -d "$d" -a -f "${d}/PID" ]; then
			pid="$( cat "${d}/PID" 2>/dev/null )"
			if ! isProcessRunning $pid ; then
				tdir="$( cat "${d}/tdir" 2>/dev/null )"
				if [ -d "$tdir" ]; then
					rm -rf "$tdir" 1>/dev/null 2>&1
				fi
				rm -rf "$d" 1>/dev/null 2>&1
			fi
		fi
	done

	if [ "$preloadSources" = 'true' ]; then
		for lockFile in "${Self_Io_Dir}"/*.lock ; do
			if [ -f "$lockFile" ]; then
				cleanUpCopyLockFile "${lockFile%.lock}"
			fi
		done
	fi
}

handleInstance () {
	local mktempDir nRunningInstances=1

	# Temporary dirs:
	# ${TMPDIR}/caudec.XXXXXXXX
	# ${TMPDIR}/caudec.XXXXXXXX/control/
	# ${TMPDIR}/caudec.XXXXXXXX/data/
	# ${TMPDIR}/caudec.XXXXXXXX/io/
	# ${TMPDIR}/caudec.XXXXXXXX/jobs/
	# ${TMPDIR}/caudec.XXXXXXXX/PID
	# ${TMPDIR}/caudec.XXXXXXXX/swap/

	if [ -n "$TMPDIR" ]; then mktempDir="$TMPDIR"; else mktempDir='/tmp'; fi

	if [ ! -d "$mktempDir" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${mktempDir}" "couldn't create directory."
		printMessage 'abort'
		cleanExit $Ex_Cant_Create
	elif [ ! -w "$mktempDir" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${mktempDir}" "directory is not writable (permission denied)."
		printMessage 'abort'
		cleanExit $Ex_No_Perm
	fi
	Self_Tmp_Dir="$mktempDir"

	Self_Instance_Dir="$( mktemp -d -p "$Self_Tmp_Dir" "${Self_Name}.XXXXXXXX" 2>/dev/null )"
	if [ -z "$Self_Instance_Dir" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${Self_Instance_Dir}" "mktemp failed to create a directory (do you have write permissions?)."
		printMessage 'abort'
		cleanExit $Ex_Os_Err
	elif [ ! -w "$Self_Instance_Dir" ]; then
		printMessage 'warning' 'initialization' 'filesystem' "path:${Self_Instance_Dir}" "directory is not writable (permission denied)."
		printMessage 'abort'
		cleanExit $Ex_No_Perm
	fi
	chmod "$Self_Permissions" "$Self_Instance_Dir"

	Self_Random_Suffix="${Self_Instance_Dir##*.}"
	Self_Control_Dir="${Self_Instance_Dir}/control"
	Self_Data_Dir="${Self_Instance_Dir}/data"
	Self_Errors_File="${Self_Instance_Dir}/errors.txt"
	Self_Io_Dir="${Self_Instance_Dir}/io"
	Self_Jobs_Dir="${Self_Instance_Dir}/jobs"
	Self_Pid_File="${Self_Instance_Dir}/pid.txt"
	Self_Swap_Dir="${Self_Instance_Dir}/swap"
	mkdir -m "$Self_Permissions" -p "$Self_Control_Dir" "$Self_Data_Dir" "$Self_Io_Dir" "$Self_Jobs_Dir" 1>/dev/null 2>&1 || cleanExit $Ex_Temp_Fail
	echo "$$" > "${Self_Pid_File}" 1>/dev/null 2>&1 || cleanExit $Ex_Temp_Fail
	touch "$Self_Errors_File" 1>/dev/null 2>&1 || cleanExit $Ex_Temp_Fail
	echo -n "0" > "${Self_Data_Dir}/readTimes.txt" 1>/dev/null 2>&1 || cleanExit $Ex_Temp_Fail

	nRunningInstances="$( getNumberOfCaudecInstances )"
	if [ $nRunningInstances -gt $maxInstances ]; then
		printMessage 'warning' 'usage' 'quota' "Too many instances of caudec are already running."
		printMessage 'info' 'stderr' "You might want to increase the 'maxInstances' value in /etc/caudecrc or ~/.caudecrc."
		printMessage 'abort'
		cleanExit $Ex_Temp_Fail
	fi
}

createControlFiles () {
	local jobIndex=$1 filesPerJob=$2 fileIndex paddedFileIndex threadIndex fileMilliseconds outputCodec

	for (( threadIndex=0; threadIndex < filesPerJob; threadIndex++ )); do
		fileIndex=$(( jobIndex * filesPerJob + threadIndex ))
		if [ $fileIndex -ge $numberOfSourceFiles ]; then
			return
		fi
		paddedFileIndex="$( printf "%03i" $fileIndex )"
		touch "${Self_Control_Dir}/${paddedFileIndex}_any.job"

		fileMilliseconds="$( getFileMilliseconds "${sourceFiles[$fileIndex]}" 2>> "$Self_Errors_File" )"
		echo "$fileMilliseconds $paddedFileIndex $fileIndex" > "${Self_Data_Dir}/${paddedFileIndex}.ms"

		for outputCodec in $outputCodecs; do
			# touch "${Self_Control_Dir}/${paddedFileIndex}_${outputCodec}.job"
			touch "${Self_Control_Dir}/${paddedFileIndex}_needsWAV_${outputCodec}.info"
			touch "${Self_Control_Dir}/${paddedFileIndex}_encoding_${outputCodec}.job"
		done
	done
}

setupControlDir () {
	local fileIndex maxThreads filesPerJob threadIndex

	maxThreads=$(( maxProcessesSetByUser * 2 ))
	if [ $maxThreads -ge $numberOfSourceFiles ]; then
		maxThreads=$numberOfSourceFiles
		filesPerJob=1
	elif [ $maxThreads -lt $numberOfSourceFiles ]; then\
		filesPerJob="$( printf "%.0f" "$( echo "scale=3; $numberOfSourceFiles / $maxThreads + (1 / 2)" | bc )" )"
	fi
	for (( threadIndex=0; threadIndex < maxThreads; threadIndex++ )); do
		createControlFiles "$threadIndex" "$filesPerJob" &
	done
	for threadIndex in $( jobs -p ); do wait $threadIndex || exitCode=$Ex_Ko ; done

	if [ $exitCode -eq $Ex_Ko ]; then
		wait
		cleanExit $exitCode
	fi

	case "$orderStrategy" in
		longest) sort -n -r "${Self_Data_Dir}/"*.ms > "${Self_Data_Dir}/millisecondsAndFileIndexes.list" ;;
		shortest) sort -n "${Self_Data_Dir}/"*.ms > "${Self_Data_Dir}/millisecondsAndFileIndexes.list" ;;
		*) cat "${Self_Data_Dir}/"*.ms > "${Self_Data_Dir}/millisecondsAndFileIndexes.list" ;;
	esac
}


setupSwapDir () {
	local swapDir="$Self_Swap_Dir" index copyLockFile fileMilliseconds

	# Backwards compatibility with caudec < 4.0.0
	if [ -n "$CAUDECDIR" -a -z "$CAUDEC_SWAP_DIR" ]; then
		CAUDEC_SWAP_DIR="$CAUDECDIR"
	fi

	if [ -n "$CAUDEC_SWAP_DIR" ]; then
		if [ "$CAUDEC_SWAP_DIR" != '/' ]; then
			CAUDEC_SWAP_DIR="${CAUDEC_SWAP_DIR%/}" # remove trailing slash
		fi
		if [ "${CAUDEC_SWAP_DIR:0:1}" != '/' ]; then # if not an absolute path, prepend current dir
			CAUDEC_SWAP_DIR="${PWD}/${CAUDEC_SWAP_DIR}"
		fi

		if [ ! -e "$CAUDEC_SWAP_DIR" ]; then
			printMessage 'warning' 'initialization' 'filesystem' "path:${CAUDEC_SWAP_DIR}" "CAUDEC_SWAP_DIR doesn't exist."
			printMessage 'abort'
			cleanExit $Ex_Os_File
		elif [ ! -d "$CAUDEC_SWAP_DIR" ]; then
			printMessage 'warning' 'initialization' 'filesystem' "path:${CAUDEC_SWAP_DIR}" "CAUDEC_SWAP_DIR is not a directory."
			printMessage 'abort'
			cleanExit $Ex_Cant_Create
		elif [ ! -w "$CAUDEC_SWAP_DIR" ]; then
			printMessage 'warning' 'initialization' 'filesystem' "path:${CAUDEC_SWAP_DIR}" "CAUDEC_SWAP_DIR is not writable (permission denied)."
			printMessage 'abort'
			cleanExit $Ex_No_Perm
		fi

		mkdir -m "$Self_Permissions" -p "${CAUDEC_SWAP_DIR}.${Self_Random_Suffix}" 1>/dev/null || cleanExit $Ex_Cant_Create
		ln -s "${CAUDEC_SWAP_DIR}.${Self_Random_Suffix}" "$Self_Swap_Dir"
	else
		mkdir -m "$Self_Permissions" -p "${Self_Swap_Dir}" 1>/dev/null || cleanExit $Ex_Cant_Create
	fi

	# FIXME: this should go to io dir
	if [ "$preloadSources" = 'true' ]; then
		for (( index=0; index < ${#sourceFiles[@]}; index++ )); do
			if [ "$gnustat" = 'true' ]; then
				copyLockFile="${Self_Io_Dir}/$( $statcmd -c '%d' "${sourceFiles[$index]}" 2>> "$Self_Errors_File" )"
			else
				copyLockFile="${Self_Io_Dir}/$( $statcmd -f '%d' "${sourceFiles[$index]}" 2>> "$Self_Errors_File" )"
			fi
			if [ ! -e "${copyLockFile}.lock" ]; then
				touch "$copyLockFile"
			fi
		done
	fi
}

getNumberOfChannels () {
	local file="$1" numberOfChannels=0

	case "$file" in
		*.wav|*.aiff|*.caf) numberOfChannels="$( soxi -c "$file" 2>/dev/null )" ;;
		*.flac) numberOfChannels="$( metaflac --show-channels "$file" 2>/dev/null )" ;;
		*.wv) numberOfChannels="$( wvunpack -f4 "$file" 2>/dev/null )" ;;
		*.ogg) numberOfChannels="$( ogginfo "$file" 2>/dev/null | grep -E "^Channels:" | tr -cd "0-9" )" ;;
		*.opus) numberOfChannels="$( opusinfo "$file" | grep -F "Channels: " | tr -cd "0-9" )" ;;
		*.mp3) numberOfChannels="$( soxi -c "$file" 2>/dev/null | tr -cd "0-9" )" ;;
		*) numberOfChannels="$( ffprobe -print_format 'default' -show_streams -select_streams 'a:0' "$file" 2>/dev/null | grep -F "channels=" | tr -cd "0-9" )" ;;
	esac

	if [ -z "$numberOfChannels" ]; then numberOfChannels=0; fi
	echo "$numberOfChannels"
}

getNumberOfCaudecInstances () {
	local numberOfInstances

	numberOfInstances=$( ls -1d "${Self_Tmp_Dir}/${Self_Name}".* 2>/dev/null | wc -l | tr -cd '0-9' )
	case "$numberOfInstances" in
		[0-9]*) echo $numberOfInstances ;;
		*) echo 1 ;;
	esac
}

getNumberOfCaudecProcesses () {
	local numberOfProcesses

	numberOfProcesses=$( ls -1d "${Self_Jobs_Dir}/process".* 2>/dev/null | wc -l | tr -cd '0-9' )
	case "$numberOfProcesses" in
		[0-9]*) echo $numberOfProcesses ;;
		*) echo 0 ;;
	esac
}

getNumberOfProcessedFiles () {
	local numberOfProcessedFiles
	numberOfProcessedFiles="$( ls -1 "${Self_Control_Dir}"/*"_all_processed.info" 2>/dev/null | wc -l | tr -cd '[:digit:]' )"
	echo $(( numberOfProcessedFiles * nCodecs ))
}

getNumberOfAvailableThreads () {
	local index="$1" maxThreads="$2" nProcessedFiles nAvailableProcesses nMillisecondsLeft=0 nThreads=1

	if [ -z "$maxThreads" ]; then
		maxThreads=999999
	fi

	nProcessedFiles="$( getNumberOfProcessedFiles )"
	nAvailableProcesses=$(( maxProcessesSetByUser - numberOfOutputFiles + nProcessedFiles + 1 ))
	if [ $nAvailableProcesses -lt 2 ]; then
		echo 1
		return
	fi

	while read milliseconds paddedFileIndex fileIndex; do
		test -e "${Self_Control_Dir}/${paddedFileIndex}_all_processed.info" 1>/dev/null 2>/dev/null && continue
		nMillisecondsLeft=$(( nMillisecondsLeft + milliseconds ))
	done < "${Self_Data_Dir}/millisecondsAndFileIndexes.list"

	while read milliseconds paddedFileIndex fileIndex; do
		test -e "${Self_Control_Dir}/${paddedFileIndex}_all_processed.info" 1>/dev/null 2>/dev/null && continue
		if [ "$fileIndex" = "$index" ]; then
			# +0.3 to round up any n value over n.2 even though printf "%.0f" already rounds up anything over n.5
			nThreads="$( printf "%.0f" "$( echo "scale=3; $maxProcessesSetByUser * $milliseconds / $nMillisecondsLeft + 0.3" | bc )" )"
			break
		fi
	done < "${Self_Data_Dir}/millisecondsAndFileIndexes.list"

	if [ $nThreads -lt 1 ]; then
		nThreads=1
	fi
	if [ $nThreads -gt $maxThreads ]; then
		nThreads=$maxThreads
	fi
	echo $nThreads
}


tagline () {
	local IFS=' ' tags switch value pattern nLines ereg=""
	test -e "$destTagFile" || return

	cp "$destTagFile" "${destTagFile}.${outputCodec}"

	if [ -n "$outputCodecs" ]; then
		pattern="x${outputCodec}Y"
		if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then
			rm -f "${destTagFile}.${outputCodec}" ; touch "${destTagFile}.${outputCodec}"
		fi

		case "$outputCodec" in
			lossyFLAC|WavPackLossy|MP3|AAC|ALAC|OggVorbis|Opus)
				grep -viE \
					"^(replaygain_[a-z0-9_]{1,}|r128_[a-z0-9_]{1,}|audio_track_peak|audio_album_peak)=" \
					"${destTagFile}.${outputCodec}" > "${destTagFile}.${outputCodec}.tmp"
				mv "${destTagFile}.${outputCodec}.tmp" "${destTagFile}.${outputCodec}"
				;;
		esac
	fi

	if isWavProcessed ; then # SoX was used on the WAV file for resampling, applying gain, or converting to stereo
		grep -viE \
			'^(replaygain_[a-z0-9_]{1,}|r128_[a-z0-9_]{1,}|audio_track_peak|audio_album_peak)=' \
			"${destTagFile}.${outputCodec}" > "${destTagFile}.${outputCodec}.tmp"
		mv "${destTagFile}.${outputCodec}.tmp" "${destTagFile}.${outputCodec}"
	fi

	if [ -n "$compressionTag" ]; then
		echo "$compressionTag" >> "${destTagFile}.${outputCodec}"
	fi

	nLines="$( cat "${destTagFile}.${outputCodec}" | wc -l | tr -cd '0-9' )"
	if [ $nLines -eq 0 ]; then
		return
	fi

	if [ -n "$1" ]; then
		while read line; do
			tags="${tags}\x00${1}\x00${line}"
		done < "${destTagFile}.${outputCodec}"
	else
		while read switch value; do
			tags="${tags}\x00${switch}\x00${value}"
		done < "${destTagFile}.${outputCodec}"
	fi
	rm -f "${destTagFile}.${outputCodec}"
	printf -- "%s" "${tags//%/%%}" | $sedcmd -e 's#§#\n#g' -e 's@\x02@\\\\x00@g'
}

# http://wiki.xiph.org/Field_names
# http://age.hobba.nl/audio/mirroredpages/ogg-tagging.html
# http://reallylongword.org/vorbiscomment/
# http://wiki.hydrogenaudio.org/index.php?title=APE_key
# http://www.id3.org/id3v2.3.0

# Sanitize track or disc number
getTrackOrDiscNumber () {
	local s="$1"

	s="${s%/*}"
	case "$s" in
		[0-9]|[0-9][0-9]|[0-9][0-9][0-9]|[0-9][0-9][0-9][0-9]) echo "$s" ;;
		*) echo '0' ;;
	esac
}

getTotalDiscsAndTracks () {
	local field value

	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		case "$field" in
			disctotal|totaldiscs)   totalDiscs="$( getTrackOrDiscNumber "$value" )" ;;
			tracktotal|totaltracks) totalTracks="$( getTrackOrDiscNumber "$value" )" ;;

			media|disc|discnumber)
				case "$value" in
					[0-9]*)
						if [ "${value#*/}" != "$value" ]; then
							totalDiscs="$( getTrackOrDiscNumber "${value#*/}" )"
						fi
						;;
				esac
				;;

			track|tracknumber)
				if [ "${value#*/}" != "$value" ]; then
					totalTracks="$( getTrackOrDiscNumber "${value#*/}" )"
				fi
				;;
		esac
	done < "$sourceTagFile"
}

vorbisCommentsToAPEv2 () {
	local line field value totalDiscs='' totalTracks=''

	getTotalDiscsAndTracks
	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		case "$field" in
			album)                 echo "Album=$value" ;;
			albumartist|"album artist") echo "Album Artist=$value" ;;
			artist)                echo "Artist=$value" ;;
			audio_album_peak)      echo "Audio_Album_Peak=$value" ;;
			audio_track_peak)      echo "Audio_Track_Peak=$value" ;;
			composer)              echo "Composer=$value" ;;
			conductor)             echo "Conductor=$value" ;;
			copyright)             echo "Copyright=$value" ;;
			crc32)                 echo "CRC32=$value" ;;
			date|year)             printf 'Year=%.4s\n' "$value" ;;
			description|comment)   echo "Comment=$value" ;;
			discnumber)
				if [ -n "$totalDiscs" ]; then
					printf 'Disc=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalDiscs"
				else
					printf 'Disc=%g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			disctotal|totaldiscs)  continue ;;
			ean/upc)               echo "EAN/UPC=$value" ;;
			encoder|encoding)      continue ;;
			genre)                 echo "Genre=$value" ;;
			isrc)                  echo "ISRC=$value" ;;
			labelno)               echo "Catalog=$value" ;;
			license)               echo "License=$value" ;;
			location)              echo "Record Location=$value" ;;
			performer)             echo "Performer=$value" ;;
			publisher)             echo "Publisher=$value" ;;
			replaygain_reference_loudness) echo "Replaygain_Reference_Loudness=$value" ;;
			replaygain_track_gain) echo "Replaygain_Track_Gain=$value" ;;
			replaygain_track_peak) echo "Replaygain_Track_Peak=$value" ;;
			replaygain_album_gain) echo "Replaygain_Album_Gain=$value" ;;
			replaygain_album_peak) echo "Replaygain_Album_Peak=$value" ;;
			sha1)                  echo "SHA1=$value" ;;
			sha256)                echo "SHA256=$value" ;;
			sha512)                echo "SHA512=$value" ;;
			sourcemedia)           echo "Media=$value" ;;
			subtitle)              echo "Subtitle=$value" ;;
			title)                 echo "Title=$value" ;;
			tracknumber)
				if [ -n "$totalTracks" ]; then
					printf 'Track=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalTracks"
				else
					printf 'Track=%g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			tracktotal|totaltracks) continue ;;
			*)                     echo "${field}=${value}" ;;
		esac
	done < "$sourceTagFile"
}

vorbisCommentsToEyeD3 () {
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks
	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		# replace ASCII hyphen-minus with an UTF-8 non-breaking hyphen only when they may cause failure,
		# and escape spaces
		value="$( echo "$value" | $sedcmd -e 's@^-@‑@' -e 's@ -@ ‑@g' -e 's@ @\\ @g' )"
		case "$field" in
			album)                 echo "--album $value" ;;
			albumartist|"album artist")
				echo "--album-artist $value"
				if [ "$value" = 'Various Artists' -o "$setCompilationFlagWithAlbumArtist" = 'true' ]; then
					echo "--text-frame=TCMP:1" # iTunes 'compilation' frame
				fi
				;;
			artist)                echo "--artist $value" ;;
			composer)              echo "--composer $value" ;;
			conductor)             echo "--text-frame=TPE3:$value" ;;

			copyright)
				echo "$value" | grep -E '^[0-9]{4} '
				if [ $? -eq $Ex_Ok ]; then
					echo "--text-frame=TCOP:$value"
				fi
				;;

			date|year)             printf -- '--release-year %.4s\n--release-date %.4s\n--orig-release-date %.4s\n--recording-date %.4s\n' "$value" "$value" "$value" "$value" ;;
			description|comment)   echo "--text-frame=COMM:$value" ;;
			discnumber)            printf -- '--disc-num %g\n' "$( getTrackOrDiscNumber "$value" )" ;;
			disctotal|totaldiscs)  printf -- '--disc-total %g\n' "$( getTrackOrDiscNumber "$value" )" "$totalDiscs" ;;
			encoder|encoding)      continue ;;
			genre)                 echo "--genre $value" ;;
			isrc)                  echo "--text-frame=TSRC:$value" ;;
			license) if [ "${value:0:7}" = 'http://' ]; then echo "--text-frame=WCOP:$value" ; fi ;;
			lyricist)              echo "--text-frame=TEXT:$value" ;;
			performer)             echo "--text-frame=TPE3:$value" ;;
			publisher)             echo "--publisher $value" ;;
			subtitle)              echo "--text-frame=TIT3:$value" ;;
			title)                 echo "--title $value" ;;
			tracknumber)           printf -- '--track %g\n' "$( getTrackOrDiscNumber "$value" )" ;;
			tracktotal|totaltracks) printf -- '--track-total %g\n' "$totalTracks" ;;
			*)                     echo "--user-text-frame=${field}:${value}" ;;
		esac
	done < "$sourceTagFile"
}

vorbisCommentsToM4A () {
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks

	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		case "$field" in
			album)                 echo "-metadata album=$value" ;;
			albumartist|"album artist")
				echo "-metadata album_artist=$value"
				if [ "$value" = 'Various Artists' -o "$setCompilationFlagWithAlbumArtist" = 'true' ]; then
					echo "-metadata compilation=1" # iTunes 'compilation' frame
				fi
				;;
			artist)                echo "-metadata artist=$value" ;;
			composer)              echo "-metadata composer=$value" ;;
			copyright)             echo "-metadata copyright=$value" ;;
			date|year)             printf -- '-metadata date=%.4s\n' "$value" ;;
			description|comment)   echo "-metadata comment=$value" ;;
			discnumber)
				if [ -n "$totalDiscs" ]; then
					printf -- '-metadata disc=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalDiscs"
				else
					printf -- '-metadata disc=%g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			encoder|encoding)      continue ;;
			genre)                 echo "-metadata genre=$value" ;;
			isrc)                  echo "-metadata isrc=$value" ;;
			organization)          echo "-metadata label=$value" ;;
			title)                 echo "-metadata title=$value" ;;
			tracknumber)
				if [ -n "$totalTracks" ]; then
					printf -- '-metadata track=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalTracks"
				else
					printf -- '-metadata track=%g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			*) continue ;;
		esac
	done < "$sourceTagFile"
}

M4AToVorbisComments () {
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks
	if [ -n "$totalDiscs" ]; then
		printf 'DISCTOTAL=%g\n' "$totalDiscs"
	fi
	if [ -n "$totalTracks" ]; then
		printf 'TRACKTOTAL=%g\n' "$totalTracks"
	fi

	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		case "$field" in
			album)                 echo "ALBUM=$value" ;;
			album_artist)          echo "ALBUMARTIST=$value" ;;
			artist)                echo "ARTIST=$value" ;;
			composer)              echo "COMPOSER=$value" ;;
			copyright)             echo "COPYRIGHT=$value" ;;
			date|year)             printf 'DATE=%.4s\n' "$value" ;;
			comment)               echo "DESCRIPTION=$value" ;;
			disc)                  printf 'DISCNUMBER=%g\n' "$( getTrackOrDiscNumber "$value" )" ;;
			encoder|encoding)      continue ;;
			genre)                 echo "GENRE=$value" ;;
			isrc)                  echo "ISRC=$value" ;;
			label)                 echo "ORGANIZATION=$value" ;;
			title)                 echo "TITLE=$value" ;;
			track)                 printf -- 'TRACKNUMBER=%g\n' "$( getTrackOrDiscNumber "$value" )";;
			*)                     echo "${field}=${value}" ;;
		esac
	done < "$sourceTagFile"
}

M4AToAPEv2 () {
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks
	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		case "$field" in
			album)                 echo "Album=$value" ;;
			album_artist)          echo "Album Artist=$value" ;;
			artist)                echo "Artist=$value" ;;
			comment)               echo "Comment=$value" ;;
			composer)              echo "Composer=$value" ;;
			copyright)             echo "Copyright=$value" ;;
			date|year)             printf 'Year=%.4s\n' "$value" ;;
			disc)
				if [ -n "$totalDiscs" ]; then
					printf 'Disc=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalDiscs"
				else
					printf 'Disc=%g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			encoder|encoding)      continue ;;
			genre)                 echo "Genre=$value" ;;
			isrc)                  echo "ISRC=$value" ;;
			title)                 echo "Title=$value" ;;
			track)
				if [ -n "$totalTracks" ]; then
					printf 'Track=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalTracks"
				else
					printf 'Track=%g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			*)                     echo "${field}=${value}" ;;
		esac
	done < "$sourceTagFile"
}

M4AToEyeD3 () {
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks
	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		# replace ASCII hyphen-minus with an UTF-8 non-breaking hyphen only when they may cause failure,
		# and escape spaces
		value="$( echo "$value" | $sedcmd -e 's@^-@‑@' -e 's@ -@ ‑@g' -e 's@ @\\ @g' )"
		case "$field" in
			album)                 echo "--album $value" ;;
			album_artist)
				echo "--album-artist $value"
				if [ "$value" = 'Various Artists' -o "$setCompilationFlagWithAlbumArtist" = 'true' ]; then
					echo "--text-frame=TCMP:1" # iTunes 'compilation' frame
				fi
				;;
			artist)                echo "--artist $value" ;;
			comment)               echo "--text-frame=COMM:$value" ;;
			composer)              echo "--composer $value" ;;
			copyright)
				echo "$value" | grep -E '^[0-9]{4} '
				if [ $? -eq $Ex_Ok ]; then
					echo "--text-frame=TCOP:$value"
				fi
				;;
			date|year)             printf -- '--release-year %.4s\n--release-date %.4s\n--orig-release-date %.4s\n--recording-date %.4s\n' "$value" "$value" "$value" "$value" ;;
			disc)
				case "$value" in
					[0-9]*)
						printf -- '--disc-num %g\n' "$( getTrackOrDiscNumber "$value" )"
						if [ -n "$totalDiscs" ]; then
							printf -- '--disc-total %g\n' "$( getTrackOrDiscNumber "$value" )" "$totalDiscs"
						fi
						;;
				esac
				;;
			encoder|encoding)      continue ;;
			genre)                 echo "--genre $value" ;;
			isrc)                  echo "--text-frame=TSRC:$value" ;;
			title)                 echo "--title $value" ;;
			track)
				if [ -n "$totalTracks" ]; then
					printf -- '--track %g\n' "$( getTrackOrDiscNumber "$value" )"
					printf -- '--track-total %g\n' "$totalTracks"
				else
					printf -- '--track %g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			*)                     echo "--user-text-frame=${field}:${value}" ;;
		esac
	done < "$sourceTagFile"
}

APEv2ToVorbisComments () {
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks
	if [ -n "$totalDiscs" ]; then
		printf 'DISCTOTAL=%g\n' "$totalDiscs"
	fi
	if [ -n "$totalTracks" ]; then
		printf 'TRACKTOTAL=%g\n' "$totalTracks"
	fi

	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		case "$field" in
			album)                 echo "ALBUM=$value" ;;
			albumartist|"album artist") echo "ALBUMARTIST=$value" ;;
			artist)                echo "ARTIST=$value" ;;
			"audio_album_peak")    echo "AUDIO_ALBUM_PEAK=$value" ;;
			"audio_track_peak")    echo "AUDIO_TRACK_PEAK=$value" ;;
			catalog)               echo "LABELNO=$value" ;;
			comment)               echo "DESCRIPTION=$value" ;;
			composer)              echo "COMPOSER=$value" ;;
			conductor)             echo "CONDUCTOR=$value" ;;
			copyright)             echo "COPYRIGHT=$value" ;;
			crc32)                 echo "CRC32=$value" ;;
			ean/upc)               echo "EAN/UPC=$value" ;;
			encoder|encoding)      continue ;;
			genre)                 echo "GENRE=$value" ;;
			isrc)                  echo "ISRC=$value" ;;
			license)               echo "LICENSE=$value" ;;
			media|disc)
				case "$value" in
					[0-9]*) printf 'DISCNUMBER=%g\n' "$( getTrackOrDiscNumber "$value" )" ;;
					*) echo "SOURCEMEDIA=$value" ;;
				esac ;;
			performer)             echo "PERFORMER=$value" ;;
			publisher)             echo "PUBLISHER=$value" ;;
			'record location')     echo "LOCATION=$value" ;;
			replaygain_reference_loudness) echo "REPLAYGAIN_REFERENCE_LOUDNESS=$value" ;;
			replaygain_track_gain) echo "REPLAYGAIN_TRACK_GAIN=$value" ;;
			replaygain_track_peak) echo "REPLAYGAIN_TRACK_PEAK=$value" ;;
			replaygain_album_gain) echo "REPLAYGAIN_ALBUM_GAIN=$value" ;;
			replaygain_album_peak) echo "REPLAYGAIN_ALBUM_PEAK=$value" ;;
			sha1)                  echo "SHA1=$value" ;;
			sha256)                echo "SHA256=$value" ;;
			sha512)                echo "SHA512=$value" ;;
			subtitle)              echo "SUBTITLE=$value" ;;
			title)                 echo "TITLE=$value" ;;
			track)                 printf 'TRACKNUMBER=%g\n' "$( getTrackOrDiscNumber "$value" )" ;;
			year|date)             printf 'DATE=%.4s\n' "$value" ;;
			*)                     echo "${field}=${value}" ;;
		esac
	done < "$sourceTagFile"
}

APEv2ToEyeD3 () {
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks
	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		# replace ASCII hyphen-minus with an UTF-8 non-breaking hyphen only when they may cause failure,
		# and escape spaces
		value="$( echo "$value" | $sedcmd -e 's@^-@‑@' -e 's@ -@ ‑@g' -e 's@ @\\ @g' )"
		case "$field" in
			album)                 echo "--album $value" ;;
			albumartist|"album artist")
				echo "--album-artist $value"
				if [ "$value" = 'Various Artists' -o "$setCompilationFlagWithAlbumArtist" = 'true' ]; then
					echo "--text-frame=TCMP:1" # iTunes 'compilation' frame
				fi
				;;
			artist)                echo "--artist $value" ;;
			comment)               echo "--text-frame=COMM:$value" ;;
			composer)              echo "--composer $value" ;;
			copyright)
				echo "$value" | grep -E '^[0-9]{4} '
				if [ $? -eq $Ex_Ok ]; then
					echo "--text-frame=TCOP:$value"
				fi
				;;
			conductor)             echo "--text-frame=TPE3:$value" ;;
			encoder|encoding)      continue ;;
			genre)                 echo "--genre $value" ;;
			isrc)                  echo "--text-frame=TSRC:$value" ;;
			license) if [ "${value:0:7}" = 'http://' ]; then echo "--text-frame=WCOP:$value" ; fi ;;
			media|disc)
				case "$value" in
					[0-9]*)
						printf -- '--disc-num %g\n' "$( getTrackOrDiscNumber "$value" )"
						if [ -n "$totalDiscs" ]; then
							printf -- '--disc-total %g\n' "$( getTrackOrDiscNumber "$value" )" "$totalDiscs"
						fi
						;;
				esac
				;;
			performer)             echo "--text-frame=TPE3:$value" ;;
			publisher)             echo "--publisher $value" ;;
			subtitle)              echo "--text-frame=TIT3:$value" ;;
			title)                 echo "--title $value" ;;
			track)
				if [ -n "$totalTracks" ]; then
					printf -- '--track %g\n' "$( getTrackOrDiscNumber "$value" )"
					printf -- '--track-total %g\n' "$totalTracks"
				else
					printf -- '--track %g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			year|date)             printf -- '--release-year %.4s\n--release-date %.4s\n--orig-release-date %.4s\n--recording-date %.4s\n' "$value" "$value" "$value" "$value" ;;
			*)                     echo "--user-text-frame=${field}:${value}" ;;
		esac
	done < "$sourceTagFile"
}

APEv2ToM4A () {
	local line field value totalTracks='' totalDiscs=''

	getTotalDiscsAndTracks

	while read line; do
		field="${line%%=*}" ; value="${line#*=}"
		if [ "$value" = '' ]; then continue; fi
		case "$field" in
			album)                 echo "-metadata album=$value" ;;
			albumartist|"album artist")
				echo "-metadata album_artist=$value"
				if [ "$value" = 'Various Artists' -o "$setCompilationFlagWithAlbumArtist" = 'true' ]; then
					echo "-metadata compilation=1" # iTunes 'compilation' frame
				fi
				;;
			artist)                echo "-metadata artist=$value" ;;
			comment)               echo "-metadata comment=$value" ;;
			composer)              echo "-metadata composer=$value" ;;
			copyright)             echo "-metadata copyright=$value" ;;
			encoder|encoding)      continue ;;
			genre)                 echo "-metadata genre=$value" ;;
			isrc)                  echo "-metadata isrc=$value" ;;
			media|disc)
				case "$value" in
					[0-9]*)
						if [ -n "$totalDiscs" ]; then
							printf -- '-metadata disc=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalDiscs"
						else
							printf -- '-metadata disc=%g\n' "$( getTrackOrDiscNumber "$value" )"
						fi
						;;
				esac
				;;
			title)                 echo "-metadata title=$value" ;;
			track)
				if [ -n "$totalTracks" ]; then
					printf -- '-metadata track=%g/%g\n' "$( getTrackOrDiscNumber "$value" )" "$totalTracks"
				else
					printf '-metadata track=%g\n' "$( getTrackOrDiscNumber "$value" )"
				fi
				;;
			year|date)             printf -- '-metadata date=%.4s\n' "$value" ;;
			*) continue ;;
		esac
	done < "$sourceTagFile"
}

genTagFilter () {
	local taglist="$1" translations search match

	translations="@albumartist@,@album artist@
@date@,@year@
@description@,@comment@
@discnumber@,@disc@
@disctotal@,@totaldiscs@
@labelno@,@catalog@
@location@,@record location@
@organization@,@label@
@sourcemedia@,@media@
@tracknumber@,@track@
@tracktotal@,@totaltracks@"

	ereg="^${taglist//,/=|^}="
	search="@${taglist//,/@,@}@"
	OIFS="$IFS"; IFS=','
	for w in $search; do
		match="$( echo "$translations" | grep -Fi "$w" 2>/dev/null )"
		if [ -n "$match" ]; then
			match="${match//@/}"; match="${match//,/=|^}"
			ereg="${ereg}|^${match}="
		fi
	done
	IFS="$OIFS"
}

processSourceTagFile () {
	local firstLine='true'

	test -e "$sourceTagFile" || return

	# process multi-line tags
	while read line; do
		if [ "$line" != "${line%%=*}" ]; then # new field
			if [ "$firstLine" = 'true' ]; then
				firstLine='false'
				echo -n "$line"
			else
				echo -en "\n${line}"
			fi
		else # multi-line tag
			echo -n "§${line}"
		fi
	done < "$sourceTagFile" > "${sourceTagFile}.tmp"
	mv "${sourceTagFile}.tmp" "$sourceTagFile" 2>> "$Self_Errors_File" || exitCode=$Ex_Ko

	if [ -n "$outputCodecs" ]; then
		# white/blacklists
		if [ -n "$tagWhitelist" ]; then
			genTagFilter "$tagWhitelist"
			grep -iE "$ereg" "$sourceTagFile" > "${sourceTagFile}.tmp"
			mv "${sourceTagFile}.tmp" "$sourceTagFile" 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
		elif [ -n "$tagBlacklist" ]; then
			genTagFilter "$tagBlacklist"
			grep -viE "$ereg" "$sourceTagFile" > "${sourceTagFile}.tmp"
			mv "${sourceTagFile}.tmp" "$sourceTagFile" 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
		fi

		if isWavProcessed ; then
			if [ -e "${sourceTagFile}.tmp" ]; then
				mv -f "${sourceTagFile}.tmp" "$sourceTagFile" 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			fi
		fi
	fi
}

sanitizeApeTags () {
	local field lastField value lastValue first='true'

	# transform duplicate fields into unique multi-value fields
	while read line; do
		lastField="$field" lastValue="$value"
		field="$( echo "${line%%=*}" | tr '[:upper:]' '[:lower:]' 2>/dev/null )"
		value="${line#*=}"
		if [ "$field" != "$lastField" ]; then
			if [ "$first" = 'true' ]; then
				echo -en "${line}"
				first='false'
			else
				echo -en "\n${line}"
			fi
		elif [ "$value" != "$lastValue" ]; then
			echo -n '\\x01'
			echo -n "$value"
		fi
	done < <( sort -u "$destTagFile" 2>/dev/null ) > "${destTagFile}.tmp"
	if [ -f "${destTagFile}.tmp" ]; then
		if [ "$gnustat" = 'true' ]; then
			destTagFileSize=$( $statcmd -c '%s' "${destTagFile}.tmp" )
		else
			destTagFileSize=$( $statcmd -f '%z' "${destTagFile}.tmp" )
		fi
		if [ $destTagFileSize -gt 0 ]; then
			echo -en "\n" >> "${destTagFile}.tmp"
		fi
		rm -f "$destTagFile" 1>/dev/null 2>&1
		mv "${destTagFile}.tmp" "$destTagFile" 1>/dev/null 2>&1
	fi
}

convertTags () {
	local format="$2"
	destTagFile="${Self_Swap_Dir}/${paddedFileIndex}_tags_${format}.txt"
	test -e "$sourceTagFile" || return
	test -e "$destTagFile" && return
	shopt -qs nocasematch
	case $1 in
		vc)
			case $2 in
				vc)
					if [ -n "$outputCodecs" ]; then
						grep -viE '^encoder=|^encoding=' "$sourceTagFile" > "$destTagFile"
					else
						cp "$sourceTagFile" "$destTagFile" 1>/dev/null 2>&1
					fi
					;;

				ape) vorbisCommentsToAPEv2 > "$destTagFile" ;;
				mp3) vorbisCommentsToEyeD3 > "$destTagFile" ;;
				m4a) vorbisCommentsToM4A > "$destTagFile" ;;
			esac ;;

		ape)
			case $2 in
				ape)
					if [ -n "$outputCodecs" ]; then
						grep -viE '^encoder=|^encoding=' "$sourceTagFile" > "$destTagFile"
					else
						cp "$sourceTagFile" "$destTagFile" 1>/dev/null 2>&1
					fi
					;;

				vc) APEv2ToVorbisComments > "$destTagFile" ;;
				mp3) APEv2ToEyeD3 > "$destTagFile" ;;
				m4a) APEv2ToM4A > "$destTagFile" ;;

			esac
			case $2 in
				vc|mp3)
					if [ "$gnused" = 'true' ]; then
						$sedcmd -i'' -e 's@\x02@ / @g' -e 's@^ro:@@' "$destTagFile"
					else
						$sedcmd -i '' -e 's@\x02@ / @g' -e 's@^ro:@@' "$destTagFile"
					fi
					;;
			esac
			;;

		m4a)
			case $2 in
				m4a)
					if [ -n "$outputCodecs" ]; then
						grep -viE '^encoder=|^encoding=' "$sourceTagFile" > "$destTagFile"
					else
						cp "$sourceTagFile" "$destTagFile" 1>/dev/null 2>&1
					fi
					;;

				ape) M4AToAPEv2 > "$destTagFile" ;;
				mp3) M4AToEyeD3 > "$destTagFile" ;;
				vc) M4AToVorbisComments > "$destTagFile" ;;
			esac ;;
	esac

	case "$destTagFile" in
		*.ape.txt) sanitizeApeTags ;;
	esac
	shopt -qu nocasematch
}

getAPEv2TrackPictureTypeLabel () {
	local picType="$1" picTypeLabel

	case "$picType" in
		0) picTypeLabel='other' ;;
		1) picTypeLabel='icon' ;;
		2) picTypeLabel='other icon' ;;
		3) picTypeLabel='front' ;;
		4) picTypeLabel='back' ;;
		5) picTypeLabel='leaflet' ;;
		6) picTypeLabel='media' ;;
		7) picTypeLabel='lead artist' ;;
		8) picTypeLabel='artist' ;;
		9) picTypeLabel='conductor' ;;
		10) picTypeLabel='band' ;;
		11) picTypeLabel='composer' ;;
		12) picTypeLabel='lyricist' ;;
		13) picTypeLabel='recording location' ;;
		14) picTypeLabel='during recording' ;;
		15) picTypeLabel='during performance' ;;
		16) picTypeLabel='video' ;;
		17) picTypeLabel='a bright colored fish' ;;
		18) picTypeLabel='illustration' ;;
		19) picTypeLabel='band logo' ;;
		20) picTypeLabel='publisher logo' ;;
		*)
	esac

	echo "$picTypeLabel"
}

getID3v2TrackPictureTypeLabel () {
	local picType="$1" picTypeLabel

	case $picType in
		0) picTypeLabel='OTHER' ;;
		1) picTypeLabel='ICON' ;;
		2) picTypeLabel='OTHER_ICON' ;;
		3) picTypeLabel='FRONT_COVER' ;;
		4) picTypeLabel='BACK_COVER' ;;
		5) picTypeLabel='LEAFLET' ;;
		6) picTypeLabel='MEDIA' ;;
		7) picTypeLabel='LEAD_ARTIST' ;;
		8) picTypeLabel='ARTIST' ;;
		9) picTypeLabel='CONDUCTOR' ;;
		10) picTypeLabel='BAND' ;;
		11) picTypeLabel='COMPOSER' ;;
		12) picTypeLabel='LYRICIST' ;;
		13) picTypeLabel='RECORDING_LOCATION' ;;
		14) picTypeLabel='DURING_RECORDING' ;;
		15) picTypeLabel='DURING_PERFORMANCE' ;;
		16) picTypeLabel='VIDEO' ;;
		17) picTypeLabel='BRIGHT_COLORED_FISH' ;;
		18) picTypeLabel='ILLUSTRATION' ;;
		19) picTypeLabel='BAND_LOGO' ;;
		20) picTypeLabel='PUBLISHER_LOGO' ;;
		*) picTypeLabel='OTHER' ;;
	esac

	echo "$picTypeLabel"
}

getTrackPictureFileName () {
	local paddedFileIndex="$1" picType="$2" picNumber="$3" picExt="$4"

	case "$picNumber" in
		[0-9]) picNumber="0${picNumber}" ;;
	esac

	case "$picType" in
		[0-9]|1[0-9]|20) picType=$picType ;;
		'other') picType=0 ;;
		'icon') picType=1 ;;
		'other icon') picType=2 ;;
		'front') picType=3 ;;
		'back') picType=4 ;;
		'leaflet') picType=5 ;;
		'media') picType=6 ;;
		'lead artist') picType=7 ;;
		'artist') picType=8 ;;
		'conductor') picType=9 ;;
		'band') picType=10 ;;
		'composer') picType=11 ;;
		'lyricist') picType=12 ;;
		'recording location') picType=13 ;;
		'during recording') picType=14 ;;
		'during performance') picType=15 ;;
		'video') picType=16 ;;
		'a bright colored fish') picType=17 ;;
		'illustration') picType=18 ;;
		'band logo') picType=19 ;;
		'publisher logo') picType=20 ;;
		*) picType=0 ;;
	esac

	echo "${paddedFileIndex}_picture_${picType}_${picNumber}-placeholder.${picExt}"
}

extractFlacArtwork () {
	local exitCode=$Ex_Ok pattern blockNumber withinPictureBlock='false'
	local picType=0 picNumber=1 picExt picFile description descFile picTypesList=''

	for outputCodec in $outputCodecs; do
		case "$outputCodec" in
			OggVorbis) continue ;; # unsupported formats
		esac
		pattern="x${outputCodec}Y"
		if [ "$preserveMetadata" != "${preserveMetadata//$pattern/@}" ]; then
			metaflac --list "$copyFile" 2>> "$Self_Errors_File" | grep -vE '[0-9A-F]{8}:' > "${Self_Swap_Dir}/${paddedFileIndex}_internal_FLAC.list" 2>/dev/null
			if [ "$gnused" = 'true' ]; then
				$sedcmd -i'' -e 's@METADATA block #@\nMETADATA block #@' "${Self_Swap_Dir}/${paddedFileIndex}_internal_FLAC.list" # binary data can screw up the 'METADATA block #' line
			else
				$sedcmd -i '' -e 's@METADATA block #@\nMETADATA block #@' "${Self_Swap_Dir}/${paddedFileIndex}_internal_FLAC.list" # binary data can screw up the 'METADATA block #' line
			fi
			while read line; do
				if [ "${line:0:16}" = 'METADATA block #' ]; then
					blockNumber="${line#*#}"
				elif [ "$line" = 'type: 6 (PICTURE)' ]; then
					withinPictureBlock='true'
				elif [ "${line:0:5}" = 'type:' -a "$withinPictureBlock" = 'true' ]; then
					picType="${line#* }"
					picType="${picType%% *}"
					picTypesList="${picTypesList}\n${picType}\n"
				elif [ "${line:0:10}" = 'MIME type:' -a "$withinPictureBlock" = 'true' ]; then
					case "$line" in
						'MIME type: image/jpeg') picExt='jpg' ;;
						'MIME type: image/png') picExt='png' ;;
						'MIME type: image/gif') picExt='gif' ;;
					esac
				elif [ "${line:0:12}" = 'description:' -a "$withinPictureBlock" = 'true' ]; then
					description="${line/description: /}"
					descFile="${Self_Swap_Dir}/$( getTrackPictureFileName "$paddedFileIndex" "$picType" "$picNumber" "txt" )"
					if [ "$description" != 'description:' ]; then
						echo "$description" > "$descFile"
					fi

					picNumber="$( echo -e "$picTypesList" | grep -F "$picType" | wc -l | tr -cd [0-9] )"
					picFile="${Self_Swap_Dir}/$( getTrackPictureFileName "$paddedFileIndex" "$picType" "$picNumber" "$picExt" )"
					metaflac --block-number=$blockNumber --export-picture-to="$picFile" "$copyFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
					if [ $exitCode -ne $Ex_Ok ]; then
						rm -rf "$picFile" "$descFile" 1>/dev/null 2>> "$Self_Errors_File"
					fi
					withinPictureBlock='false'
				fi
			done < "${Self_Swap_Dir}/${paddedFileIndex}_internal_FLAC.list"
			rm -f "${Self_Swap_Dir}/${paddedFileIndex}_internal_FLAC.list" 1>/dev/null 2>&1
			return $exitCode
		fi
	done

	return $exitCode
}

extractAPEv2Artwork () {
	local exitCode=$Ex_Ok pattern picType=0 picNumber=1 picTypeLabel='other' picExt='' picFile
	local picTypesList='' argString=''

	for outputCodec in $outputCodecs; do
		case "$outputCodec" in
			OggVorbis) continue ;; # unsupported formats
		esac
		pattern="x${outputCodec}Y"
		if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then continue; fi

		for picTypeLabel in 'other' 'icon' 'other icon' 'front' 'back' 'leaflet' 'media' 'lead artist' 'artist' 'conductor' 'band' 'composer' 'lyricist' 'recording location' 'during recording' 'during performance' 'video' 'a bright colored fish' 'illustration' 'band logo' 'publisher logo'; do
			picFile="${Self_Swap_Dir}/$( getTrackPictureFileName "$paddedFileIndex" "$picTypeLabel" "$picNumber" "$picExt" )"
			argString="${argString}\\x00-d\\x00cover art (${picTypeLabel})=${picFile}"
			(( picType++ ))
			(( picNumber++ ))
		done
		if [ -n "$argString" ]; then
			echo -en "-z${argString}\x00${copyFile}" | xargs -0 APEv2 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
		fi
	done

	return $exitCode
}

extractAPEv2Binaries () {
	local exitCode=$Ex_Ok pattern argString='' fieldName='' binaryIndex=1 paddedBinaryIndex

	for outputCodec in $outputCodecs; do
		case "$outputCodec" in
			MonkeysAudio|WavPack*)
				pattern="x${outputCodec}Y"
				if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then continue; fi

				if [ ! -d "$binariesDir" ]; then
					mkdir -p "$binariesDir" 1>/dev/null 2>&1
				fi
				while read fieldName; do
					paddedBinaryIndex="$( printf "%03i" $binaryIndex )"
					echo "$fieldName" > "${binariesDir}/${paddedBinaryIndex}.txt" 2>/dev/null
					argString="${argString}\\x00-d\\x00${fieldName}=${binariesDir}/${paddedBinaryIndex}.bin"
					( (binaryIndex++ ))
				done < <( APEv2 -z "$copyFile" 2>/dev/null | grep -F '=data:' 2>/dev/null | cut -d '=' -f 1 2>/dev/null )

				if [ -n "$argString" ]; then
					echo -en "-z${argString}\x00${copyFile}" | xargs -0 APEv2 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				fi
				;;

			*) continue ;;
		esac
	done

	return $exitCode
}

getUserSpecifiedArtworkBytes () {
	local exitCode=$Ex_Ok userSpecifiedArtwork bytes

	userSpecifiedArtwork="$( getCodecCoverArtFile "$outputCodec" )"
	userSpecifiedArtwork="${sourceDirname}/${userSpecifiedArtwork}"
	if [ -z "$userSpecifiedArtwork" ]; then
		echo "0"; return $Ex_Ok
	elif [ ! -f "$userSpecifiedArtwork" ]; then
		echo "0"; return $Ex_Ok
	elif [ ! -r "$userSpecifiedArtwork" ]; then
		echo "0"; return $Ex_Ok
	else
		if [ "$gnustat" = 'true' ]; then
			bytes="$( $statcmd -L --printf '%s' "$userSpecifiedArtwork" 2>/dev/null )"
		else
			bytes="$( $statcmd -L -n -f '%z' "$userSpecifiedArtwork" 2>/dev/null )"
		fi
	fi

	case "$bytes" in
		[0-9]*) echo "$bytes" ;;
		*) echo "0"; exitCode=$Ex_Ko ;;
	esac

	return $exitCode
}

getEmbeddedArtworkSize () {
	local exitCode=$Ex_Ok pattern picType picNumber picFile picBasename bytes=0 fileBytes=0

	pattern="x${outputCodec}Y"
	if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then
		echo "$bytes"
		return $Ex_Ok
	fi

	bytes="$( getUserSpecifiedArtworkBytes )"

	# "${paddedFileIndex}_picture_${picType}_${picNumber}_placeholder.${picExt}"
	for picFile in "${Self_Swap_Dir}/${paddedFileIndex}_picture_"*; do
		if [ ! -f "$picFile" ]; then # there are no pictures for this file
			echo "$bytes"
			return $Ex_Ok
		fi
		case "$picFile" in
			*.txt|*.bin) continue ;;
		esac
		if [ ! -r "$picFile" ]; then
			continue
		fi
		if [ "$gnustat" = 'true' ]; then
			fileBytes="$( $statcmd -L --printf '%s' "$picFile" 2>/dev/null )"
		else
			fileBytes="$( $statcmd -L -n -f '%z' "$picFile" 2>/dev/null )"
		fi
		case "$fileBytes" in
			[0-9]*) bytes=$(( bytes + fileBytes )) ;;
		esac
	done

	echo "$bytes"
	return $exitCode
}

importCoverArt () {
	local exitCode=$Ex_Ok userSpecifiedArtwork coverArtType=3 picNumber=0 picExt picFile descFile

	# "${paddedFileIndex}_picture_${picType}_${picNumber}_placeholder.${picExt}"
	userSpecifiedArtwork="$( getCodecCoverArtFile "$outputCodec" )"
	if [ -n "$userSpecifiedArtwork" ]; then
		userSpecifiedArtwork="${sourceDirname}/${userSpecifiedArtwork}"
		if [ ! -f "$userSpecifiedArtwork" ]; then
			return $Ex_Ok
		elif [ ! -r "$userSpecifiedArtwork" ]; then
			return $Ex_Ko
		fi
	else
		return $Ex_Ok
	fi

	picExt="${userSpecifiedArtwork##*.}"
	picFile="${Self_Swap_Dir}/$( getTrackPictureFileName "$paddedFileIndex" "$coverArtType" "$picNumber" "$picExt" )"
	descFile="${Self_Swap_Dir}/$( getTrackPictureFileName "$paddedFileIndex" "$coverArtType" "$picNumber" "txt" )"
	cp -f "$userSpecifiedArtwork" "$picFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
	touch "$descFile" 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
	touch "${descFile}"

	return $exitCode
}

importArtworkIntoFLAC () {
	local exitCode=$Ex_Ok pattern picType picNumber picFile picBasename description='' descFile=''

	pattern="x${outputCodec}Y"
	if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then
		return $Ex_Ok
	fi

	importCoverArt || exitCode=$Ex_Ko

	# "${paddedFileIndex}_picture_${picType}_${picNumber}_placeholder.${picExt}"
	for picFile in "${Self_Swap_Dir}/${paddedFileIndex}_picture_"*; do
		if [ ! -f "$picFile" ]; then # there are no pictures for this file
			return $Ex_Ok
		fi
		case "$picFile" in
			*.txt|*.bin) continue ;;
		esac
		if [ ! -r "$picFile" ]; then
			continue
		fi
		picBasename="${picFile##*/}"
		picType="$( echo "$picBasename" | cut -d '_' -f 3 | tr -cd [0-9] )"
		picNumber="$( echo "$picBasename" | cut -d '_' -f 4 | tr -cd [0-9] )"
		descFile="${Self_Swap_Dir}/$( getTrackPictureFileName "$paddedFileIndex" "$picType" "$picNumber" "txt" )"
		description=''
		if [ -r "$descFile" ]; then
			description="$( cat "$descFile" 2>> "$Self_Errors_File" )"
		fi
		metaflac --import-picture-from="${picType}||${description}||${picFile}" "$encodedFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
	done

	return $exitCode
}

genOpusArtworkCommandLine () {
	local exitCode=$Ex_Ok pattern picFile picBasename picType picNumber descFile description cmdline='' doEmbedCoverArt

	doEmbedCoverArt="$( shouldEmbedCoverArt "$outputCodec" )"
	if [ "$doEmbedCoverArt" = 'false' ]; then
		echo "$cmdline"
		return $Ex_Ok
	fi

	pattern="x${outputCodec}Y"
	if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then
		echo "$cmdline"
		return $Ex_Ok
	fi

	importCoverArt || exitCode=$Ex_Ko

	# "${paddedFileIndex}_picture_${picType}_${picNumber}_placeholder.${picExt}"
	for picFile in "${Self_Swap_Dir}/${paddedFileIndex}_picture_"*; do
		if [ ! -f "$picFile" ]; then # there are no pictures for this file
			return $Ex_Ok
		fi
		case "$picFile" in
			*.txt|*.bin) continue ;;
		esac
		if [ ! -r "$picFile" ]; then
			continue
		fi
		picBasename="${picFile##*/}"
		picType="$( echo "$picBasename" | cut -d '_' -f 3 | tr -cd [0-9] )"
		picNumber="$( echo "$picBasename" | cut -d '_' -f 4 | tr -cd [0-9] )"
		descFile="${Self_Swap_Dir}/$( getTrackPictureFileName "$paddedFileIndex" "$picType" "$picNumber" "txt" )"
		description=''
		if [ -r "$descFile" ]; then
			description="$( cat "$descFile" 2>> "$Self_Errors_File" )"
		fi
		cmdline="${cmdline}\x00--picture=${picType}||${description}||${picFile}"
	done
	echo "$cmdline"

	return $exitCode
}

importArtworkIntoAPEv2 () {
	local exitCode=$Ex_Ok pattern picFile picBasename picType picTypeLabel argString=''

	pattern="x${outputCodec}Y"
	if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then
		return $Ex_Ok
	fi

	importCoverArt || exitCode=$Ex_Ko

	# "${paddedFileIndex}_picture_${picType}_${picNumber}_placeholder.${picExt}"
	for picFile in "${Self_Swap_Dir}/${paddedFileIndex}_picture_"*; do
		if [ ! -f "$picFile" ]; then # there are no pictures for this file
			return $Ex_Ok
		fi
		case "$picFile" in
			*.txt|*.bin) continue ;;
		esac
		if [ ! -r "$picFile" ]; then
			continue
		fi
		picBasename="${picFile##*/}"
		picType="$( echo "$picBasename" | cut -d '_' -f 3 | tr -cd [0-9] )"
		picNumber="$( echo "$picBasename" | cut -d '_' -f 4 | tr -cd [0-9] )"
		descFile="${Self_Swap_Dir}/$( getTrackPictureFileName "$paddedFileIndex" "$picType" "$picNumber" "txt" )"
		description=''
		if [ -r "$descFile" ]; then
			description="$( cat "$descFile" 2>> "$Self_Errors_File" )"
		fi
		picTypeLabel="$( getAPEv2TrackPictureTypeLabel "$picType" )"
		argString="${argString}\\x00-a\\x00Cover Art (${picTypeLabel})=${picFile}"
	done

	if [ -n "$argString" ]; then
		echo -en "-z${argString}\x00${encodedFile}" | xargs -0 APEv2 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
	fi

	return $exitCode
}

importBinariesIntoAPEv2 () {
	local exitCode=$Ex_Ok pattern argString='' fieldName binaryFile

	if [ ! -d "$binariesDir" ]; then return $Ex_Ok; fi

	pattern="x${outputCodec}Y"
	if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then
		return $Ex_Ok
	fi

	# "${binariesDir}/${paddedBinaryIndex}.txt"
	for binaryFile in "${binariesDir}"/*.txt; do
		if [ ! -f "$binaryFile" ]; then # there are no binaries for this file
			exit $Ex_Ok
		fi
		if [ ! -r "$binaryFile" ]; then
			continue
		fi
		fieldName="$( cat "$binaryFile" )"
		argString="${argString}\\x00-b\\x00${fieldName}=${binaryFile/.txt/.bin}"
	done

	if [ -n "$argString" ]; then
		echo -en "-z${argString}\x00${encodedFile}" | xargs -0 APEv2 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
	fi

	return $exitCode
}

importArtworkIntoMP3 () {
	local exitCode=$Ex_Ok pattern picBasename picType picTypeLabel description='' descFile=''

	which 'eyeD3' 1>/dev/null 2>&1 || return $Ex_Ok

	pattern="x${outputCodec}Y"
	if [ "$preserveMetadata" = "${preserveMetadata//$pattern/@}" ]; then
		return $Ex_Ok
	fi

	importCoverArt || exitCode=$Ex_Ko

	# "${paddedFileIndex}_picture_${picType}_${picNumber}_placeholder.${picExt}"
	for picFile in "${Self_Swap_Dir}/${paddedFileIndex}_picture_"*; do
		if [ ! -f "$picFile" ]; then # there are no pictures for this file
			return $Ex_Ok
		fi
		case "$picFile" in
			*.txt|*.bin) continue ;;
		esac
		if [ ! -r "$picFile" ]; then
			continue
		fi
		picBasename="${picFile##*/}"
		picType="$( echo "$picBasename" | cut -d '_' -f 3 | tr -cd [0-9] )"
		picNumber="$( echo "$picBasename" | cut -d '_' -f 4 | tr -cd [0-9] )"
		descFile="${Self_Swap_Dir}/$( getTrackPictureFileName "$paddedFileIndex" "$picType" "$picNumber" "txt" )"
		description=''
		if [ -r "$descFile" ]; then
			description="$( cat "$descFile" 2>> "$Self_Errors_File" )"
		fi
		picTypeLabel="$( getID3v2TrackPictureTypeLabel "$picType" )"
		eyeD3 --quiet --to-v2.4 --add-image="${picFile}:${picTypeLabel}:${description}" "$encodedFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
	done

	return $exitCode
}

getDownmixFactors () {
	local divider="$1"

	fv="$( echo "scale=5; 1 / $divider" | bc )"
	fv="$( printf "%.4f" "$fv" )"

	pv="$( echo "scale=5; (1 / sqrt(2)) / $divider" | bc )"
	pv="$( printf "%.4f" "$pv" )"

	hv="$( echo "scale=5; 0.5 / $divider" | bc )"
	hv="$( printf "%.4f" "$hv" )"
}

upmixToStereo () {
	local exitCode=$Ex_Ok

	sox $soxGuard -M "$wavFile" "$wavFile" $bitdepthcmd -c 2 "$resampledWavFile" $gaincmd $ratecmd $dithercmd 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko

	if [ $exitCode -eq $Ex_Ok -a -f "$resampledWavFile" ]; then
		mv -f "$resampledWavFile" "$wavFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
		if [ $exitCode -eq $Ex_Ok ]; then
			isWavProcessed 'true'
		fi
	fi
	if [ -e "$resampledWavFile" ]; then rm -f "$resampledWavFile"; fi
	return $exitCode
}

downmixToStereo () {
	local exitCode=$Ex_Ok surroundConfig='' fv='' pv='' hv=''

	# The following channel mappings have been thoroughly tested and should never clip, even in worst-case scenarios
	# Front ($fv): factor 1, LFE ($hv): factor 0.5 (1/2), everything else ($pv): factor 0.7071 (1 / sqrt(2))
	# http://www.academia.edu/2397757/A_downmix_approach
	case "$nChannels" in
		3) # FL, FR, LFE
			surroundConfig='2.1'
			getDownmixFactors '1.55'
			sox $soxGuard "$wavFile" $bitdepthcmd "$resampledWavFile" $ratecmd remix -m 1v${fv},3v${hv} 2v${fv},3v${hv} $dithercmd 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			;;

		4) # FL, FR, SL, SR
			surroundConfig='4.0'
			getDownmixFactors '1.75'
			sox $soxGuard "$wavFile" $bitdepthcmd "$resampledWavFile" $ratecmd remix -m 1v${fv},3v${pv} 2v${fv},4v${pv} $dithercmd 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			;;

		5) # FL, FR, C, SL, SR
			surroundConfig='5.0'
			getDownmixFactors '2.5'
			sox $soxGuard "$wavFile" $bitdepthcmd "$resampledWavFile" $ratecmd remix -m 1v${fv},3v${pv},4v${pv} 2v${fv},3v${pv},5v${pv} $dithercmd 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			;;

		6) # FL, FR, C, LFE, SL, SR
			surroundConfig='5.1'
			getDownmixFactors '3'
			sox $soxGuard "$wavFile" $bitdepthcmd "$resampledWavFile" $ratecmd remix -m 1v${fv},3v${pv},4v${hv},5v${pv} 2v${fv},3v${pv},4v${hv},6v${pv} $dithercmd 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			;;

		8) # FL, FR, C, LFE, SL, SR, BL, BR
			surroundConfig='7.1'
			getDownmixFactors '3.75'
			sox $soxGuard "$wavFile" $bitdepthcmd "$resampledWavFile" $ratecmd remix -m 1v${fv},3v${pv},4v${hv},5v${pv},7v${pv} 2v${fv},3v${pv},4v${hv},6v${pv},8v${pv} $dithercmd 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			;;

		*) return $Ex_Ok ;; # nothing to do
	esac

	unset fv pv hv

	if [ $exitCode -eq $Ex_Ok -a -f "$resampledWavFile" ]; then
		mv -f "$resampledWavFile" "$wavFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
		if [ $exitCode -eq $Ex_Ok ]; then
			isWavProcessed 'true'
		fi
	fi
	if [ -e "$resampledWavFile" ]; then rm -f "$resampledWavFile"; fi
	return $exitCode
}

isWavProcessed () {
	local trueOrFalse="$1"

	if [ "$trueOrFalse" = 'true' ]; then
		if [ ! -e "$wavProcessedStatusFile" ]; then
			touch "$wavProcessedStatusFile"
		fi
		return $Ex_Ok
	elif [ "$trueOrFalse" = 'false' ]; then
		if [ -e "$wavProcessedStatusFile" ]; then
			rm -f "$wavProcessedStatusFile" 1>/dev/null 2>&1
		fi
		return $Ex_Ko
	elif [ -e "$wavProcessedStatusFile" ]; then
		return $Ex_Ok
	else
		return $Ex_Ko
	fi
}

processWavFile () {
	local exitCode=$Ex_Ok

	if [ -e "$copyFile" ]; then
		rm -f "$copyFile" "${copyFile}c"
	fi
	gainValue='' gaincmd=''
	if [ "$applyGain" = 'true' ]; then
		if [ "$applyGainType" = 'ALBUM' -o "$applyGainType" = 'TRACK' ]; then
			if [ "$applyGainType" = 'ALBUM' ]; then
				gainValue="$( grep -Fi 'replaygain_album_gain' "$sourceTagFile" 2>/dev/null | cut -d '=' -f 2 | cut -d ' ' -f 1 )"
			else
				gainValue="$( grep -Fi 'replaygain_track_gain' "$sourceTagFile" 2>/dev/null | cut -d '=' -f 2 | cut -d ' ' -f 1 )"
			fi
			if [ -n "$gainValue" ]; then
				if [ "${preamp:0:1}" = '-' ]; then
					gainValue="$( printf '%.2f' "$( echo "scale=5; ($gainValue - ${preamp:1}) / 1" | bc 2>> "$Self_Errors_File" )" )"
				elif [ "${preamp:0:1}" = '+' ]; then
					gainValue="$( printf '%.2f' "$( echo "scale=5; ($gainValue + ${preamp:1}) / 1" | bc 2>> "$Self_Errors_File" )" )"
				fi
				if [ "${gainValue:0:1}" != '-' -a "${gainValue:0:1}" != '+' ]; then
					gainValue="+${gainValue}"
				fi
			fi
		elif [ "$applyGainType" = 'ALBUM_PEAK' -o "$applyGainType" = 'TRACK_PEAK' ]; then
			if [ "$applyGainType" = 'ALBUM_PEAK' ]; then
				gainPeak="$( grep -Fi 'replaygain_album_peak' "$sourceTagFile" 2>/dev/null | cut -d '=' -f 2 )"
			elif [ "$applyGainType" = 'TRACK_PEAK' ]; then
				gainPeak="$( grep -Fi 'replaygain_track_peak' "$sourceTagFile" 2>/dev/null | cut -d '=' -f 2 )"
			fi
			if [ -n "$gainPeak" ]; then
				if [ "${gainPeak:0:1}" = '0' ]; then
					gainValue="$( computeGainFromPeak "$gainPeak" )"
					if [ "${gainValue:0:1}" != '-' ]; then # gainValue is positive
						if [ "${peakReference:0:1}" = '-' ]; then
							gainValue="${peakReference}"
						else
							gainValue=''
						fi
					else # gainValue is negative
						if [ "${peakReference:0:1}" = '-' ]; then
							gainValue="$( printf "%.2f" "$( echo "scale=5; (${gainValue:1} + ${peakReference}) / 1" | bc 2>> "$Self_Errors_File" )" )"
							if [ "${gainValue:0:1}" != '-' ]; then
								gainValue="+${gainValue}"
							fi
						else
							gainValue="+${gainValue:1}"
						fi
					fi
				elif [ "${peakReference:0:1}" = '-' ]; then
					gainValue="$peakReference"
				fi
			fi
		else
			gainValue="$applyGainType"
		fi

		if [ -n "$gainValue" ]; then
			gaincmd="gain $gainValue"
		fi
	fi

	if [ "$applyGain" = 'true' -a -z "$gainValue" ]; then
		printMessage 'warning' 'processing' "file:${sourceFile}" $processNumber "threads:1" "no gain value"
	fi

	nChannels=$( getNumberOfChannels "$wavFile" )
	if [ -z "$nChannels" -o "$nChannels" = '0' ]; then
		nChannels=2
	fi

	if [ "$preventClipping" = 'true' ]; then
		soxGuard='-G'
	fi

	if [ -n "$bitDepth" ]; then
		bitdepthcmd="-b $bitDepth"
	fi

	if [ -n "$samplingRate" ]; then
		ratecmd="rate -v $samplingRate"
	fi

	if [ -n "$bitDepth" -o -n "$samplingRate" ]; then
		dithercmd='dither -a -s' # FL, FR, C, LFE, SL, SR, BL, BR; 1/4
	fi

	# convert to stereo (and at the same time, resample and / or apply gain if requested)
	if [ "$convertToStereo" != 'false' ]; then
		if [ $nChannels -gt 2 ]; then
			downmixToStereo || exitCode=$Ex_Io_Err
		elif [ $nChannels -eq 1 ]; then
			upmixToStereo || exitCode=$Ex_Io_Err
		fi
	fi

	# resample (and apply gain if requested) if not already done
	# make sure to test both wavProcessed != 'true' and ec = Ex_Ok, because wavProcessed will only be true if prior processing succeeded
	if [ $exitCode -eq $Ex_Ok -a "$wavProcessed" != 'true' ]; then # no prior processing, resampling has not yet be done
		if [ -n "$bitdepthcmd" -o -n "$ratecmd" ]; then
			sox $soxGuard "$wavFile" $bitdepthcmd "$resampledWavFile" $gaincmd $ratecmd $dithercmd 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Io_Err
			if [ $exitCode -eq $Ex_Ok -a -f "$resampledWavFile" ]; then
				rm -f "$wavFile" &&  mv -f "$resampledWavFile" "$wavFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Io_Err
				if [ $exitCode -eq $Ex_Ok ]; then
					isWavProcessed 'true'
				fi
			fi
			if [ -e "$resampledWavFile" ]; then rm -f "$resampledWavFile"; fi
		fi
	fi

	# apply gain if not already done
	if [ $exitCode -eq $Ex_Ok -a "$wavProcessed" != 'true' -a -n "$gaincmd" ]; then # no prior processing, gain has not yet been applied
		# debug "sox gaincmd=[$gaincmd]"
		sox $soxGuard "$wavFile" "$resampledWavFile" $gaincmd 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Io_Err
		if [ $exitCode -eq $Ex_Ok -a -f "$resampledWavFile" ]; then
			rm -f "$wavFile" &&  mv -f "$resampledWavFile" "$wavFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Io_Err
			if [ $exitCode -eq $Ex_Ok ]; then
				isWavProcessed 'true'
			fi
		fi
		if [ -e "$resampledWavFile" ]; then rm -f "$resampledWavFile"; fi
	fi

	return $exitCode
}

decode () {
	local exitCode=$Ex_Ok sourceTagFormat
	local soxGuard='' kfm='' nChannels=2 gaincmd='' ratecmd='' bitdepthcmd='' dithercmd='' gainPeak=''
	local destFileTargetPath copyFileTargetPath gotWavOutputCodec

	isWavProcessed 'false' ; ec=$?
	if [ -e "$copyFile" ]; then
		case "$sourceExtension" in
			wav)
				sourceTagFormat='vc'
				if [ -L "$copyFile" ]; then
					if [ "$gotWavOutputCodec" = 'true' ]; then
						getOutputCodecDestFile "$sourceFile"
						destFileTargetPath="$( readlink -f "$destFile" )"
						copyFileTargetPath="$( readlink -f "$copyFile" )"
						if [ "$destFileTargetPath" = "$copyFileTargetPath" ]; then
							cp "$copyFileTargetPath" "$wavFile" >/dev/null 2>&1 || exitCode=$Ex_Ko
						else
							mv "$copyFile" "$wavFile" 1>/dev/null 2>&1 || exitCode=$Ex_Ko
						fi
					else
						cp "$copyFile" "$wavFile" 1>/dev/null 2>&1 || exitCode=$Ex_Ko
					fi
				elif [ "$outputCodecs" = 'WAV' ]; then
					mv "$copyFile" "$wavFile" 1>/dev/null 2>&1 || exitCode=$Ex_Ko
				else
					cp "$copyFile" "$wavFile" 1>/dev/null 2>&1 || exitCode=$Ex_Ko
				fi
				touch "$sourceTagFile"
				;;

			aiff|caf)
				sourceTagFormat='vc'
				sox "$copyFile" -t wav "$wavFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				touch "$sourceTagFile"
				;;

			# decodeFLAC
			flac)
				sourceTagFormat='vc'
				if [ "$keepWavMetadata" = 'true' ]; then
					if ! flac -s -d --keep-foreign-metadata -o "$wavFile" "$copyFile" 1>/dev/null 2>&1; then
						if [ -e "$wavFile" ]; then rm -f "$wavFile"; fi
						flac -s -d -o "$wavFile" "$copyFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
					fi
				else
					flac -s -d -o "$wavFile" "$copyFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				fi
				if [ $exitCode -eq $Ex_Ok ]; then
					metaflac --no-utf8-convert --export-tags-to="$sourceTagFile" "$copyFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
					if [ $exitCode -eq $Ex_Ok ]; then
						extractFlacArtwork || exitCode=$Ex_Ko
					fi
					if [ $exitCode -eq $Ex_Ok -a -e "$sourceTagFile" ]; then
						grep -iv 'WAVEFORMATEXTENSIBLE_CHANNEL_MASK=' "$sourceTagFile" > "${sourceTagFile}.tmp"
						mv "${sourceTagFile}.tmp" "$sourceTagFile"
					fi
				fi
				;;

			# decodeWV
			wv)
				sourceTagFormat='ape' kfm='-w'
				if [ "$keepWavMetadata" = 'true' ]; then kfm='' ; fi
				nThreads=$( getNumberOfAvailableThreads "$fileIndex" $WavPack_Max_Threads )
				wvunpack -q $kfm -m --threads=$nThreads -o "$wavFile" "$copyFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				if [ $exitCode -eq $Ex_Ok ]; then
					APEv2 -z "$copyFile" 2>> "$Self_Errors_File" | grep -vE '(=data:)|(=artwork:)' | $sedcmd -e 's@\\n@\n@g' -e 's@\\x00@\x02@g' > "$sourceTagFile" 2>/dev/null
					extractAPEv2Artwork && extractAPEv2Binaries
				fi
				;;

			# decodeAPE
			ape)
				sourceTagFormat='ape'
				nThreads=$( getNumberOfAvailableThreads "$fileIndex" )
				mac "$copyFile" "$wavFile" -d -threads=$nThreads 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				if [ $exitCode -eq $Ex_Ok ]; then
					APEv2 -z "$copyFile" 2>> "$Self_Errors_File" | grep -vE '(=data:)|(=artwork:)' | $sedcmd -e 's@\\n@\n@g' -e 's@\\x00@\x02@g' > "$sourceTagFile" 2>/dev/null
					extractAPEv2Artwork && extractAPEv2Binaries
				fi
				;;

			# decodeALAC
			m4a)
				sourceTagFormat='m4a'
				nThreads=$( getNumberOfAvailableThreads "$fileIndex" )
				ffmpeg -i "$copyFile" -threads ${nThreads} "$wavFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				if [ $exitCode -eq $Ex_Ok ]; then
					ffmpeg -i "$copyFile" -f ffmetadata "$sourceTagFile" 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
					if [ $exitCode -eq $Ex_Ok ]; then
						grep -ivE '^(;|major_brand=|minor_version=|compatible_brands=|encoder=)' "$sourceTagFile" > "${sourceTagFile}.tmp" 2>> "$Self_Errors_File"
						mv "${sourceTagFile}.tmp" "$sourceTagFile" 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
					fi
				fi
				;;

			*) exitCode=$Ex_Ko ;;
		esac
	else
		exitCode=$Ex_Ko
	fi

	if [ $exitCode -eq $Ex_Ok -a "$wavMustBeProcessed" = 'true' ]; then
		processWavFile ; exitCode=$?
	fi

	if [ $exitCode -ne $Ex_Ok ]; then
		rm -f "$wavFile" "$copyFile" "${copyFile}c" "$resampledWavFile" "$wavProcessedStatusFile" # in case it exists
		rm -f "${Self_Control_Dir}/${paddedFileIndex}_encoding_"*.job # delete all codec lock files
		rm -f "${Self_Control_Dir}/${paddedFileIndex}_needsWAV_"*.info # delete associated lock files
		if [ $exitCode -eq $Ex_Io_Err ]; then
			printMessage 'error' 'processing' "file:${sourceFile}" $processNumber
		else
			printMessage 'error' 'decoding' "file:${sourceFile}" $processNumber
		fi
		return $Ex_Ko
	fi

	if [ "$gnustat" = 'true' ]; then
		$statcmd -L --printf ' + %s' "$wavFile" >> "${Self_Data_Dir}/bytes" 2>> "$Self_Errors_File"
	else
		$statcmd -L -n -f ' + %z' "$wavFile" >> "${Self_Data_Dir}/bytes" 2>> "$Self_Errors_File"
	fi

	if [ "$outputCodecs" != "WAV" ]; then
		processSourceTagFile
		for outputCodec in $outputCodecs; do
			case "$outputCodec" in
				FLAC|lossyFLAC|OggVorbis|Opus) convertTags $sourceTagFormat 'vc' ;;
				WavPack*|MonkeysAudio) convertTags $sourceTagFormat 'ape' ;;
				MP3) convertTags $sourceTagFormat 'mp3' ;;
				AAC|ALAC) convertTags $sourceTagFormat 'm4a' ;;
			esac
		done
	fi

	return $exitCode
}

getEncoderVersions () {
	local outputCodec oggencPath vorbisPrefix libvorbisVersion

	for outputCodec in $outputCodecs; do
		case "$outputCodec" in
			FLAC) flacVersion="$( flac --version | head -n 1 )"; flacVersion="${flacVersion##* }" ;;
			MonkeysAudio) apeVersion="$( mac 2>&1 | grep -F '(c)' | tr -d ' ' | cut -d '(' -f 2 | cut -d ')' -f 1 )"; apeVersion="${apeVersion#v}" ;;
			MP3) lameVersion="$( lame --version 2>/dev/null | grep -E 'LAME.*version' | cut -d 'v' -f 2 | cut -d '(' -f 1 | cut -d ' ' -f 2- )" ; lameVersion="${lameVersion% *}" ;;
			AAC) aacVersion="$( ffmpeg -version 2>/dev/null | grep -E '^ffmpeg version' | cut -d ' ' -f 3 )" ;;
			ALAC) alacVersion="$( ffmpeg -version 2>/dev/null | grep -E '^ffmpeg version' | cut -d ' ' -f 3 )" ;;
			Opus) opusVersion="$( opusenc --version 2>/dev/null | grep -F 'opusenc' )" ;;

			WavPack|WavPackHybrid|WavPackLossy)
				wavpackVersion="$( wavpack --version 2>/dev/null | head -n 1 )"
				wavpackVersion="${wavpackVersion##* }"
				;;

			lossyFLAC)
				lossywavVersion="$( lossywav -v 2>/dev/null | grep -F 'lossyWAV' | tr -d '\r\n' )" # recent lossyWAV
				if [ -z "$lossywavVersion" ]; then
					lossywavVersion="$( lossywav -v 2>&1 | grep -F 'lossyWAV' | tr -d '\r\n' )" # old lossyWAV
				fi
				lossywavVersion="${lossywavVersion##* }"
				;;

			OggVorbis)
				oggencVersion="$( oggenc -V | tr -cd '0-9.' )"
				oggencPath="$( which oggenc )"
				vorbisPrefix="${oggencPath%/oggenc}"; vorbisPrefix="${vorbisPrefix%/bin}"
				if [ -f "${vorbisPrefix}/lib/pkgconfig/vorbisenc.pc" ]; then
					libvorbisVersion="$( grep -i 'version' "${vorbisPrefix}/lib/pkgconfig/vorbisenc.pc" | tr -cd '0-9.' )"
					oggencVersion="${oggencVersion}, libvorbis $libvorbisVersion"
				fi
				;;
		esac
	done
}

isFileNewer () {
	local fileA="$1" fileB="$2" ctimeA ctimeB

	# Don't use 'test -nt' because it doesn't work on files touched by 'caudec -T '
	if [ -e "$fileA" -a -e "$fileB" ]; then
		if [ "$gnustat" = 'true' ]; then
			ctimeA="$( $statcmd -c '%Z' "$fileA" )"
			ctimeB="$( $statcmd -c '%Z' "$fileB" )"
		else
			ctimeA="$( $statcmd -f '%c' "$fileA" )"
			ctimeB="$( $statcmd -f '%c' "$fileB" )"
		fi
		if [ $ctimeA -gt $ctimeB ]; then
			return $Ex_Ok
		else
			return $Ex_Ko
		fi
	else
		return $Ex_Ok
	fi
}

areInodesDifferent () {
	local fileA="$1" fileB="$2" inodeA inodeB

	if [ -e "$fileA" -a -e "$fileB" ]; then
		inodeA="$( ls -i "$fileA" 2>/dev/null | cut -d " " -f 1 2>/dev/null )"
		inodeB="$( ls -i "$fileB" 2>/dev/null | cut -d " " -f 1 2>/dev/null )"
		if [ "$inodeA" != "$inodeB" ]; then
			return $Ex_Ok
		else
			return $Ex_Ko
		fi
	else
		return $Ex_Ok
	fi
}

copyOrLinkAllFiles () {
	local codec="$1" sourceDirFile otherFileBasename destOtherFile destOtherLinkedFile
	for sourceDirFile in "$sourceDirname"/*; do
		case "$sourceDirFile" in
			*.wav|*.caf|*.aiff|*.flac|*.wv|*.wvc|*.ape|*.ogg|*.mp3|*.m4a|*.opus) continue ;;
		esac
		if [ -f "$sourceDirFile" ]; then
			otherFileBasename="${sourceDirFile##*/}"
			destOtherFile="${destPath}/${otherFileBasename}"
			if [ "$codec" = "WavPackLossy" -a -n "$linkDir" ]; then
				destOtherLinkedFile="${destLinkPath}/${otherFileBasename}"
				if areInodesDifferent "$destOtherFile" "$destOtherLinkedFile"; then
					rm -f "$destOtherLinkedFile" 1>/dev/null 2>> "$Self_Errors_File" &&
					ln -f "$destOtherFile" "$destOtherLinkedFile" 1>/dev/null 2>> "$Self_Errors_File"
				fi
			else
				if isFileNewer "$sourceDirFile" "$destOtherFile"; then
					cp "$sourceDirFile" "$destOtherFile" 1>/dev/null 2>> "$Self_Errors_File"
				fi
			fi
		fi
	done
}

copyOrLinkCommaSeparatedFiles () {
	local codec="$1" pattern="$2" listOfOtherFiles otherFile extOtherFile otherFileBasename destOtherFile destOtherLinkedFile

	OIFS="$IFS"; IFS=','
	read -a listOfOtherFiles <<< "$pattern"
	for otherFile in "${listOfOtherFiles[@]}"; do
		case "$otherFile" in
			.*)
				for extOtherFile in "$sourceDirname"/*"$otherFile"; do
					if [ -f "$extOtherFile" ]; then
						otherFileBasename="${extOtherFile##*/}"
						destOtherFile="${destPath}/${otherFileBasename}"
						if [ "$codec" = "WavPackLossy" -a -n "$linkDir" ]; then
							destOtherLinkedFile="${destLinkPath}/${otherFileBasename}"
							if areInodesDifferent "$destOtherFile" "$destOtherLinkedFile"; then
								rm -f "$destOtherLinkedFile" 1>/dev/null 2>> "$Self_Errors_File" &&
								ln -f "$destOtherFile" "$destOtherLinkedFile" 1>/dev/null 2>> "$Self_Errors_File"
							fi
						else
							if isFileNewer "$extOtherFile" "$destOtherFile"; then
								cp "$extOtherFile" "$destOtherFile" 1>/dev/null 2>> "$Self_Errors_File"
							fi
						fi
					fi
				done
			;;

			*)
				if [ -f "${sourceDirname}/${otherFile}" ]; then
					destOtherFile="${destPath}/${otherFile}"
					if [ "$codec" = "WavPackLossy" -a -n "$linkDir" ]; then
						destOtherLinkedFile="${destLinkPath}/${destOtherFile}"
						if areInodesDifferent "$destOtherFile" "$destOtherLinkedFile"; then
							rm -f "$destOtherLinkedFile" 1>/dev/null 2>> "$Self_Errors_File" &&
							ln -f "$destOtherFile" "$destOtherLinkedFile" 1>/dev/null 2>> "$Self_Errors_File"
						fi
					else
						if isFileNewer "$extOtherFile" "$destOtherFile"; then
							cp "${sourceDirname}/${otherFile}" "$destOtherFile" 1>/dev/null 2>> "$Self_Errors_File"
						fi
					fi
				fi
			;;
		esac
	done
	IFS="$OIFS"
}

copyOrLinkFile () {
	local codec="$1" otherFile="$2" extOtherFile otherFileBasename destOtherFile destOtherLinkedFile

	case "$otherFile" in
		.*)
			for extOtherFile in "$sourceDirname"/*"$otherFile"; do
				if [ -f "$extOtherFile" ]; then
					otherFileBasename="${extOtherFile##*/}"
					destOtherFile="${destPath}/${otherFileBasename}"
					if [ "$codec" = "WavPackLossy" -a -n "$linkDir" ]; then
						destOtherLinkedFile="${destLinkPath}/${otherFileBasename}"
						if areInodesDifferent "$destOtherFile" "$destOtherLinkedFile"; then
							rm -f "$destOtherLinkedFile" 1>/dev/null 2>> "$Self_Errors_File" &&
							ln -f "$destOtherFile" "$destOtherLinkedFile" 1>/dev/null 2>> "$Self_Errors_File"
						fi
					else
						if isFileNewer "$extOtherFile" "$destOtherFile"; then
							cp "$extOtherFile" "$destOtherFile" 1>/dev/null 2>> "$Self_Errors_File"
						fi
					fi
				fi
			done
		;;

		*)
			if [ -f "${sourceDirname}/${otherFile}" ]; then
				destOtherFile="${destPath}/${otherFile}"
				if [ "$codec" = "WavPackLossy" -a -n "$linkDir" ]; then
					destOtherLinkedFile="${destLinkPath}/${otherFile}"
					if areInodesDifferent "$destOtherFile" "$destOtherLinkedFile"; then
						rm -f "$destOtherLinkedFile" 1>/dev/null 2>> "$Self_Errors_File" &&
						ln -f "$destOtherFile" "$destOtherLinkedFile" 1>/dev/null 2>> "$Self_Errors_File"
					fi
				else
					if isFileNewer "${sourceDirname}/${otherFile}" "$destOtherFile"; then
						cp "${sourceDirname}/${otherFile}" "$destOtherFile" 1>/dev/null 2>> "$Self_Errors_File"
					fi
				fi
			fi
		;;
	esac
}

copyOrLinkOtherFiles () {
	local codec="$1"

	pattern="$( getCodecOtherFiles "$codec" )"

	if [ -n "$pattern" ]; then
		case "$pattern" in
			all) copyOrLinkAllFiles "$codec" ;;
			*,*) copyOrLinkCommaSeparatedFiles "$codec" "$pattern" ;;
			*) copyOrLinkFile "$codec" "$pattern" ;;
		esac
	fi
}

encode () {
	local exitCode=$Ex_Ok nDecodingThreads=$1 nThreads=1
	local pattern="x${outputCodec}Y" kfm='' statusInfo='' nRunningProcesses listOfOtherFiles
	local audioFile otherFile otherFileBasename extOtherFile destOtherFile compressionTag='' id3CompressionTag=''
	local nChannels compressionParam qualityArg coverArtFile='' doEmbedCoverArt='true' bitsPerSample
	local embeddedArtworkBytes=0 padding
	# local doEmbedBinaries='true' # FIXME with a new -F parameter

	doEmbedCoverArt="$( shouldEmbedCoverArt "$outputCodec" )"
	# doEmbedBinaries="$( shouldEmbedBinaries "$outputCodec" )" # FIXME with a new -F parameter
	case "$outputCodec" in
		WAV)
			if [ "$sourceIsLossyWAV" = 'true' ]; then
				destExtension='lossy.wav'
			else
				destExtension='wav'
			fi
			encodedFile="${Self_Swap_Dir}/${paddedFileIndex}_${outputCodec}.${destExtension}"
			ln -s "$wavFile" "$encodedFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			;;

		AIFF)
			destExtension='aiff'; encodedFile="${Self_Swap_Dir}/${paddedFileIndex}_${outputCodec}.${destExtension}"
			sox "$wavFile" "$encodedFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			;;

		CAF)
			destExtension='caf'; encodedFile="${Self_Swap_Dir}/${paddedFileIndex}_${outputCodec}.${destExtension}"
			sox "$wavFile" "$encodedFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			;;

		# encodeALAC
		ALAC)
			destExtension='m4a'; encodedFile="${Self_Swap_Dir}/${paddedFileIndex}_${outputCodec}.${destExtension}" destTagFile="${Self_Swap_Dir}/${paddedFileIndex}_tags_m4a.txt"
			if [ "$tagCompressionSetting" = 'true' ]; then compressionTag="-metadata comment=$Self_Name $Self_Version / ALAC (ffmpeg $alacVersion)"; fi
			nThreads=$( getNumberOfAvailableThreads "$fileIndex" )
			if [ "$doEmbedCoverArt" = 'true' ]; then
				if [ -z "$sourceCoverArtFile" ]; then
					for coverArtFile in "${Self_Swap_Dir}/${paddedFileIndex}_picture_3-"; do
						if [ ! -r "$coverArtFile" ]; then continue; fi
						case "$coverArtFile" in
							*.txt|*.bin) continue ;;
							*) sourceCoverArtFile="$coverArtFile"
						esac
					done
				fi
			fi
			if [ "$doEmbedCoverArt" = 'true' -a -n "$sourceCoverArtFile" -a -e "$sourceCoverArtFile" ]; then
				printf -- "`tagline`\x00%s\x00%s" "$encodedFile" | xargs -0 ffmpeg -i "$wavFile" -threads ${nThreads} -i "$sourceCoverArtFile" -map 0:a -map 1 -codec copy -metadata:s:v title="Album cover" -metadata:s:v comment="Cover (front)" -disposition:v attached_pic -c:a alac 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			else
				printf -- "`tagline`\x00%s\x00%s" "$encodedFile" | xargs -0 ffmpeg -i "$wavFile" -threads ${nThreads} -c:a alac 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			fi
			;;

		# encodeFLAC
		FLAC)
			destExtension='flac'; encodedFile="${Self_Swap_Dir}/${paddedFileIndex}_${outputCodec}.${destExtension}" destTagFile="${Self_Swap_Dir}/${paddedFileIndex}_tags_vc.txt" kfm=''
			# Kohlrabi is a very cool dude
			if [ "$keepWavMetadata" = 'true' ]; then kfm='--keep-foreign-metadata' ; fi
			if [ "$tagCompressionSetting" = 'true' ]; then compressionTag="ENCODING=$Self_Name $Self_Version / FLAC $flacVersion / -$compression_FLAC"; fi
			padding=$FLACPadding
			if [ "$doEmbedCoverArt" = 'true' ]; then
				embeddedArtworkBytes="$( getEmbeddedArtworkSize )"
				padding=$(( padding + embeddedArtworkBytes ))
			fi
			nThreads=$( getNumberOfAvailableThreads "$fileIndex" $Flac_Max_Threads )
			printf -- "-s`tagline -T`\x00%s" "$wavFile" | xargs -0 flac -j $nThreads -P $padding $kfm -${compression_FLAC} -o "$encodedFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			if [ $exitCode -eq $Ex_Ok -a "$doEmbedCoverArt" = 'true' ]; then
				importArtworkIntoFLAC || exitCode=$Ex_Ko
			fi
			;;

		# encodeAPE
		MonkeysAudio)
			destExtension='ape'; encodedFile="${Self_Swap_Dir}/${paddedFileIndex}_${outputCodec}.${destExtension}" destTagFile="${Self_Swap_Dir}/${paddedFileIndex}_tags_ape.txt"
			nThreads=$( getNumberOfAvailableThreads "$fileIndex" )
			mac "$wavFile" "$encodedFile" -c${compression_MonkeysAudio}000 -threads=${nThreads} 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			if [ $exitCode -eq $Ex_Ok -a -f "$destTagFile" ]; then
				if [ "$tagCompressionSetting" = 'true' ]; then compressionTag="Encoding=$Self_Name $Self_Version / Monkey's Audio $apeVersion / -c${compression_MonkeysAudio}000"; fi
				printf -- "-R`tagline -t`\x00%s" "$encodedFile" | xargs -0 APEv2 -z 1>/dev/null 2>> "$Self_Errors_File"
				if [ "$doEmbedCoverArt" = 'true' ]; then
					importArtworkIntoAPEv2
				fi
				importBinariesIntoAPEv2 # FIXME with a new -F parameter
			fi
			;;

		# encodeWV
		WavPack)
			destExtension='wv'; encodedFile="${Self_Swap_Dir}/${paddedFileIndex}_${outputCodec}.${destExtension}" destTagFile="${Self_Swap_Dir}/${paddedFileIndex}_tags_ape.txt" kfm='-r'
			if [ -e "${destFile}c" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${destDir}" "$Self_Name -c wv: correction files are present. Please delete them and try again." ; exitCode=$Ex_Ko
			else
				if [ "$keepWavMetadata" = 'true' ]; then kfm=''; fi
				nThreads=$( getNumberOfAvailableThreads "$fileIndex" $WavPack_Max_Threads )
				if [ "$tagCompressionSetting" = 'true' ]; then compressionTag="Encoding=$Self_Name $Self_Version / WavPack $wavpackVersion / -$compression_WavPack"; fi
				printf -- "-q`tagline -w`\x00%s" "$wavFile" | xargs -0 wavpack --threads=$nThreads -m $kfm -${compression_WavPack} -o "$encodedFile" --no-utf8-convert 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				if [ $exitCode -eq $Ex_Ok -a -f "$destTagFile" ]; then
					if [ "$doEmbedCoverArt" = 'true' ]; then
						importArtworkIntoAPEv2
					fi
					importBinariesIntoAPEv2 # FIXME with a new -F parameter
				fi
			fi
			;;

		# encodeWVH
		WavPackHybrid)
			destExtension='wv'; encodedFile="${Self_Swap_Dir}/${paddedFileIndex}_${outputCodec}.${destExtension}" destTagFile="${Self_Swap_Dir}/${paddedFileIndex}_tags_ape.txt" kfm='-r'
			if [ "$keepWavMetadata" = 'true' ]; then kfm=''; fi
			# WavPack Hybrid only supports multithreading for files with more than 2 channels
			nChannels=$( getNumberOfChannels "$wavFile" )
			if [ $nChannels -gt 2 ]; then
				nThreads=$( getNumberOfAvailableThreads "$fileIndex" $WavPack_Max_Threads )
			else
				nThreads=1
			fi
			if [ "$tagCompressionSetting" = 'true' ]; then
				if [ "${average_bitrate_WavPackLossy%.*}" -lt 24 ]; then
					compressionTag="Encoding=$Self_Name $Self_Version / WavPack $wavpackVersion / -$compression_WavPack / $average_bitrate_WavPackLossy bits per sample (ABR)"
				else
					compressionTag="Encoding=$Self_Name $Self_Version / WavPack $wavpackVersion / -$compression_WavPack / $average_bitrate_WavPackLossy kbps (ABR)"
				fi
			fi
			printf -- "-q`tagline -w`\x00%s" "$wavFile" | xargs -0 wavpack --threads=$nThreads -m $kfm -o "$encodedFile" -c${compression_WavPack} -b${average_bitrate_WavPackLossy} --no-utf8-convert 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			if [ $exitCode -eq $Ex_Ok -a -f "$destTagFile" ]; then
				if [ "$doEmbedCoverArt" = 'true' ]; then
					importArtworkIntoAPEv2
				fi
				importBinariesIntoAPEv2 # FIXME with a new -F parameter
			fi
			;;

		# encodeWVL
		WavPackLossy)
			destExtension='wv'; encodedFile="${Self_Swap_Dir}/${paddedFileIndex}_${outputCodec}.${destExtension}" destTagFile="${Self_Swap_Dir}/${paddedFileIndex}_tags_ape.txt" kfm='-r'
			if [ -e "${destFile}c" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${destDir}" "$Self_Name -c wv: correction files are present. Please delete them and try again." ; exitCode=$Ex_Ko
			else
				if [ "$keepWavMetadata" = 'true' ]; then kfm=''; fi
				# WavPack Lossy only supports multithreading for files with more than 2 channels
				nChannels=$( getNumberOfChannels "$wavFile" )
				if [ $nChannels -gt 2 ]; then
					nThreads=$( getNumberOfAvailableThreads "$fileIndex" $WavPack_Max_Threads )
				else
					nThreads=1
				fi
				if [ "$tagCompressionSetting" = 'true' ]; then
					if [ -z "$compression_WavPack" ]; then
						compressionTag="Encoding=$Self_Name $Self_Version / WavPack $wavpackVersion / default / $average_bitrate_WavPackLossy bits per sample (ABR)"
					else
						compressionTag="Encoding=$Self_Name $Self_Version / WavPack $wavpackVersion / -$compression_WavPack / $average_bitrate_WavPackLossy kbps (ABR)"
					fi
				fi
				printf -- "-q`tagline -w`\x00%s" "$wavFile" | xargs -0 wavpack --threads=$nThreads -m $kfm -o "$encodedFile" -$compression_WavPack -b${average_bitrate_WavPackLossy} --no-utf8-convert 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				if [ $exitCode -eq $Ex_Ok -a -f "$destTagFile" ]; then
					if [ "$doEmbedCoverArt" = 'true' ]; then
						importArtworkIntoAPEv2
					fi
					importBinariesIntoAPEv2 # FIXME with a new -F parameter
				fi
			fi
			;;

		# encodeLossyFLAC
		lossyFLAC)
			destExtension='lossy.flac'; encodedFile="${Self_Swap_Dir}/${paddedFileIndex}_${outputCodec}.${destExtension}" destTagFile="${Self_Swap_Dir}/${paddedFileIndex}_tags_vc.txt"
			if [ "$sourceIsLossyWAV" = 'true' ]; then
				printMessage 'warning' 'encoding' "file:${sourceBasename}" $processNumber "${outputCodec}: source is already lossy"
				exitCode=$Ex_Ko
			fi
			namedPipe="${Self_Control_Dir}/${paddedIndexFile}_lossyWAV_pipe.wav"
			if [ "$tagCompressionSetting" = 'true' ]; then compressionTag="ENCODING=$Self_Name $Self_Version / lossyWAV $lossywavVersion / -q $compression_lossyWAV"; fi
			padding=$FLACPadding
			if [ "$doEmbedCoverArt" = 'true' ]; then
				embeddedArtworkBytes="$( getEmbeddedArtworkSize )"
				padding=$(( padding + embeddedArtworkBytes ))
			fi
			# nThreads=$( getNumberOfAvailableThreads "$fileIndex" $Flac_Max_Threads )
			nThreads=1 # flac -5 -e -p is slower than lossyWAV
			bitsPerSample="$( soxi -b "$wavFile" 2>/dev/null )"
			mkfifo "$namedPipe"
			if [ -n "$bitsPerSample" -a $bitsPerSample -lt 24 ]; then
				sox "$wavFile" -b 24 -D -t wav - 2>/dev/null | lossywav - -q $compression_lossyWAV -a 6 -s w -A --scale "$lossyWAV_scale" --stdout --silent 1>/dev/null 2>> "$Self_Errors_File" > "$namedPipe" &
			else
				lossywav "$wavFile" -q $compression_lossyWAV -a 6 -s w -A --scale "$lossyWAV_scale" --stdout --silent 1>/dev/null 2>> "$Self_Errors_File" > "$namedPipe" &
			fi
			printf -- "--totally-silent`tagline -T`\x00%s" "$namedPipe" | xargs -0 flac -j $nThreads -P $padding -5 -e -p -b 512 -o "$encodedFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			rm -f "$namedPipe"
			if [ $exitCode -eq $Ex_Ok -a "$doEmbedCoverArt" = 'true' ]; then
				importArtworkIntoFLAC || exitCode=$Ex_Ko
			fi
			;;

		# encodeMP3
		MP3)
			destExtension='mp3'; encodedFile="${Self_Swap_Dir}/${paddedFileIndex}_${outputCodec}.${destExtension}" destTagFile="${Self_Swap_Dir}/${paddedFileIndex}_tags_mp3.txt"
			if [ "$compression_MP3" = '320' ]; then
				MP3_MODE='CBR' bitrate_MP3=320
			fi
			padding=$ID3Padding
			if [ "$doEmbedCoverArt" = 'true' ]; then
				embeddedArtworkBytes="$( getEmbeddedArtworkSize )"
				padding=$(( padding + embeddedArtworkBytes ))
			fi
			if [ "$MP3_MODE" = 'VBR' ]; then
				if [ "$tagCompressionSetting" = 'true' ]; then id3CompressionTag="$Self_Name $Self_Version / LAME $lameVersion / VBR $compression_MP3"; fi
				lame -S -V $compression_MP3 --noreplaygain --id3v2-only --pad-id3v2-size $padding --ignore-tag-errors -o "$wavFile" "$encodedFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			elif [ "$MP3_MODE" = 'ABR' ]; then
				if [ "$tagCompressionSetting" = 'true' ]; then id3CompressionTag="$Self_Name $Self_Version / LAME $lameVersion / $average_bitrate_MP3 kbps (ABR)"; fi
				lame -S --abr $average_bitrate_MP3 --noreplaygain --id3v2-only --pad-id3v2-size $padding --ignore-tag-errors -o "$wavFile" "$encodedFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			else
				if [ $compression_MP3 -eq "insane" ]; then
					if [ "$tagCompressionSetting" = 'true' ]; then id3CompressionTag="$Self_Name $Self_Version / LAME $lameVersion / 320 kbps (CBR)"; fi
					lame -S --preset insane --noreplaygain --id3v2-only --pad-id3v2-size $padding --ignore-tag-errors -o "$wavFile" "$encodedFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				else
					if [ "$tagCompressionSetting" = 'true' ]; then id3CompressionTag="$Self_Name $Self_Version / LAME $lameVersion / $bitrate_MP3 kbps (CBR)"; fi
					lame -S -b $bitrate_MP3 --cbr --noreplaygain --id3v2-only --pad-id3v2-size $padding --ignore-tag-errors -o "$wavFile" "$encodedFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				fi
			fi
			if [ $exitCode -ne $Ex_Ko ]; then
				if [ -n "$id3CompressionTag" ]; then
					printf -- "`tagline`" | xargs -0 eyeD3 --quiet --to-v2.4 --force-update --encoding 'utf8' --text-frame=TSSE:"$id3CompressionTag" "$encodedFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				else
					printf -- "`tagline`" | xargs -0 eyeD3 --quiet --to-v2.4 --force-update --encoding 'utf8' "$encodedFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				fi
				if [ $exitCode -eq $Ex_Ok -a "$doEmbedCoverArt" = 'true' ]; then
					importArtworkIntoMP3 || exitCode=$Ex_Ko
				fi
			fi
			;;

		# encodeAAC
		AAC)
			destExtension='m4a'; encodedFile="${Self_Swap_Dir}/${paddedFileIndex}_${outputCodec}.${destExtension}" destTagFile="${Self_Swap_Dir}/${paddedFileIndex}_tags_m4a.txt" aaclibs=("aac_at" "libfdk_aac" "aac") aaclib=""
			if [ "$doEmbedCoverArt" = 'true' ]; then
				if [ -z "$sourceCoverArtFile" ]; then
					for coverArtFile in "${Self_Swap_Dir}/${paddedFileIndex}_picture_3-"; do
						if [ ! -r "$coverArtFile" ]; then continue; fi
						case "$coverArtFile" in
							*.txt|*.bin) continue ;;
							*) sourceCoverArtFile="$coverArtFile"
						esac
					done
				fi
			fi

			# https://trac.ffmpeg.org/wiki/Encode/AAC
			for aaclib in "${aaclibs[@]}"; do
				case "$aaclib" in
					aac_at)
						if [ "$AAC_MODE" = "ABR" -a -n "$average_bitrate_AAC" ]; then
							compressionParam="-aac_at_mode abr -b:a" qualityArg="${average_bitrate_AAC}k"
							if [ "$tagCompressionSetting" = 'true' ]; then compressionTag="-metadata comment=$Self_Name $Self_Version / AAC (ffmpeg $aacVersion aac_at) / $bitrate_AAC kbps (ABR)"; fi
						else
							compressionParam="-b:a" qualityArg="${bitrate_AAC}k"
							if [ "$tagCompressionSetting" = 'true' ]; then compressionTag="-metadata comment=$Self_Name $Self_Version / AAC (ffmpeg $aacVersion aac_at) / $bitrate_AAC kbps (CBR)"; fi
						fi
						# debug "aaclib [$aaclib] compressionParam[$compressionParam] qualityArg[$qualityArg]"
						if [ "$doEmbedCoverArt" = 'true' -a -n "$sourceCoverArtFile" -a -e "$sourceCoverArtFile" ]; then
							printf -- "`tagline`\x00%s\x00%s" "$encodedFile" | xargs -0 ffmpeg -i "$wavFile" -i "$sourceCoverArtFile" -map 0:a -map 1 -codec copy -metadata:s:v title="Album cover" -metadata:s:v comment="Cover (front)" -disposition:v attached_pic -c:a $aaclib $compressionParam $qualityArg 1>/dev/null 2>> "$Self_Errors_File"; exitCode=$?
						else
							printf -- "`tagline`\x00%s\x00%s" "$encodedFile" | xargs -0 ffmpeg -i "$wavFile" -c:a $aaclib $compressionParam $qualityArg 1>/dev/null 2>> "$Self_Errors_File"; exitCode=$?
						fi
						if [ $exitCode -ne $Ex_Ko ]; then exitCode=$Ex_Ok; break; fi
						;;

					libfdk_aac)
						compressionParam="-b:a" qualityArg="${bitrate_AAC}k"
						if [ "$tagCompressionSetting" = 'true' ]; then compressionTag="-metadata comment=$Self_Name $Self_Version / AAC (ffmpeg $aacVersion libfdk_aac) / $bitrate_AAC kbps (CBR)"; fi
						# debug "aaclib [$aaclib] compressionParam[$compressionParam] qualityArg[$qualityArg]"
						if [ "$doEmbedCoverArt" = 'true' -a -n "$sourceCoverArtFile" -a -e "$sourceCoverArtFile" ]; then
							printf -- "`tagline`\x00%s\x00%s" "$encodedFile" | xargs -0 ffmpeg -i "$wavFile" -i "$sourceCoverArtFile" -map 0:a -map 1 -codec copy -metadata:s:v title="Album cover" -metadata:s:v comment="Cover (front)" -disposition:v attached_pic -c:a $aaclib $compressionParam $qualityArg 1>/dev/null 2>> "$Self_Errors_File"; exitCode=$?
						else
							printf -- "`tagline`\x00%s\x00%s" "$encodedFile" | xargs -0 ffmpeg -i "$wavFile" -c:a $aaclib $compressionParam $qualityArg 1>/dev/null 2>> "$Self_Errors_File"; exitCode=$?
						fi
						if [ $exitCode -ne $Ex_Ko ]; then exitCode=$Ex_Ok; break; fi
						;;

					aac)
						if [ "$AAC_MODE" != "CBR" ]; then
							if [ -z "$average_bitrate_AAC" -o "$average_bitrate_AAC" != "$bitrate_AAC" ]; then
								bitrate_AAC="$average_bitrate_AAC"
							fi
						fi
						compressionParam="-b:a" qualityArg="${bitrate_AAC}k"
						if [ "$tagCompressionSetting" = 'true' ]; then compressionTag="-metadata comment=$Self_Name $Self_Version / AAC (ffmpeg $aacVersion aac) / $bitrate_AAC kbps (CBR)"; fi
						# debug "aaclib [$aaclib] compressionParam[$compressionParam] qualityArg[$qualityArg]"
						if [ "$doEmbedCoverArt" = 'true' -a -n "$sourceCoverArtFile" -a -e "$sourceCoverArtFile" ]; then
							printf -- "`tagline`\x00%s\x00%s" "$encodedFile" | xargs -0 ffmpeg -i "$wavFile" -i "$sourceCoverArtFile" -map 0:a -map 1 -codec copy -metadata:s:v title="Album cover" -metadata:s:v comment="Cover (front)" -disposition:v attached_pic -c:a $aaclib $compressionParam $qualityArg 1>/dev/null 2>> "$Self_Errors_File"; exitCode=$?
						else
							printf -- "`tagline`\x00%s\x00%s" "$encodedFile" | xargs -0 ffmpeg -i "$wavFile" -c:a $aaclib $compressionParam $qualityArg 1>/dev/null 2>> "$Self_Errors_File"; exitCode=$?
						fi
						if [ $exitCode -ne $Ex_Ko ]; then exitCode=$Ex_Ok; break; fi
						;;
				esac
				if [ $exitCode -eq $Ex_Ok ]; then break; fi
			done
			;;

		# encodeOgg
		OggVorbis)
			destExtension='ogg'; encodedFile="${Self_Swap_Dir}/${paddedFileIndex}_${outputCodec}.${destExtension}" destTagFile="${Self_Swap_Dir}/${paddedFileIndex}_tags_vc.txt"
			if [ "$OggVorbis_MODE" = 'VBR' ]; then
				if [ "$tagCompressionSetting" = 'true' ]; then compressionTag="ENCODING=$Self_Name $Self_Version / oggenc $oggencVersion / -q $compression_OggVorbis"; fi
				printf -- "-Q`tagline -c`\x00%s" "$wavFile" | xargs -0 oggenc -q $compression_OggVorbis -o "$encodedFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			elif [ "$OggVorbis_MODE" = 'ABR' ]; then
				if [ "$tagCompressionSetting" = 'true' ]; then compressionTag="ENCODING=$Self_Name $Self_Version / oggenc $oggencVersion / $average_bitrate_OggVorbis kbps (ABR)"; fi
				printf -- "-Q`tagline -c`\x00%s" "$wavFile" | xargs -0 oggenc --managed -b $average_bitrate_OggVorbis -o "$encodedFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			else
				if [ "$tagCompressionSetting" = 'true' ]; then compressionTag="ENCODING=$Self_Name $Self_Version / oggenc $oggencVersion / $bitrate_OggVorbis kbps (CBR)"; fi
				printf -- "-Q`tagline -c`\x00%s" "$wavFile" | xargs -0 oggenc --managed -b $bitrate_OggVorbis -m $bitrate_OggVorbis -M $bitrate_OggVorbis -o "$encodedFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			fi
			;;

		# encodeOpus
		Opus)
			destExtension='opus'; encodedFile="${Self_Swap_Dir}/${paddedFileIndex}_${outputCodec}.${destExtension}" destTagFile="${Self_Swap_Dir}/${paddedFileIndex}_tags_vc.txt"
			if [ "$Opus_MODE" = 'VBR' ]; then
				if [ "$tagCompressionSetting" = 'true' ]; then compressionTag="ENCODING=$Self_Name $Self_Version / $opusVersion / $compression_Opus kbps (VBR)"; fi
				printf -- "--quiet`tagline --comment`\x00%s`genOpusArtworkCommandLine`\x00%s" "$wavFile" "$encodedFile" | xargs -0 opusenc --padding $OpusPadding --vbr --bitrate $compression_Opus 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			elif [ "$Opus_MODE" = 'ABR' ]; then
				if [ "$tagCompressionSetting" = 'true' ]; then compressionTag="ENCODING=$Self_Name $Self_Version / $opusVersion / $average_bitrate_Opus kbps (ABR)"; fi
				printf -- "--quiet`tagline --comment`\x00%s`genOpusArtworkCommandLine`\x00%s" "$wavFile" "$encodedFile" | xargs -0 opusenc --padding $OpusPadding --cvbr --bitrate $average_bitrate_Opus 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			else
				if [ "$tagCompressionSetting" = 'true' ]; then compressionTag="ENCODING=$Self_Name $Self_Version / $opusVersion / $bitrate_Opus kbps (CBR)"; fi
				printf -- "--quiet`tagline --comment`\x00%s`genOpusArtworkCommandLine`\x00%s" "$wavFile" "$encodedFile" | xargs -0 opusenc --padding $OpusPadding --hard-cbr --bitrate $bitrate_Opus 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			fi
			;;
	esac

	if [ "$copyPath" = 'true' ]; then
		if ! mkdir -p "$destPath" 1>/dev/null 2>&1 ; then
			exitCode=$Ex_Ko
		fi
		if [ "$outputCodec" = "WavPackHybrid" -a -n "$destLinkPath" ]; then
			if ! mkdir -p "$destLinkPath" 1>/dev/null 2>&1 ; then
				exitCode=$Ex_Ko
			fi
		fi
	fi

	if [ "$outputCodec" = 'WAV' ]; then
		statusInfo='decoding'
	else
		statusInfo='encoding'
	fi

	if [ ! -w "$destPath" ]; then
		exitCode=$Ex_Io_Err
	elif [ -e "$destFile" -a ! -w "$destFile" ]; then
		exitCode=$Ex_Io_Err
	fi

	if [ $exitCode -eq $Ex_Ok ]; then
		if [ -e "$encodedFile" ]; then
			chmod 0644 "$encodedFile"
			if [ -e "${encodedFile}c" ]; then # WavPack Hybrid correction files
				chmod 0644 "${encodedFile}c"
			fi
			if [ -L "$encodedFile" ]; then # source WAV symlinked as "$encodedFile"
				cp "$( readlink -f "$encodedFile" )" "$destFile" 1>/dev/null 2>> "$Self_Errors_File"
			else
				mv "$encodedFile" "$destFile" 1>/dev/null 2>> "$Self_Errors_File"
				if [ -e "${encodedFile}c" ]; then  # WavPack Hybrid correction files
					mv "${encodedFile}c" "${destFile}c" 1>/dev/null 2>> "$Self_Errors_File"
				fi
			fi

			if [ "$outputCodec" = "WavPackHybrid" -a -n "$destLinkPath" ]; then
				if [ -e "$destLinkFile" ]; then # delete old link for consistency``
					rm -f "$destLinkFile" 1>/dev/null 2>> "$Self_Errors_File"
				fi
				if [ -f "$destFile" ]; then
					ln -f "$destFile" "$destLinkPath" 1>/dev/null 2>> "$Self_Errors_File"
				fi
			fi

			case $outputCodec in
				WAV|AIFF|CAF)
					printMessage 'success' "$statusInfo" "file:${destFile}" $processNumber "outputCodec:WAV" "threads:$nDecodingThreads"
					;;

				WavPackHybrid)
					if [ -n "$destLinkPath" ]; then
						printMessage 'success' "$statusInfo" "file:${destFile}" $processNumber "outputCodec:${outputCodec}" "threads:$nThreads" "$destLinkPath"
					else
						printMessage 'success' "$statusInfo" "file:${destFile}" $processNumber "outputCodec:${outputCodec}" "threads:$nThreads"
					fi
					;;

				*)
					printMessage 'success' "$statusInfo" "file:${destFile}" $processNumber "outputCodec:${outputCodec}" "threads:$nThreads"
					;;
			esac
		fi
	elif [ $exitCode -eq $Ex_Io_Err ]; then
		printMessage 'error' "$statusInfo" "file:${destFile}" $processNumber 'destination is read-only.'
	else
		rm -f "$encodedFile" 1>/dev/null 2>&1 # in case it exists
		printMessage 'error' "$statusInfo" "file:${destFile}" $processNumber
	fi

	return $exitCode
}

getLock () {
	local lockFile="$1"
	if [ "$OS" = 'Darwin' ]; then
		test -e "$lockFile" && lockf -s -n -t 1 "$lockFile" test -e "$lockFile" 1>/dev/null 2>/dev/null
	else
		test -e "$lockFile" && unlink "$lockFile" 2>/dev/null # FIXME LOCKING
	fi
}

getAndRenameLock () {
	local lockFileOne="$1" lockFileTwo="$2"
	if [ "$OS" = 'Darwin' ]; then
		test -e "$lockFileOne" && lockf -k -s -n -t 1 "$lockFileOne" mv "$lockFileOne" "$lockFileTwo" 1>/dev/null 2>/dev/null
	else
		test -e "$lockFileOne" && mv "$lockFileOne" "$lockFileTwo" 2>/dev/null  # FIXME LOCKING
	fi
}

cleanUpCopyLockFile () {
	local copyLockFile="$1" pid

	if [ -e "${copyLockFile}.lock" ]; then
		pid="$( cat "${copyLockFile}.lock" )"
		if [ -n "$pid" ]; then
			if ! isProcessRunning $pid ; then
				echo '' > "${copyLockFile}.lock" 2>/dev/null
				mv "${copyLockFile}.lock" "$copyLockFile" 1>/dev/null 2>&1
			fi
		fi
	fi
}

prepareSource () {
	local exitCode=$Ex_Ok sourcePath copyLockFile copyDone='false' cptimer1 cptimer2 cpseconds attemptNumber=0

	if [ "$preloadSources" = 'true' -a "$touchFiles" = 'false' ]; then
		if [ "$gnustat" = 'true' ]; then
			copyLockFile="${Self_Io_Dir}/$( $statcmd -c '%d' "$sourceFile" 2>> "$Self_Errors_File" )"
		else
			copyLockFile="${Self_Io_Dir}/$( $statcmd -f '%d' "$sourceFile" 2>> "$Self_Errors_File" )"
		fi
		until test "$copyDone" = 'true' ; do
			# if test -f "$copyLockFile" && mv "$copyLockFile" "${copyLockFile}.lock" 1>/dev/null 2>&1; then
			if getAndRenameLock "$copyLockFile" "${copyLockFile}.lock"; then
				touch "${Self_Instance_Dir}/ioLockFiles/${copyLockFile##*/}"
				echo "$$" > "${copyLockFile}.lock"

				if [ "$gnudate" = 'true' ]; then
					cptimer1="$( $datecmd '+%s.%N' )"
				fi

				cp "$sourceFile" "$copyFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				if [ -e "${sourceFile}c" ]; then # WavPack correction file
					cp "${sourceFile}c" "${copyFile}c" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				fi

				echo '' > "${copyLockFile}.lock" 2>/dev/null
				mv "${copyLockFile}.lock" "$copyLockFile" 1>/dev/null 2>&1 &&
				rm -f "${Self_Instance_Dir}/ioLockFiles/${copyLockFile##*/}" 1>/dev/null 2>&1
				copyDone='true'

				if [ -n "$cptimer1" ]; then
					if [ "$gnudate" = 'true' ]; then
						cptimer2="$( $datecmd '+%s.%N' )"
					fi
					if [ -n "$cptimer2" ]; then
						cpseconds="$( printf 'scale=6; %.6f - %.6f\n' "$cptimer2" "$cptimer1" | bc )"
						echo -n " + $cpseconds" >> "${Self_Data_Dir}/readTimes.txt"
					fi
				fi
			else
				if [ $attemptNumber -ge 100 ]; then
					cleanUpCopyLockFile "$copyLockFile"
					attemptNumber=0
				else
					sleep 0.1
					(( attemptNumber++ ))
				fi
			fi
		done
	else
		if [ "${sourceFile:0:1}" = '/' ]; then # sourceFile is an absolute path
			sourcePath="$sourceFile"
		else # sourceFile is a relative path; prepend current directory
			sourcePath="${PWD}/${sourceFile}"
		fi
		if [ -n "$copyFile" ]; then
			if [ ! -L "$copyFile" ]; then
				ln -s "$sourcePath" "$copyFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			fi

			if [ -e "${sourcePath}c" ]; then # WavPack correction file
				if [ ! -L "${copyFile}c" ]; then
					ln -s "${sourcePath}c" "${copyFile}c" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				fi
			fi
		fi
	fi

	if [ $exitCode -ne $Ex_Ok ]; then
		rm -f "$copyFile" "${copyFile}c" 1>/dev/null 2>&1
	fi

	return $exitCode
}

setControlVariables () {
	copyFile="${Self_Swap_Dir}/${paddedFileIndex}_input.${sourceExtension}"
	wavFile="${Self_Swap_Dir}/${paddedFileIndex}.wav"
	resampledWavFile="${Self_Swap_Dir}/${paddedFileIndex}_resampled.wav"
	wasProcessedFile="${Self_Control_Dir}/${paddedFileIndex}_all_processed.info"
	wavProcessedStatusFile="${Self_Control_Dir}/${paddedFileIndex}_wav_processed.info"
	sourceTagFile="${Self_Swap_Dir}/${paddedFileIndex}_tags_input.txt"
	binariesDir="${Self_Swap_Dir}/${paddedFileIndex}_binaries"
}

transcode () {
	local exitCode=$Ex_Ok allFilesDone allCodecsDone milliseconds fileIndex paddedFileIndex transcodingJobFile
	local decodingJobFile lastCodec="${outputCodecs##* }" copyDone='false' encodingDone='false'
	local nDecodingThreads=1 encodingNeedsWavFile sleepTime="0.05"

	until test "$allFilesDone" = 'true' ; do
		allFilesDone='true'
		while read milliseconds paddedFileIndex fileIndex; do
			sourceFile="${sourceFiles[$fileIndex]}"
			sourceFilename="${sourceFile##*/}"
			sourceExtension="${sourceFile##*.}"
			transcodingJobFile="${Self_Control_Dir}/${paddedFileIndex}_any.job"
			decodingJobFile="${Self_Control_Dir}/${paddedFileIndex}_decoding.job"

			# if test -e "$transcodingJobFile" && mv "$transcodingJobFile" "$decodingJobFile" 2>/dev/null; then
			if getAndRenameLock "$transcodingJobFile" "$decodingJobFile"; then
				allFilesDone='false'
				setControlVariables
				getFileProps "$sourceFile"
				prepareSource &&
				decode || exitCode=$Ex_Ko
				if [ -n "$nThreads" ]; then
					nDecodingThreads=$nThreads
				else
					nDecodingThreads=1
				fi
				rm -f "$decodingJobFile" 1>/dev/null 2>&1
			elif [ -e "$decodingJobFile" ]; then # can't do anything for this track yet, gotta wait for it to be decoded
				allFilesDone='false'
				continue # skip to next track
			fi

			for outputCodec in $outputCodecs; do
				encodingNeedsWavFile="${Self_Control_Dir}/${paddedFileIndex}_needsWAV_${outputCodec}.info"
				encodingJobFile="${Self_Control_Dir}/${paddedFileIndex}_encoding_${outputCodec}.job"
				# if test -e "$encodingJobFile" && unlink "$encodingJobFile" 2>/dev/null; then
				if test -e "$encodingJobFile" && getLock "$encodingJobFile"; then
					allFilesDone='false' allCodecsDone='false'
					setControlVariables
					getFileProps "$sourceFile" "$outputCodec"
					encode $nDecodingThreads || exitCode=$Ex_Ko
					copyOrLinkOtherFiles "$outputCodec"
					if [ "$outputCodec" = "WavPackHybrid" -a -d "$destLinkPath" ]; then
						copyOrLinkOtherFiles "WavPackLossy"
					fi
					rm -f "$encodingNeedsWavFile"

					# Do this in this loop because it is conditional on getting a lock on an encoding job.
					# Doing it outside of this loop would run the following code every $sleepTime seconds per process.
					ls "${Self_Control_Dir}/${paddedFileIndex}_needsWAV_"*.info 1>/dev/null 2>&1 || allCodecsDone='true'
					if [ "$allCodecsDone" = 'true' ]; then
						touch "$wasProcessedFile"
						rm -rf "$wavFile" "$binariesDir" "${Self_Swap_Dir}/${paddedFileIndex}_picture_"* 1>/dev/null 2>&1
					fi
				fi
			done

			if [ -n "$destPath" -a -d "$destPath" -a -w "$destPath" ]; then
				chmod u+rwX "$destPath" "${destPath}"/* 2>/dev/null
			fi
		done < "${Self_Data_Dir}/millisecondsAndFileIndexes.list"
		sleep "$sleepTime" # make sure idling processes don't hog the CPU
	done

	rm -f "${Self_Jobs_Dir}/process.${processNumber}"
	return $exitCode
}

testFile () {
	local exitCode=$Ex_Ok nThreads=1

	if [ -e "$copyFile" ]; then
		case "$copyFile" in
			*.flac) flac -st "$copyFile" 1>/dev/null 2>&1; exitCode=$? ;;

			*.wv)
				nThreads=$( getNumberOfAvailableThreads "$fileIndex" $WavPack_Max_Threads )
				wvunpack --threads=$nThreads -qmv "$copyFile" 1>/dev/null 2>&1; exitCode=$?
				;;

			*.ape)
				nThreads=$( getNumberOfAvailableThreads "$fileIndex" )
				mac "$copyFile" -V -threads=$nThreads 1>/dev/null 2>&1; exitCode=$?
				;;

			*) printMessage 'warning' 'testing' 'unsupported' "file:${sourceFile}" $processNumber 'unsupported format' ; return $Ex_Ko ;;
		esac
	else
		exitCode=$Ex_Ko
	fi

	if [ $exitCode -eq $Ex_Ok ]; then
		printMessage 'success' 'testing' $processNumber "threads:$nThreads" "file:${sourceFile}"
	else
		printMessage 'error' 'testing' $processNumber "file:${sourceFile}"
	fi

	return $exitCode
}

testFiles () {
	local exitCode=$Ex_Ok jobFile
	while read milliseconds paddedFileIndex fileIndex; do
		sourceFile="${sourceFiles[$fileIndex]}"
		sourceFilename="${sourceFile##*/}"
		sourceExtension="${sourceFile##*.}"
		copyFile="${Self_Swap_Dir}/${paddedFileIndex}_input.${sourceExtension}"
		jobFile="${Self_Control_Dir}/${paddedFileIndex}_any.job"
		wasProcessedFile="${Self_Control_Dir}/${paddedFileIndex}_all_processed.info"

		if getLock "$jobFile"; then
			prepareSource &&
			testFile || exitCode=$Ex_Ko
			if [ -e "$copyFile" ]; then rm -f "$copyFile" "${copyFile}c" 1>/dev/null 2>&1; fi
			touch "$wasProcessedFile"
		fi
	done < "${Self_Data_Dir}/millisecondsAndFileIndexes.list"

	rm -f "${Self_Jobs_Dir}/process.${processNumber}"
	return $exitCode
}

showInternalHash () {
	local exitCode=$Ex_Ok hash

	if [ -e "$sourceFile" ]; then
		case "$sourceFile" in
			*.flac) hash="$( metaflac --show-md5sum "$sourceFile" )" ;;
			*.wv) hash="$( wvunpack -f7 "$sourceFile" 2>/dev/null )" ;;
			*) printMessage 'warning' 'hashing' '' 'unsupported format' "file:${sourceFile}" $processNumber ; return $Ex_Ko ;;
		esac
	else
		exitCode=$Ex_Ko
	fi

	if [ $exitCode -eq $Ex_Ok -a -n "$hash" ]; then
		printMessage 'info' 'hashing' "hash:$hash" "hashType:MD5" "file:${sourceFile}" "threads:1" $processNumber
	else
		printMessage 'error' 'hashing' "" "file doesn't have an internal hash" "file:${sourceFile}" $processNumber
	fi
	return $exitCode
}

showInternalHashes () {
	local exitCode=$Ex_Ok jobFile
	while read milliseconds paddedFileIndex fileIndex; do
		sourceFile="${sourceFiles[$fileIndex]}"
		sourceFilename="${sourceFile##*/}"
		sourceExtension="${sourceFile##*.}"
		copyFile="${Self_Swap_Dir}/${paddedFileIndex}_input.${sourceExtension}"
		jobFile="${Self_Control_Dir}/${paddedFileIndex}_any.job"
		wasProcessedFile="${Self_Control_Dir}/${paddedFileIndex}_all_processed.info"

		if getLock "$jobFile"; then
			prepareSource &&
			showInternalHash || exitCode=$Ex_Ko
			if [ -e "$copyFile" ]; then rm -f "$copyFile" "${copyFile}c" 1>/dev/null 2>&1; fi
			touch "$wasProcessedFile"
		fi
	done < "${Self_Data_Dir}/millisecondsAndFileIndexes.list"

	rm -f "${Self_Jobs_Dir}/process.${processNumber}"
	return $exitCode
}

showTrackInformation () {
	local exitCode=$Ex_Ok nChannels bitDepth samplingRate nSamples multiples cddaSamples sectorSize=588 mediaType
	local floatOrInt floatStr="" something rest bitrate=0 bytesLossy bytesLossless

	if [ -e "$sourceFile" ]; then
		case "$sourceFile" in
			*.flac)
				read -d '\n' nChannels bitDepth samplingRate nSamples < <( metaflac --show-channels --show-bps --show-sample-rate --show-total-samples "$sourceFile" 2>/dev/null )
				;;

			*.wv)
				line="$( wvunpack -f "$sourceFile" 2>/dev/null )"
				OIFS="$IFS"
				IFS=";"
				read samplingRate bitDepth floatOrInt nChannels something nSamples rest <<< "$line"
				IFS="$OIFS"

				# FIXME
				# if [ "$floatOrInt" = "float" ]; then
				# 	floatStr=".0"
				# fi
				;;

			*)
				while read line; do
					case $line in
						channels*) nChannels="${line##*=}" ;;
						bits_per_raw_sample*|bits_per_sample*)
							if [ -z "$bitDepth" -o "$bitDepth" = "0" ]; then
								bitDepth="${line##*=}"
								# FIXME
								# if [ "${bitDepth:0:1}" = "f" -o "${bitDepth:0:1}" = "d" ]; then
								# 	floatStr=".0"
								# fi
								bitDepth="$( echo "$bitDepth" | tr -cd [0-9] )"
							fi
							;;
						sample_rate*) samplingRate="${line##*=}" ;;
						duration_ts*) nSamples="${line##*=}" ;;
					esac
				done < <( ffprobe -print_format 'default' -show_streams -select_streams 'a:0' "$sourceFile" 2>/dev/null )
				;;
		esac

		if [ -z "$bitDepth" -o "$bitDepth" = "0" ]; then
			bitDepth="NA"
		else
			bitDepth="$( printf "%2s" "$bitDepth" )"
		fi

		case "$sourceFile" in
			*.flac|*.wv|*.ape|*.m4a)
				if [ -n "$nSamples" ]; then
					multiples=$(( nSamples / sectorSize ))
					cddaSamples=$(( multiples * sectorSize ))
					if [ $nSamples -eq $cddaSamples -a "$nChannels" = "2" -a "$bitDepth" = "16" -a "$samplingRate" = "44100" ]; then
						mediaType="CDDA"
					else
						mediaType="non-CDDA"
					fi
				fi
				;;
		esac
	else
		exitCode=$Ex_Ko
	fi

	case "$sourceFile" in
		*.wv)
			if [ -f "${sourceFile}c" ]; then
				if [ "$gnustat" = 'true' ]; then
					bytesLossy="$( $statcmd -L --printf '%s' "$sourceFile" 2>/dev/null )"
					bytesLossless="$( $statcmd -L --printf '%s' "${sourceFile}c" 2>/dev/null )"
				else
					bytesLossy="$( $statcmd -L -n -f '%z' "$sourceFile" 2>/dev/null )"
					bytesLossless="$( $statcmd -L -n -f '%z' "${sourceFile}c" 2>/dev/null )"
				fi
				bitrate="$( printf "%.0f" "$( echo "scale=3; ($bytesLossy + $bytesLossless) * 8 * $samplingRate / $nSamples" | bc )" )"
			else
				bitrate="$( ffprobe -show_format -print_format flat "$sourceFile" 2>/dev/null | grep -E '^format.bit_rate=' | tr -cd [0-9] )"
			fi
		;;

		*) bitrate="$( ffprobe -show_format -print_format flat "$sourceFile" 2>/dev/null | grep -E '^format.bit_rate=' | tr -cd [0-9] )" ;;
	esac
	case "$bitrate" in
		[0-9]*) true ;;
		"000"|*) bitrate=0 ;;
	esac

	if [ $exitCode -eq $Ex_Ok ]; then
		printMessage 'success' "characteristics" "characteristics:${nChannels};${bitDepth}${floatStr};${samplingRate};${bitrate}" "mediaType:${mediaType}" "file:${sourceFile}" $processNumber
	else
		printMessage 'error' 'characteristics' "characteristics:0;00;00000;0" "mediaType:${mediaType}" "file:${sourceFile}" $processNumber
	fi
	return $exitCode
}

showTracksInformation () {
	local exitCode=$Ex_Ok jobFile

	while read milliseconds paddedFileIndex fileIndex; do
		sourceFile="${sourceFiles[$fileIndex]}"
		sourceFilename="${sourceFile##*/}"
		sourceExtension="${sourceFile##*.}"
		jobFile="${Self_Control_Dir}/${paddedFileIndex}_any.job"
		wasProcessedFile="${Self_Control_Dir}/${paddedFileIndex}_all_processed.info"

		if getLock "$jobFile"; then
			showTrackInformation || exitCode=$Ex_Ko
			touch "$wasProcessedFile"
		fi
	done < "${Self_Data_Dir}/millisecondsAndFileIndexes.list"

	rm -f "${Self_Jobs_Dir}/process.${processNumber}"
	return $exitCode
}

saveReplaygainToMP3 () {
	local exitCode=$Ex_Ok

	if [ "$computeAudioPeaks" = 'true' -a -n "$peakDbfs" ]; then
		eyeD3 --quiet --to-v2.4 \
			--user-text-frame="REPLAYGAIN_${gainType}_GAIN:${gain} dB" \
			--user-text-frame="REPLAYGAIN_${gainType}_PEAK:${peak}" \
			--user-text-frame="AUDIO_${gainType}_PEAK:${peakDbfs} dBFS" \
			"$destFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
	else
		eyeD3 --quiet --to-v2.4 \
			--user-text-frame="REPLAYGAIN_${gainType}_GAIN:${gain} dB" \
			--user-text-frame="REPLAYGAIN_${gainType}_PEAK:${peak}" \
			"$destFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
	fi

	return $exitCode
}

saveGain () {
	local exitCode=$Ex_Ok gainType="$1" gainTypeText gain peak peakDbfs uGain mp3GainSteps clippingPreventionParam=''

	if [ "$gainType" = 'TRACK' ]; then
		gain="$trackGain" peak="$trackPeak" uGain="$trackGain"
	else
		gain="$albumGain" peak="$albumPeak" uGain="$albumGain"
	fi

	if [ "${gain:0:1}" != '-' ]; then
		gain="+${gain}"
	fi

	if [ "$computeAudioPeaks" = 'true' ]; then
		peakDbfs="$( computeGainFromPeak "$peak" )"
		if [ -n "$peakDbfs" ]; then
			if [ "$peakDbfs" = "-0.00" ]; then
				peakDbfs="0.00"
			elif [ "${peakDbfs:0:1}" != '-' -a "$peakDbfs" != "0.00" ]; then
				peakDbfs="+${peakDbfs}"
			fi
		fi
	fi

	case "$destFile" in
		*.flac)
			if [ "$gainType" = 'ALBUM' ]; then
				if [ "$computeAudioPeaks" = 'true' -a -n "$peakDbfs" ]; then
					metaflac \
						--remove-tag="REPLAYGAIN_ALBUM_GAIN" \
						--remove-tag="REPLAYGAIN_ALBUM_PEAK" \
						--remove-tag="AUDIO_ALBUM_PEAK" \
						--set-tag="REPLAYGAIN_ALBUM_GAIN=${gain} dB" \
						--set-tag="REPLAYGAIN_ALBUM_PEAK=${peak}" \
						--set-tag="AUDIO_ALBUM_PEAK=${peakDbfs} dBFS" \
						"$destFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				else
					metaflac \
						--remove-tag="REPLAYGAIN_ALBUM_GAIN" \
						--remove-tag="REPLAYGAIN_ALBUM_PEAK" \
						--set-tag="REPLAYGAIN_ALBUM_GAIN=${gain} dB" \
						--set-tag="REPLAYGAIN_ALBUM_PEAK=${peak}" \
						"$destFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				fi
			else
				if [ "$computeAudioPeaks" = 'true' -a -n "$peakDbfs" ]; then
					metaflac \
						--remove-tag="AUDIO_TRACK_PEAK" \
						--set-tag="AUDIO_TRACK_PEAK=${peakDbfs} dBFS" \
						"$destFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				fi
			fi
			;;

		*.wv)
			if [ "$gainType" = 'ALBUM' ]; then
				if [ "$computeAudioPeaks" = 'true' -a -n "$peakDbfs" ]; then
					wvtag \
						-w "replaygain_album_gain=" \
						-w "replaygain_album_peak=" \
						-w "audio_album_peak=" \
						-w "replaygain_album_gain=${gain} dB" \
						-w "replaygain_album_peak=${peak}" \
						-w "audio_album_peak=${peakDbfs} dBFS" \
						"$destFile" 1>/dev/null 2>/dev/null || exitCode=$Ex_Ko
				else
					wvtag \
						-w "replaygain_album_gain=" \
						-w "replaygain_album_peak=" \
						-w "replaygain_album_gain=${gain} dB" \
						-w "replaygain_album_peak=${peak}" \
						"$destFile" 1>/dev/null 2>/dev/null || exitCode=$Ex_Ko
				fi
			else
				if [ "$computeAudioPeaks" = 'true' -a -n "$peakDbfs" ]; then
					wvtag \
						-w "audio_track_peak=" \
						-w "audio_track_peak=${peakDbfs} dBFS" \
						"$destFile" 1>/dev/null 2>/dev/null || exitCode=$Ex_Ko
				fi
			fi
			;;

		*.ape)
			if [ "$gainType" = 'ALBUM' ]; then
				if [ "$computeAudioPeaks" = 'true' -a -n "$peakDbfs" ]; then
					APEv2 \
						-r "replaygain_album_gain" \
						-r "replaygain_album_peak" \
						-r "audio_album_peak" \
						-t "replaygain_album_gain=${gain} dB" \
						-t "replaygain_album_peak=${peak}" \
						-t "audio_album_peak=${peakDbfs} dBFS" \
						"$destFile" 1>/dev/null 2>/dev/null || exitCode=$Ex_Ko
				else
					APEv2 \
						-r "replaygain_album_gain" \
						-r "replaygain_album_peak" \
						-t "replaygain_album_gain=${gain} dB" \
						-t "replaygain_album_peak=${peak}" \
						"$destFile" 1>/dev/null 2>/dev/null || exitCode=$Ex_Ko
				fi
			else
				if [ "$computeAudioPeaks" = 'true' -a -n "$peakDbfs" ]; then
					APEv2 \
						-r "replaygain_track_gain" \
						-r "replaygain_track_peak" \
						-t "replaygain_track_gain=${gain} dB" \
						-t "replaygain_track_peak=${peak}" \
						-r "audio_track_peak" \
						-t "audio_track_peak=${peakDbfs} dBFS" \
						"$destFile" 1>/dev/null 2>/dev/null || exitCode=$Ex_Ko
				else
					APEv2 \
						-r "replaygain_track_gain" \
						-r "replaygain_track_peak" \
						-t "replaygain_track_gain=${gain} dB" \
						-t "replaygain_track_peak=${peak}" \
						"$destFile" 1>/dev/null 2>/dev/null || exitCode=$Ex_Ko
				fi
			fi
			;;

		*.ogg)
			if [ "$gainType" = 'ALBUM' ]; then
				if [ "$computeAudioPeaks" = 'true' -a -n "$peakDbfs" ]; then
					vorbiscomment -a \
						-d "REPLAYGAIN_ALBUM_PEAK" \
						-d "REPLAYGAIN_ALBUM_GAIN" \
						-d "AUDIO_ALBUM_PEAK" \
						-t "REPLAYGAIN_ALBUM_PEAK=${peak}" \
						-t "REPLAYGAIN_ALBUM_GAIN=${gain} dB" \
						-t "AUDIO_ALBUM_PEAK=${peakDbfs} dBFS" \
						"$destFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				else
					vorbiscomment -a \
						-d "REPLAYGAIN_ALBUM_PEAK" \
						-d "REPLAYGAIN_ALBUM_GAIN" \
						-t "REPLAYGAIN_ALBUM_PEAK=${peak}" \
						-t "REPLAYGAIN_ALBUM_GAIN=${gain} dB" \
						"$destFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				fi
			else
				if [ "$computeAudioPeaks" = 'true' -a -n "$peakDbfs" ]; then
					vorbiscomment -a \
						-d "AUDIO_TRACK_PEAK" \
						-t "AUDIO_TRACK_PEAK=${peakDbfs} dBFS" \
						"$destFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				fi
			fi
			;;

		*.mp3)
			if [ "$applyGain" = 'true' ]; then
				mp3GainSteps="$( echo "scale=3; $uGain / 1.5" | bc )" # MP3 gain steps are 1.5dB
				mp3GainSteps="$( printf '%.0f' "$mp3GainSteps" )"
				if [ "$preventClipping" = 'true' ]; then
					clippingPreventionParam="-k"
				fi
				mp3gain -s d "$destFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				mp3gain -c $clippingPreventionParam -g "$mp3GainSteps" "$destFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
			else
				mp3gain -s d "$destFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				saveReplaygainToMP3 || exitCode=$Ex_Ko
			fi
			;;

		*) exitCode=$Ex_Ko ;;
	esac

	return $exitCode
}

getFileMilliseconds () {
	local exitCode=$Ex_Ok file="$1" seconds line samplingRate bitDepth format nChannels channelMask nSamples rest

	case "$file" in
		*.wv)
				line="$( wvunpack -f "$file" 2>/dev/null )"
				OIFS="$IFS"
				IFS=";"
				read samplingRate bitDepth format nChannels channelMask nSamples rest <<< "$line"
				echo "scale=0; $nSamples * 1000 / $samplingRate" | bc 2>/dev/null
				IFS="$OIFS"
				return $Ex_Ok
			;;

		*.ape|*.m4a)
			seconds="$( ffprobe -print_format 'default' -show_streams -select_streams 'a:0' "$file" 2>/dev/null | grep -F 'duration=' 2>/dev/null | cut -d '=' -f 2 | tr -cd '0-9.' )"
			;;

		*) seconds="$( soxi -D "$file" )" ;;
	esac

	if [ -n "$seconds" -a "$seconds" != "0" ]; then
		echo "scale=0; $seconds * 1000 / 1" | bc 2>/dev/null
	else
		exitCode=$Ex_Ko
		echo 1
	fi

	return $exitCode
}

getMillisecondsByPaddedFileIndex () {
	local paddedFileIndex="$1"

	read trackMilliseconds paddedFileIndex fileIndex < "${Self_Data_Dir}/${paddedFileIndex}.ms"
	if [ -n "$trackMilliseconds" ]; then
		echo $trackMilliseconds
	else
		echo 1
		return $Ex_Ko
	fi

	return $Ex_Ok
}

computeGainFromPeak () {
	local floatingPointPeak="$1"
	printf "%.2f" "$( echo "scale=10; 20 * l(${floatingPointPeak}) / l(10)" | bc -l 2>> "$Self_Errors_File" )"
}

computeTrackGain () {
	local exitCode=$Ex_Ok line nLines=0 decimals trackGain trackPeak albumGain destTagFile clippingPreventionParam=""
	local nThreads line

	if [ -e "$sourceFile" ]; then
		case "$sourceFile" in
			*.flac)
				metaflac --add-replay-gain "$sourceFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				if [ $exitCode -eq $Ex_Ok ]; then
					trackGain="$( metaflac --show-tag="REPLAYGAIN_TRACK_GAIN" "$sourceFile" 2>> "$Self_Errors_File" | cut -d '=' -f 2 | cut -d ' ' -f 1 | tr -d '+' )"
					trackPeak="$( metaflac --show-tag="REPLAYGAIN_TRACK_PEAK" "$sourceFile" 2>> "$Self_Errors_File" | cut -d '=' -f 2 )"
				fi
				if [ -n "$trackGain" -a -n "$trackPeak" ]; then
					echo "$trackGain" > "$trackGainFile"
					echo "$trackPeak" > "$trackPeakFile"
				else
					exitCode=$Ex_Ko
				fi
				;;

			*.wv)
				nThreads=$( getNumberOfAvailableThreads "$fileIndex" )
				if [ $nThreads -gt 1 ]; then
					wvgain -q -t "$sourceFile" 1>/dev/null 2>/dev/null || exitCode=$Ex_Ko
				else
					wvgain -q -1 "$sourceFile" 1>/dev/null 2>/dev/null || exitCode=$Ex_Ko
				fi
				if [ $exitCode -eq $Ex_Ok ]; then
					trackGain="$( wvtag -x "replaygain_track_gain" "$sourceFile" 2>/dev/null | cut -d '=' -f 2 | cut -d ' ' -f 1 | tr -d '+' )"
					trackPeak="$( wvtag -x "replaygain_track_peak" "$sourceFile" 2>/dev/null | cut -d '=' -f 2 )"
				fi
				if [ -n "$trackGain" -a -n "$trackPeak" ]; then
					echo "$trackGain" > "$trackGainFile"
					echo "$trackPeak" > "$trackPeakFile"
				else
					exitCode=$Ex_Ko
				fi
				;;

			*.ape)
				rsgain custom -q -s i "$sourceFile" 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
				if [ $exitCode -eq $Ex_Ok ]; then
					shopt -qs nocasematch
					while read line; do
						case "$line" in
							replaygain_track_gain=*) trackGain="$( echo "$line" | cut -d '=' -f 2 | cut -d ' ' -f 1 | tr -d '+' )" ;;
							replaygain_track_peak=*) trackPeak="$( echo "$line" | cut -d '=' -f 2 )" ;;
						esac
					done < <( APEv2 -z "$sourceFile" 2>> "$Self_Errors_File" | grep -iE '^replaygain_track_(gain|peak)' 2>/dev/null )
					shopt -qu nocasematch
				fi
				if [ -n "$trackGain" -a -n "$trackPeak" ]; then
					echo "$trackGain" > "$trackGainFile"
					echo "$trackPeak" > "$trackPeakFile"
				else
					exitCode=$Ex_Ko
				fi
				;;

			*.ogg)
				vorbisgain "$sourceFile" 1>/dev/null 2>/dev/null || exitCode=$Ex_Ko
				if [ $exitCode -eq $Ex_Ok ]; then
					trackGain="$( vorbiscomment -l "$sourceFile" 2>/dev/null | grep -iE '^replaygain_track_gain=' 2>> "$Self_Errors_File" | cut -d '=' -f 2 | cut -d ' ' -f 1 | tr -d '+' )"
					trackPeak="$( vorbiscomment -l "$sourceFile" 2>/dev/null | grep -iE '^replaygain_track_peak=' 2>> "$Self_Errors_File" | cut -d '=' -f 2 )"
				fi
				if [ -n "$trackGain" -a -n "$trackPeak" ]; then
					echo "$trackGain" > "$trackGainFile"
					echo "$trackPeak" > "$trackPeakFile"
				else
					exitCode=$Ex_Ko
				fi
				;;

			*.opus) break ;;

			*.mp3)
				mp3gain -u "$sourceFile" 1>/dev/null 2>/dev/null
				mp3gain -s d "$sourceFile" 1>/dev/null 2>/dev/null
				if [ "$preventClipping" = 'true' ]; then
					clippingPreventionParam="-k"
				fi
				line="$( mp3gain -e $clippingPreventionParam -o -T -q "$sourceFile" 2>> "$Self_Errors_File" | grep -Fv 'MP3 gain' | tr '\t' '|' | tr -d '+' | cut -d '|' -f 3-4 )" ; exitCode=$?
				if [ $exitCode -eq $Ex_Ok -a -n "$line" ]; then
					trackGain="${line%|*}"
					decimals="${trackGain#*.}"
					trackGain="${trackGain%.*}.${decimals:0:2}"
					trackPeak="${line#*|}"; trackPeak="${trackPeak%.*}"
					trackPeak="$( echo "scale=8; $trackPeak / 32767" | bc )"
					if [ "${trackPeak:0:1}" = '.' ]; then
						trackPeak="0${trackPeak}"
					fi
					if [ -n "$trackGain" -a -n "$trackPeak" ]; then
						echo "$trackGain" > "$trackGainFile"
						echo "$trackPeak" > "$trackPeakFile"
					else
						exitCode=$Ex_Ko
					fi
				else
					exitCode=$Ex_Ko
				fi
				;;

			*) printMessage 'warning' 'track_gain' 'unsupported' "file:${sourceFile}" $processNumber 'unsupported format' ; return $Ex_Ko ;;
		esac
	else
		exitCode=$Ex_Ko
	fi

	if [ "$sourceExtension" != "opus" ]; then
		if [ $exitCode -eq $Ex_Ok ]; then
			if [ "$applyGain" = 'false' -o "$applyGainType" = "TRACK" ]; then
				saveGain 'TRACK' || exitCode=$Ex_Ko
			fi
		fi

		if [ $exitCode -eq $Ex_Ok ]; then
			if [ "$verbose" = 'true' ]; then
				if [ "${trackGain:0:1}" != '-' -a "${trackGain:0:1}" != '+' ]; then
					trackGain="+${trackGain}"
				fi
				printMessage 'success' 'track_gain' $processNumber "$trackGain dB" "Track gain: $trackGain dB" "file:${sourceFile}"
			fi
		else
			printMessage 'error' 'track_gain' "file:${sourceFile}" $processNumber
		fi
	fi
	return $exitCode
}

computeTrackGains () {
	local exitCode=$Ex_Ok jobFile

	while read milliseconds paddedFileIndex fileIndex; do
		sourceFile="${sourceFiles[$fileIndex]}"
		destFile="$sourceFile"
		sourceFilename="${sourceFile##*/}"
		sourceExtension="${sourceFile##*.}"
		jobFile="${Self_Control_Dir}/${paddedFileIndex}_any.job"
		wasProcessedFile="${Self_Control_Dir}/${paddedFileIndex}_all_processed.info"
		trackGainFile="${Self_Data_Dir}/${paddedFileIndex}_trackgain.txt"
		trackPeakFile="${Self_Data_Dir}/${paddedFileIndex}_trackpeak.txt"

		if getLock "$jobFile"; then
			computeTrackGain || exitCode=$Ex_Ko
			touch "$wasProcessedFile"
		fi
	done < "${Self_Data_Dir}/millisecondsAndFileIndexes.list"

	rm -f "${Self_Jobs_Dir}/process.${processNumber}"
	return $exitCode
}

computeAlbumGain () {
	# This is a very fast way of computing the album gain, but it is also less precise than the official implementation.
	# A comparison between gains on 754 albums revealed max differences ranging from -2.06 dB to +1.50 dB.
	# PINK_REF="64.82" is from flac/src/share/replaygain_analysis/replaygain_analysis.c
	local exitCode=$Ex_Ok PINK_REF_COMPLEMENT="35.18" index processIndex secondsIndex rank trackGain trackSeconds=1
	local increment=0 trackGainFile trackPeakFile albumPeak albumAudioPeak albumGain

	while read milliseconds paddedFileIndex fileIndex; do
		trackGainFile="${Self_Data_Dir}/${paddedFileIndex}_trackgain.txt"
		trackPeakFile="${Self_Data_Dir}/${paddedFileIndex}_trackpeak.txt"
		trackGain="$( cat "$trackGainFile" )"
		trackMilliseconds="$( getMillisecondsByPaddedFileIndex "$paddedFileIndex" )"
		trackSeconds="$( printf "%.0f" "$( echo "scale=3; $trackMilliseconds / 1000" | bc )" )"
		if [ -z "$trackSeconds" ]; then
			trackSeconds=1
		fi
		for (( secondsIndex=0; secondsIndex < trackSeconds; secondsIndex++ )); do
			echo "$trackGain" >> "${Self_Data_Dir}/trackgains"
			(( increment++ ))
		done
		cat "$trackPeakFile" >> "${Self_Data_Dir}/trackpeaks" 2>/dev/null
	done < "${Self_Data_Dir}/millisecondsAndFileIndexes.list"

	albumPeak="$( sort -n "${Self_Data_Dir}/trackpeaks" 2>/dev/null | tail -n 1 )"
	if [ -z "$albumPeak" ]; then
		return $Ex_Ko
	fi

	if [ "$applyGain" = 'true' -a "$applyGainType" = 'ALBUM_PEAK' ]; then
		albumGain="$( computeGainFromPeak "$albumPeak" )"
		if [ "${albumGain:0:1}" = '-' ]; then
			albumGain="${albumGain:1}"
			if [ "${peakReference:0:1}" = '-' ]; then
				albumGain="$( printf "%.2f" "$( echo "scale=3; ($albumGain + $peakReference) / 1" | bc 2>> "$Self_Errors_File" )" )"
			fi
		elif [ "${peakReference:0:1}" = '-' ]; then
			albumGain="$peakReference"
		else
			albumGain="-0"
		fi
	else
		sort -n "${Self_Data_Dir}/trackgains" > "${Self_Data_Dir}/trackgains.tmp" 2>/dev/null
		mv "${Self_Data_Dir}/trackgains.tmp" "${Self_Data_Dir}/trackgains"

		# By using PINK_REF_COMPLEMENT instead of PINK_REF, running 'head' MIGHT be slightly faster than
		# running 'tail' with PINK_REF because 'head' will output fewer lines than 'tail'.
		rank="$( printf "%.0f" "$( echo "scale=5; ((${PINK_REF_COMPLEMENT} / 100) * $increment + (1 / 2)) / 1" | bc 2>> "$Self_Errors_File" )" )"
		albumGain="$( head -n $rank "${Self_Data_Dir}/trackgains" 2>/dev/null | tail -n 1 )"
		if [ -z "$albumGain" ]; then
			printMessage 'error' 'album_gain' "Album gain"
			return $Ex_Ko
		elif [ "$applyGain" = 'true' -a "$applyGainType" = 'ALBUM' -a -n "$preamp" ]; then
			if [ "${preamp:0:1}" = '-' ]; then
				albumGain="$( printf "%.2f" "$( echo "scale=3; ($albumGain - ${preamp:1}) / 1" | bc 2>> "$Self_Errors_File" )" )"
			elif [ "${preamp:0:1}" = '+' ]; then
				albumGain="$( printf "%.2f" "$( echo "scale=3; ($albumGain + ${preamp:1}) / 1" | bc 2>> "$Self_Errors_File" )" )"
			fi
		fi
	fi

	processIndex=0
	while read milliseconds paddedFileIndex fileIndex; do
		if [ $processIndex -lt $nProcesses ]; then
			destFile="${sourceFiles[$fileIndex]}"
			saveGain 'ALBUM' &
		else
			wait
			processIndex=0
			destFile="${sourceFiles[$fileIndex]}"
			saveGain 'ALBUM' &
		fi
		(( processIndex++ ))
	done < "${Self_Data_Dir}/millisecondsAndFileIndexes.list"
	wait

	if [ "${albumGain:0:1}" != '-' ]; then
		albumGain="+${albumGain}"
	fi
	printMessage 'success' 'album_gain' "${albumGain} dB" "Album gain: $albumGain dB"

	return $exitCode
}

# https://github.com/FrancisRussell/zoog
computeOpusAlbumGain () {
	local exitCode=$Ex_Ok list sourceFile albumPlaybackGain trackPlaybackGain trackDecibels signedTrackGain signedAlbumGain

	for sourceFile in "${sourceFiles[@]}"; do
		if [ -z "$list" ]; then
			list="$sourceFile"
		else
			list="${list}\x00${sourceFile}"
		fi
	done
	echo -en "$list" | xargs -0 opusgain -j $nProcesses -a -p rg 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
	if [ $exitCode -ne $Ex_Ko ]; then
		# opusgain changes the rights on the files it touches, to u=rw,go=
		chmod u=rw,go=r "${sourceFiles[@]}" 1>/dev/null 2>> "$Self_Errors_File"

		albumPlaybackGain="$( opusinfo "$sourceFile" 2>> "$Self_Errors_File" | grep -F "Playback gain: " | cut -d ':' -f 2 | cut -d ' ' -f 2 )"
		albumPlaybackGain="$( printf "%.2f" "$albumPlaybackGain" )"
		for sourceFile in "${sourceFiles[@]}"; do
			trackPlaybackGain="$( opusinfo "$sourceFile" | grep -F "R128_TRACK_GAIN=" | cut -d '=' -f 2 | cut -d ' ' -f 1 )"
			trackPlaybackGain="${trackPlaybackGain#+*}"
			trackDecibels="$( echo "scale=3; ($albumPlaybackGain + ($trackPlaybackGain / 256) + 5) / 1" | bc 2>> "$Self_Errors_File" )"
			trackDecibels="$( printf "%.2f" "$trackDecibels" )"
			signedTrackGain="$trackDecibels"
			if [ "${signedTrackGain:0:1}" != '-' -a "${signedTrackGain:0:1}" != '+' ]; then
				signedTrackGain="+${signedTrackGain}"
			fi
			printMessage 'success' 'track_gain' 0 "$signedTrackGain dB" "file:${sourceFile}"
		done
		signedAlbumGain="$albumPlaybackGain"
		if [ "${signedAlbumGain:0:1}" != '-' -a "${signedAlbumGain:0:1}" != '+' ]; then
			signedAlbumGain="+${signedAlbumGain}"
		fi
		printMessage 'success' 'album_gain' "$signedAlbumGain dB"
	else
		printMessage 'error' 'album_gain' "Album gain"
	fi

	return $exitCode
}

reverseOpusTrackGains () {
	local exitCode=$Ex_Ok list sourceFile

	for sourceFile in "${sourceFiles[@]}"; do
		if [ -z "$list" ]; then
			list="$sourceFile"
		else
			list="${list}\x00${sourceFile}"
		fi
	done

	echo -en "$list" | xargs -0 opusgain -j $nProcesses -p 'original' 1>/dev/null 2>> "$Self_Errors_File" &&
	echo -en "$list" | xargs -0 opusgain -j $nProcesses -c 1>/dev/null 2>> "$Self_Errors_File" || exitCode=$Ex_Ko
	if [ $exitCode -ne $Ex_Ko ]; then
		# opusgain changes the rights on the files it touches, to u=rw,go=
		chmod u=rw,go=r "${sourceFiles[@]}" 1>/dev/null 2>> "$Self_Errors_File"

		for sourceFile in "${sourceFiles[@]}"; do
			printMessage 'success' 'track_gain' 0 "-0 dB" "file:${sourceFile}"
		done
	else
		printMessage 'error' 'track_gain' "Track gain"
	fi

	return $exitCode
}

reverseTrackGain () {
	local exitCode=$Ex_Ok

	if [ -e "$sourceFile" ]; then
		case "$sourceFile" in
			*.flac) metaflac \
				--remove-tag="REPLAYGAIN_REFERENCE_LOUDNESS" \
				--remove-tag="REPLAYGAIN_TRACK_GAIN" \
				--remove-tag="REPLAYGAIN_TRACK_PEAK" \
				--remove-tag="REPLAYGAIN_ALBUM_GAIN" \
				--remove-tag="REPLAYGAIN_ALBUM_PEAK" \
				--remove-tag="AUDIO_TRACK_PEAK" \
				--remove-tag="AUDIO_ALBUM_PEAK" \
				"$sourceFile" 1>/dev/null 2>/dev/null ; exitCode=$? ;;

			*.wv) wvtag \
				-w "replaygain_reference_loudness=" \
				-w "replaygain_track_gain=" \
				-w "replaygain_track_peak=" \
				-w "replaygain_album_gain=" \
				-w "replaygain_album_peak=" \
				-w "audio_track_peak=" \
				-w "audio_album_peak=" \
				"$sourceFile" 1>/dev/null 2>/dev/null ; exitCode=$?
				;;

			*.ape) APEv2 -z \
				-r "Replaygain_Reference_Loudness" \
				-r "Replaygain_Track_Gain" \
				-r "Replaygain_Track_Peak" \
				-r "Replaygain_Album_Gain" \
				-r "Replaygain_Album_Peak" \
				-r "Audio_Track_Peak" \
				-r "Audio_Album_Peak" \
				"$sourceFile" 1>/dev/null 2>/dev/null ; exitCode=$?
				;;

			*.ogg) vorbiscomment \
				-d "REPLAYGAIN_REFERENCE_LOUDNESS" \
				-d "REPLAYGAIN_TRACK_PEAK" \
				-d "REPLAYGAIN_TRACK_GAIN" \
				-d "REPLAYGAIN_ALBUM_PEAK" \
				-d "REPLAYGAIN_ALBUM_GAIN" \
				-d "AUDIO_TRACK_PEAK" \
				-d "AUDIO_ALBUM_PEAK" \
				"$sourceFile" 1>/dev/null 2>/dev/null; exitCode=$?
				;;

			*.mp3)
				mp3gain -u "$sourceFile" 1>/dev/null 2>/dev/null ; exitCode=$?
				if [ $exitCode -eq $Ex_Ok ]; then
					mp3gain -s d "$sourceFile" 1>/dev/null 2>> "$Self_Errors_File"
				fi
				;;

			*) printMessage 'warning' 'track_gain' 'unsupported' "file:${sourceFile}" $processNumber 'unsupported format' ; return $Ex_Ko ;;
		esac
	else
		exitCode=$Ex_Ko
	fi

	if [ $exitCode -eq $Ex_Ok ]; then
		if [ "$verbose" = 'true' ]; then
			printMessage 'success' 'track_gain' $processNumber "-0 dB" "file:${sourceFile}"
		fi
	else
		printMessage 'error' 'track_gain' "file:${sourceFile}" $processNumber
	fi
	return $exitCode
}

reverseTrackGains () {
	local exitCode=$Ex_Ok jobFile

	while read milliseconds paddedFileIndex fileIndex; do
		sourceFile="${sourceFiles[$fileIndex]}"
		jobFile="${Self_Control_Dir}/${paddedFileIndex}_any.job"

		if getLock "$jobFile"; then
			reverseTrackGain || exitCode=$Ex_Ko
		fi
	done < "${Self_Data_Dir}/millisecondsAndFileIndexes.list"

	rm -f "${Self_Jobs_Dir}/process.${processNumber}"
	return $exitCode
}

echoTouchString () {
  local trackDate="$1" hours="$2" minutes="$3" seconds="$4"
  if [ ${#hours} -lt 2 ]; then hours="0${hours}"; fi
  if [ ${#minutes} -lt 2 ]; then minutes="0${minutes}"; fi
  if [ ${#seconds} -lt 2 ]; then seconds="0${seconds}"; fi
  echo "${trackDate}${hours}${minutes}.${seconds}"
}

getTouchString () {
  local trackDate="$1" totalSeconds="$2" str="" fDays fHours fMinutes fSeconds fMilliseconds=0

  fSeconds=$totalSeconds
  fDays="$( echo "scale=0; $fSeconds / 86400" | bc )"
  fSeconds="$( echo "$fSeconds - ($fDays * 86400)" | bc )"
  fHours="$( echo "scale=0; $fSeconds / 3600" | bc )"
  fSeconds="$( echo "$fSeconds - ($fHours * 3600)" | bc )"
  fMinutes="$( echo "scale=0; $fSeconds / 60" | bc )"
  fSeconds="$( echo "scale=0; ($fSeconds - ($fMinutes * 60)) / 1" | bc )" # divide by 1 because "scale" only works on divisions
  fMilliseconds="$( echo "$totalSeconds" | cut -d "." -f 2 )"

	if [ "$fMilliseconds" == "" ]; then fMilliseconds=0; fi
  if [ $fMilliseconds -ge 500 ]; then
    fSeconds="$( echo "$fSeconds + 1" | bc )"
  fi

  echoTouchString $trackDate $fHours $fMinutes $fSeconds
}

computeTrackDateTime () {
	local exitCode=$Ex_Ok trackYear trackMonth trackDay

	case "$sourceFile" in
		*.flac|*ogg|*.m4a|*.wv|*.ape|*.opus|*.mp3)
			case "$sourceFile" in
				*.flac) date=$( metaflac --no-filename --show-tag=date "$sourceFile" | tr -cd "[:digit:]-" ) ;;
				*.ogg) date=$( vorbiscomment "$sourceFile" | grep -iF "date=" | tr -cd "[:digit:]-" ) ;;
				*.m4a) date=$( ffprobe -show_format -print_format flat "$sourceFile" 2>/dev/null | grep -iE '^format.tags.date' | cut -d '.' -f 3- | tr -cd "[:digit:]-" ) ;;
				*.wv) date=$( wvtag -x Year "$sourceFile" 2>/dev/null | tr -cd "[:digit:]-" ) ;;
				*.ape) date=$( APEv2 -z "$sourceFile" 2>/dev/null | grep -iF year= | tr -cd "[:digit:]-" ) ;;
				*.opus) date=$( opusinfo "$sourceFile" | grep -iF "date=" | tr -cd "[:digit:]-" ) ;;
				*.mp3) date=$( ffmpeg -i "$sourceFile" -f ffmetadata - 2>/dev/null | grep -iE "^(date|TDOR|TDRC|TDRL)=[0-9]{4}" | head -n 1 | tr -cd "[:digit:]-" ) ;;
			esac
			if [ ${#date} -eq 4 ]; then
				trackYear="$date"
				trackMonth="01"
				trackDay="01"
			elif [ ${#date} -eq 7 ]; then
				trackYear=$( echo "$date" | cut -d "-" -f 1 )
				trackMonth=$( echo "$date" | cut -d "-" -f 2 )
				trackDay="01"
			elif [ ${#date} -eq 10 ]; then
				trackYear=$( echo "$date" | cut -d "-" -f 1 )
				trackMonth=$( echo "$date" | cut -d "-" -f 2 )
				trackDay=$( echo "$date" | cut -d "-" -f 3 )
			else
				trackYear="$( $datecmd "+%Y" )"
				trackMonth="$( $datecmd "+%m" )"
				trackDay="$( $datecmd "+%d" )"
			fi

			echo "${trackYear}${trackMonth}${trackDay}" > "$sourceTagFile"
			;;

		*) continue ;;
	esac

	if [ $exitCode -eq $Ex_Ok ]; then
		printMessage 'success' 'touch_file' $processNumber "dateTime:${trackYear}-${trackMonth}-${trackDay}" "file:${sourceFile}"
	else
		printMessage 'error' 'touch_file' $processNumber "dateTime:${trackYear}-${trackMonth}-${trackDay}" "file:${sourceFile}"
	fi

	return $exitCode
}

computeTrackDateTimes () {
	local exitCode=$Ex_Ok jobFile

	while read milliseconds paddedFileIndex fileIndex; do
		sourceFile="${sourceFiles[$fileIndex]}"
		sourceFilename="${sourceFile##*/}"
		sourceTagFile="${Self_Swap_Dir}/${paddedFileIndex}_tags_input.txt"
		jobFile="${Self_Control_Dir}/${paddedFileIndex}_any.job"
		wasProcessedFile="${Self_Control_Dir}/${paddedFileIndex}_all_processed.info"

		if getLock "$jobFile"; then
			prepareSource &&
			computeTrackDateTime || exitCode=$Ex_Ko
			touch "$wasProcessedFile"
		fi
	done

	rm -f "${Self_Jobs_Dir}/process.${processNumber}"
	return $exitCode
}

touchAllFiles () {
	local exitCode=$Ex_Ok index audioFileIndex otherFileIndex dirIndex
	local trackDate albumSeconds discSeconds trackMilliseconds discHours discMinutes discSeconds
	local defaultTrackDate lastDir="" curDir artistDir albumDir albumLinkDir albumPath dirPath inode linkedFile linkPath
	local touchString discDirs linkedDiscDirs audioFiles otherFiles otherFile audioFile sourceFile sourceTagFile

	trackDate="$( $datecmd "+%Ymd" )"
	defaultTrackDate="$trackDate"
	albumSeconds=0

	discDirs=()
	linkedDiscDirs=()
	audioFiles=()
	otherFiles=()

	for (( index=0, dirIndex=0; index < ${#sourceFiles[@]}; index++ )); do
		sourceFile="${sourceFiles[$index]}"
		sourceDirname="${sourceFile%/*}"
		curDir="$( readlink -f "$sourceDirname" )"
		if [ "$curDir" != "$lastDir" ]; then
			discDirs[$dirIndex]="$curDir"
			(( dirIndex++ ))
			lastDir="$curDir"
		fi
	done

	for (( dirIndex=0; dirIndex < ${#discDirs[@]}; dirIndex++ )); do
		curDir="${discDirs[$dirIndex]}"
		trackMilliseconds=0
		touchString="${trackDate}0000.00"
		discSeconds=0
		linkPath=""

		for (( index=0, audioFileIndex=0, otherFileIndex=0; index < ${#sourceFiles[@]}; index++ )); do
			sourceFile="${sourceFiles[$index]}"
			sourceDirname="${sourceFile%/*}"
			dirPath="$( readlink -f "$sourceDirname" )"
			if [ "$dirPath" != "$curDir" ]; then continue; fi
			case "$sourceFile" in
				*.flac|*ogg|*.m4a|*.wv|*.ape|*.mp3|*.opus) audioFiles[$audioFileIndex]="$sourceFile" ; (( audioFileIndex++ )) ;;
				*.wvc) continue ;; # will be touched when the matching .wv file is touched
				*.aiff|*.caf) continue ;; # unsupported audio files
				*) otherFiles[$otherFileIndex]="$sourceFile" ; (( otherFileIndex++ )) ;; # all non-audio files
			esac
		done

		for audioFile in "${audioFiles[@]}"; do
			audioFileDirname="${audioFile%/*}"
			dirPath="$( readlink -f "$audioFileDirname" )"
			if [ "$dirPath" != "$curDir" ]; then continue; fi
			if [ "$gotLinkedDir" = 'true' -a -z "$linkPath" ]; then
				linkedDiscDirs[$dirIndex]=""
				inode="$( ls -i "$audioFile" 2>/dev/null | cut -d " " -f 1 2>/dev/null )"
				if [ -n "$inode" ]; then
					while read linkedFile; do
						if [ -z "$linkPath" ]; then
							linkPath="${linkedFile%/*}"
							linkedDiscDirs[$dirIndex]="$linkPath"
							break
						fi
					done < <( $findcmd "$linkDir" -inum "$inode" 2>dev/null )
				fi
			else
				break
			fi
		done

		while read milliseconds paddedFileIndex fileIndex; do
			sourceFile="${sourceFiles[$fileIndex]}"
			sourceDirname="${sourceFile%/*}"
			dirPath="$( readlink -f "$sourceDirname" )"
			if [ "$dirPath" != "$curDir" ]; then continue; fi
			sourceTagFile="${Self_Swap_Dir}/${paddedFileIndex}_tags_input.txt"
			trackMilliseconds="$( getMillisecondsByPaddedFileIndex "$paddedFileIndex" )"
			if [ -z "$trackMilliseconds" ]; then trackMilliseconds=0; fi

			case "$sourceFile" in
				*.flac|*ogg|*m4a|*.wv|*.ape|*.mp3|*.opus)
					read trackDate < "$sourceTagFile"
					if [ -z "$trackDate" ]; then trackDate="$defaultTrackDate"; fi
					;;

				*.wvc) continue ;;

				*) continue ;;
			esac

			touchString="$( getTouchString $trackDate $discSeconds )"
			touch -t "$touchString" "$sourceFile" || exitCode=$Ex_Io_Err
			if [ -e "${sourceFile}c" ]; then  # WavPack correction file
				touch -t "$touchString" "${sourceFile}c" || exitCode=$Ex_Io_Err
			fi
			discSeconds="$( echo "scale=3; ($discSeconds + ($trackMilliseconds / 1000)) / 1" | bc )"
			albumSeconds="$( echo "scale=3; ($albumSeconds + ($trackMilliseconds / 1000)) / 1" | bc )"
			# debug "trackMilliseconds=[$trackMilliseconds] discSeconds=[$discSeconds] albumSeconds[$albumSeconds]"
		done

		for otherFile in "${otherFiles[@]}"; do
			touchString="$( getTouchString $trackDate $discSeconds )"
			touch -t "$touchString" "$otherFile" 2>> "$Self_Errors_File" || exitCode=$Ex_Io_Err
		done

		if [ ! -w "$curDir" ]; then
			printMessage 'warning' 'usage' 'filesystem' "path:${curDir}" 'refusing to touch directory that is read-only.'
		else
			touchString="$( getTouchString $trackDate $discSeconds )"
			touch -t "$touchString" "$curDir" || exitCode=$Ex_Io_Err
		fi

		if [ -n "$linkPath" ]; then
			if [ ! -w "$linkPath" ]; then
				printMessage 'warning' 'usage' 'filesystem' "path:${linkPath}" 'refusing to touch directory that is read-only.'
			else
				touchString="$( getTouchString $trackDate $discSeconds )"
				touch -t "$touchString" "$linkPath" || exitCode=$Ex_Io_Err
			fi
		fi
	done

	if [ ${#discDirs[@]} -gt 1 ]; then
		for (( dirIndex=0; dirIndex < ${#discDirs[@]}; dirIndex++ )); do
			curDir="${discDirs[$dirIndex]}"
			curLinkedDir="${linkedDiscDirs[$dirIndex]}"
			albumDir="${curDir%/*}"

			if [ ! -w "$albumDir" ]; then
				printMessage 'warning' 'usage' 'filesystem' "path:${albumDir}" 'refusing to touch directory that is read-only.'
			else
				touchString="$( getTouchString $trackDate $albumSeconds )"
				touch -t "$touchString" "$albumDir" || exitCode=$Ex_Io_Err
			fi

			if [ -n "$curLinkedDir" ]; then
				albumLinkDir="${curLinkedDir%/*}"
				if [ ! -w "$albumLinkDir" ]; then
					printMessage 'warning' 'usage' 'filesystem' "path:${albumLinkDir}" 'refusing to touch directory that is read-only.'
				else
					touchString="$( getTouchString $trackDate $albumSeconds )"
					touch -t "$touchString" "$albumLinkDir" || exitCode=$Ex_Io_Err
				fi
			fi
		done
	fi

	if [ $exitCode -eq $Ex_Ok ]; then
		touchString="$( getTouchString $trackDate $albumSeconds )"
		discHours="${touchString:8:2}"
		discMinutes="${touchString:10:2}"
		albumSeconds="${touchString:13:2}"
		printMessage 'success' 'touch_files' "albumTime:${discHours}:${discMinutes}:${albumSeconds}"
	else
		printMessage 'error' 'touch_files' "Album length"
	fi

	return $exitCode
}

getCodecExtension () {
	local codec="$1" ext

	case "$codec" in
		WAV)           ext='wav' ;;
		AIFF)          ext='aiff' ;;
		CAF)           ext='caf' ;;
		FLAC)          ext='flac' ;;
		WavPack)       ext='wv' ;;
		WavPackHybrid) ext='wv' ;;
		MonkeysAudio)  ext='ape' ;;
		WavPackLossy)  ext='wv' ;;
		lossyFLAC)     ext='lossy.flac' ;;
		OggVorbis)     ext='ogg' ;;
		MP3)           ext='mp3' ;;
		AAC|ALAC)      ext='m4a' ;;
		Opus)          ext='opus' ;;
	esac

	echo "$ext"
}

getCodecFullName () {
	local codec="$1" codecFullName

	case "$codec" in
		WAV)           codecFullName='WAV' ;;
		AIFF)          codecFullName='AIFF' ;;
		CAF)           codecFullName='CAF' ;;
		FLAC)          codecFullName='FLAC' ;;
		ALAC)          codecFullName='ALAC' ;;
		WavPack)       codecFullName='WavPack' ;;
		WavPackHybrid) codecFullName='WavPack Hybrid' ;;
		MonkeysAudio)  codecFullName="Monkey's Audio" ;;
		WavPackLossy)  codecFullName='WavPack Lossy' ;;
		lossyFLAC)     codecFullName='lossyFLAC' ;;
		OggVorbis)     codecFullName='Ogg Vorbis' ;;
		MP3)           codecFullName='MP3' ;;
		AAC)           codecFullName='AAC' ;;
		Opus)          codecFullName='Opus' ;;
	esac

	echo "$codecFullName"
}

getOutputCodecDestFile () {
	local sourceFile="$1" outputCodec="$2" sourceFilename sourceDirname sourceBasename sourceIsLossyWAV
	local sourceExtension destExtension destDir destFilename copyPath destPath

	sourceFilename="${sourceFile##*/}"
	sourceDirname="${sourceFile%/*}"
	sourceBasename="${sourceFilename%.*}"
	if [ "$sourceBasename" != "${sourceBasename%.lossy}" ]; then
		sourceIsLossyWAV='true'
	else
		sourceIsLossyWAV='false'
	fi
	sourceBasename="${sourceBasename%.lossy}";
	sourceExtension="${sourceFilename##*.}"

	destExtension="$( getCodecExtension "$outputCodec" )"
	outputCodecFullName="$( getCodecFullName "$outputCodec" )"
	destDir="$( getDestDir "$outputCodec" )"
	if [ "$outputCodec" = 'WAV' -a "$sourceIsLossyWAV" = 'true' ]; then
		destExtension='lossy.wav'
	fi
	destFilename="${sourceBasename}.${destExtension}"

	copyPath="$( copyPathOrNot "$outputCodec" )"
	if [ "$copyPath" = 'true' ]; then
		destPath="${destDir}/${sourceDirname#/}"
		destFile="${destPath}/${destFilename}"
	else
		destPath="$destDir"
		destFile="${destDir}/${destFilename}"
	fi
}

getFileProps () {
	local outputCodec="$2"

	sourceFile="$1"
	sourceFilename="${sourceFile##*/}"
	sourceDirname="${sourceFile%/*}"
	sourceBasename="${sourceFilename%.*}"
	if [ "$sourceBasename" != "${sourceBasename%.lossy}" ]; then
		sourceIsLossyWAV='true'
	else
		sourceIsLossyWAV='false'
	fi
	sourceBasename="${sourceBasename%.lossy}";
	sourceExtension="${sourceFilename##*.}"

	if [ -n "$outputCodec" ]; then
		destExtension="$( getCodecExtension "$outputCodec" )"
		outputCodecFullName="$( getCodecFullName "$outputCodec" )"
		destDir="$( getDestDir "$outputCodec" )"
		if [ "$outputCodec" = 'WAV' -a "$sourceIsLossyWAV" = 'true' ]; then
			destExtension='lossy.wav'
		fi
		destFilename="${sourceBasename}.${destExtension}"

		sourceCoverArtFile=""
		coverArtFilename="$( getCodecCoverArtFile "$outputCodec" )"
		if [ -n "$coverArtFilename" ]; then
			sourceCoverArtFile="${sourceDirname}/${coverArtFilename}"
			if [ ! -e "$sourceCoverArtFile" ]; then
				sourceCoverArtFile=""
				# printMessage 'warning' 'usage' 'filesystem' "file:${coverArtFilename}" 'no such file.'
			elif [ ! -r "$sourceCoverArtFile" ]; then
				sourceCoverArtFile=""
				# printMessage 'warning' 'usage' 'filesystem' "file:${coverArtFilename}" 'cannot open file for reading (permission denied).'
			fi
		fi

		copyPath="$( copyPathOrNot "$outputCodec" )"
		if [ "$copyPath" = 'true' ]; then
			destPath="${destDir}/${sourceDirname#/}"
			destFile="${destPath}/${destFilename}"
			if [ -n "$linkDir" ]; then
				destLinkPath="${linkDir}/${sourceDirname#/}"
				destLinkFile="${destLinkPath}/${destFilename}"
			fi
		else
			destPath="$destDir"
			destFile="${destDir}/${destFilename}"
			if [ -n "$linkDir" ]; then
				destLinkPath="$linkDir"
				destLinkFile="${linkDir}/${destFilename}"
			fi
		fi
	fi
}

printMachineStats () {
	local sourceCoverArtBytes destExtension dest bcmd seconds slist
	local bytesCompressed duration=0 processingRate=''

	seconds="$( printf 'scale=6; %.6f - %.6f\n' "$time2" "$time1" | bc )"
	if [ "$seconds" = '0' ]; then seconds='1'; fi # prevent division by 0 situations

	while read fileMilliseconds index; do
		duration=$(( duration + fileMilliseconds ))
	done < "${Self_Data_Dir}/millisecondsAndFileIndexes.list"

	if [ "$duration" != '0' ]; then
		duration="$( printf "%.0f" "$( echo "scale=3; $duration / 1000" | bc )" )"
		processingRate="$( echo "scale=1; $duration / $seconds" | bc )"
	fi

	if [ -z "$outputCodecs" ]; then
		if [ -n "$processingRate" ]; then
			printMessage 'info' "${processingRate} x"
		fi
		return
	fi

	if [ -n "$processingRate" ]; then
		printMessage 'info' "${processingRate} x"
	fi

	if [ "$outputCodecs" = 'WAV' ]; then return; fi

	bcmd=''
	for outputCodec in $outputCodecs; do
		for sourceFile in "${sourceFiles[@]}"; do
			getFileProps "$sourceFile" "$outputCodec"
			if [ -e "$destFile" ]; then
				bcmd="${bcmd}\x00${destFile//%/%%}"
				if [ -e "${destFile}c" ]; then # WavPack correction file
					bcmd="${bcmd}\x00${destFile//%/%%}c"
				fi
			fi
		done
	done

	if [ "$gnustat" = 'true' ]; then
		bytesCompressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %s' | xargs -0 $statcmd -L --printf; echo; } | bc )"
	else
		bytesCompressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %z' | xargs -0 $statcmd -L -n -f; echo; } | bc )"
	fi

	for outputCodec in $outputCodecs; do
		bcmd=''
		for sourceFile in "${sourceFiles[@]}"; do
			getFileProps "$sourceFile" "$outputCodec"
			if [ -e "$destFile" ]; then
				bcmd="${bcmd}\x00${destFile//%/%%}"
				if [ -e "${destFile}c" ]; then # WavPack correction file
					bcmd="${bcmd}\x00${destFile//%/%%}c"
				fi
			fi
		done

		if [ "$gnustat" = 'true' ]; then
			bytesCompressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %s' | xargs -0 $statcmd -L --printf; echo; } | bc )"
		else
			bytesCompressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %z' | xargs -0 $statcmd -L -n -f; echo; } | bc )"
		fi


		if [ $duration -gt 0 ]; then
			bitrateCompressed="$( echo "scale=0; ($bytesCompressed * 8) / ${duration}" | bc )"
			printMessage 'info' "bitrate_${outputCodec}" "${bitrateCompressed}bps"
		fi
	done

	return $Ex_Ok
}

printHumanStats () {
	local sourceFile sourceCoverArtBytes destExtension dest bcmd seconds slist
	local bytesSource bytesWav bytesCompressed imbsec ombsec mibSource mibCompressed mibUncompressed bitrateCompressed
	local ratio duration='0' processingRate='' readDuration

	seconds="$( printf 'scale=6; %.6f - %.6f\n' "$time2" "$time1" | bc )"
	if [ "$seconds" = '0' ]; then seconds='1'; fi # prevent division by 0 situations

	while read fileMilliseconds index; do
		duration=$(( duration + fileMilliseconds ))
	done < "${Self_Data_Dir}/millisecondsAndFileIndexes.list"

	if [ "$duration" != '0' ]; then
		duration="$( printf "%.0f" "$( echo "scale=3; $duration / 1000" | bc )" )"
		processingRate="$( echo "scale=1; $duration / $seconds" | bc )"
	fi
	printf "${Clr_B_Bk} * ${Clr_Rst}%.2f seconds" $seconds

	readDuration="$( { echo -n 'scale=6; ' ; cat "${Self_Data_Dir}/readTimes.txt" ; echo ; } | bc )"
	if [ "$readDuration" = '0' -o -z "$readDuration" ]; then # prevent division by 0 situations
		if [ "$seconds" = '0' ]; then
			readDuration='1'
		else
			readDuration="$seconds"
		fi
	fi


	for sourceFile in "${sourceFiles[@]}"; do
		slist="${slist}\x00${sourceFile//%/%%}"
		if [ -e "${sourceFile}c" ]; then # WavPack correction file
			slist="${slist}\x00${sourceFile//%/%%}c"
		fi
	done

	if [ "$gnustat" = 'true' ]; then
		bytesSource="$( { echo -n 'scale=0; 0'; printf "%s${slist}" ' + %s' | xargs -0 $statcmd -L --printf; echo; } | bc )"
	else
		bytesSource="$( { echo -n 'scale=0; 0'; printf "%s${slist}" ' + %z' | xargs -0 $statcmd -L -n -f; echo; } | bc )"
	fi
	imbsec="$( echo "scale=3; $bytesSource / ($readDuration * 1000000)" | bc )"

	if [ -z "$outputCodecs" ]; then
		if [ -z "$processingRate" ]; then
			printf ' (read: %.1f MB/s)\n' "$imbsec"
		else
			printf ' (read: %.1f MB/s, rate: %s x)\n' "$imbsec" "$processingRate"
		fi
		return
	fi

	bcmd=''
	for outputCodec in $outputCodecs; do
		for sourceFile in "${sourceFiles[@]}"; do
			getOutputCodecDestFile "$sourceFile" "$outputCodec"
			if [ -e "$destFile" ]; then
				bcmd="${bcmd}\x00${destFile//%/%%}"
				if [ -e "${destFile}c" ]; then # WavPack correction file
					bcmd="${bcmd}\x00${destFile//%/%%}c"
				fi
			fi
		done
	done

	if [ "$gnustat" = 'true' ]; then
		bytesCompressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %s' | xargs -0 $statcmd -L --printf; echo; } | bc )"
	else
		bytesCompressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %z' | xargs -0 $statcmd -L -n -f; echo; } | bc )"
	fi
	ombsec="$( echo "scale=3; $bytesCompressed / ($seconds * 1000000)" | bc )"

	if [ -n "$processingRate" ]; then
		printf ' (read: %.1f MB/s, write: %.1f MB/s, rate: %s x)\n' "$imbsec" "$ombsec" "$processingRate"
	else
		printf ' (read: %.1f MB/s, write: %.1f MB/s)\n' "$imbsec" "$ombsec"
	fi

	if [ "$outputCodecs" = 'WAV' ]; then return; fi

	bytesWav="$( { echo -n 'scale=0; 0' ; cat "${Self_Data_Dir}/bytes" ; echo ; } | bc )"
	mibSource="$( echo "scale=3; $bytesSource / 1048576" | bc )"
	mibUncompressed="$( echo "scale=3; $bytesWav / 1048576" | bc )"
	ratio="$( echo "scale=3; $bytesSource * 100 / $bytesWav" | bc )"

	if [ $duration -gt 0 ]; then
		bitrate_source="$( echo "scale=0; (${bytesSource} * 8) / ${duration} / 1000" | bc )"
	else
		bitrate_source='?'
	fi

	# each item is separated by 4 spaces
	printf '\n%-15s    %6.1f MiB    %5.1f%%' 'WAV:' "$mibUncompressed" '100'
	printf '\n%-15s    %6.1f MiB    %5.1f%%    %4s kbps\n' 'Source:' "$mibSource" "$ratio" "$bitrate_source"

	for outputCodec in $outputCodecs; do
		bcmd=''
		for sourceFile in "${sourceFiles[@]}"; do
			getOutputCodecDestFile "$sourceFile" "$outputCodec"
			if [ -e "$destFile" ]; then
				bcmd="${bcmd}\x00${destFile//%/%%}"
				if [ -e "${destFile}c" ]; then # WavPack correction file
					bcmd="${bcmd}\x00${destFile//%/%%}c"
				fi
			fi
		done

		if [ "$gnustat" = 'true' ]; then
			bytesCompressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %s' | xargs -0 $statcmd -L --printf; echo; } | bc )"
		else
			bytesCompressed="$( { echo -n 'scale=0; 0'; printf "%s${bcmd}" ' + %z' | xargs -0 $statcmd -L -n -f; echo; } | bc )"
		fi

		if [ $duration -gt 0 ]; then
			bitrateCompressed="$( echo "scale=0; (${bytesCompressed} * 8) / ${duration} / 1000" | bc )"
		else
			bitrateCompressed='?'
		fi

		mibCompressed="$( echo "scale=3; $bytesCompressed / 1048576" | bc )"
		ratio="$( echo "scale=3; $bytesCompressed * 100 / $bytesWav" | bc )"

		# each item is separated by 4 spaces
		printf '%-15s    %6.1f MiB    %5.1f%%    %4s kbps\n' "${outputCodecFullName}:"	$mibCompressed "$ratio" "$bitrateCompressed"
	done

	return $Ex_Ok
}

setDestDir () {
	local outputCodec="$1" codecDestDir="$2" copyPath="$3" listOfCodecs codec

	if [ -z "$outputCodec" ]; then
		read -a listOfCodecs <<< "$allCodecsString"
	else
		read -a listOfCodecs <<< "$outputCodec"
	fi

	for codec in "${listOfCodecs[@]}"; do
		case "$codec" in
			WAV) dir_WAV="$codecDestDir" ;;
			AIFF) dir_AIFF="$codecDestDir" ;;
			CAF) dir_CAF="$codecDestDir" ;;
			FLAC) dir_FLAC="$codecDestDir" ;;
			ALAC) dir_ALAC="$codecDestDir" ;;
			WavPack) dir_WavPack="$codecDestDir" ;;
			WavPackHybrid) dir_WavPackHybrid="$codecDestDir" ;;

			WavPackLossy) dir_WavPackLossy="$codecDestDir" ;;
			MonkeysAudio) dir_MonkeysAudio="$codecDestDir" ;;
			lossyFLAC) dir_lossyFLAC="$codecDestDir" ;;
			MP3) dir_MP3="$codecDestDir" ;;
			AAC) dir_AAC="$codecDestDir" ;;
			OggVorbis) dir_OggVorbis="$codecDestDir" ;;
			Opus) dir_Opus="$codecDestDir" ;;
		esac
	done

	for codec in "${listOfCodecs[@]}"; do
		case "$codec" in
			WAV) copyPath_WAV="$copyPath" ;;
			AIFF) copyPath_AIFF="$copyPath" ;;
			CAF) copyPath_CAF="$copyPath" ;;
			FLAC) copyPath_FLAC="$copyPath" ;;
			ALAC) copyPath_ALAC="$copyPath" ;;
			WavPack) copyPath_WavPack="$copyPath" ;;
			WavPackHybrid) copyPath_WavPackHybrid="$copyPath" ;;

			WavPackLossy) copyPath_WavPackLossy="$copyPath" ;;
			MonkeysAudio) copyPath_MonkeysAudio="$copyPath" ;;
			lossyFLAC) copyPath_lossyFLAC="$copyPath" ;;
			MP3) copyPath_MP3="$copyPath" ;;
			AAC) copyPath_AAC="$copyPath" ;;
			OggVorbis) copyPath_OggVorbis="$copyPath" ;;
			Opus) copyPath_Opus="$copyPath" ;;
		esac
	done
}

getDestDir () {
	local outputCodec="$1" codecDestDir=""

	case "$outputCodec" in
		WAV) codecDestDir="$dir_WAV" ;;
		AIFF) codecDestDir="$dir_AIFF" ;;
		CAF) codecDestDir="$dir_CAF" ;;
		FLAC) codecDestDir="$dir_FLAC" ;;
		ALAC) codecDestDir="$dir_ALAC" ;;
		WavPack) codecDestDir="$dir_WavPack" ;;
		WavPackHybrid) codecDestDir="$dir_WavPackHybrid" ;;
		MonkeysAudio) codecDestDir="$dir_MonkeysAudio" ;;

		WavPackLossy) codecDestDir="$dir_WavPackLossy" ;;
		lossyFLAC) codecDestDir="$dir_lossyFLAC" ;;
		MP3) codecDestDir="$dir_MP3" ;;
		AAC) codecDestDir="$dir_AAC" ;;
		OggVorbis) codecDestDir="$dir_OggVorbis" ;;
		Opus) codecDestDir="$dir_Opus" ;;
	esac

	if [ -n "$codecDestDir" ]; then
		echo "$codecDestDir"
	else
		echo "$defaultDestDir"
	fi
}

copyPathOrNot () {
	local outputCodec="$1" copyPath

	case "$outputCodec" in
		WAV) copyPath="$copyPath_WAV" ;;
		AIFF) copyPath="$copyPath_AIFF" ;;
		CAF) copyPath="$copyPath_CAF" ;;
		FLAC) copyPath="$copyPath_FLAC" ;;
		ALAC) copyPath="$copyPath_ALAC" ;;
		WavPack) copyPath="$copyPath_WavPack" ;;
		WavPackHybrid) copyPath="$copyPath_WavPackHybrid" ;;

		WavPackLossy) copyPath="$copyPath_WavPackLossy" ;;
		MonkeysAudio) copyPath="$copyPath_MonkeysAudio" ;;
		lossyFLAC) copyPath="$copyPath_lossyFLAC" ;;
		MP3) copyPath="$copyPath_MP3" ;;
		AAC) copyPath="$copyPath_AAC" ;;
		OggVorbis) copyPath="$copyPath_OggVorbis" ;;
		Opus) copyPath="$copyPath_Opus" ;;
	esac

	if [ -n "$copyPath" ]; then
		echo "$copyPath"
	else
		echo 'false'
	fi
}

setCodecOtherFiles () {
	local outputCodec="$1" pattern="$2" listOfCodecs codec

	case "$outputCodec" in
		default) read -a listOfCodecs <<< "$allCodecsString" ;;
		lossless) read -a listOfCodecs <<< "$losslessCodecsString" ;;
		lossy) read -a listOfCodecs <<< "$lossyCodecsString" ;;
		*) read -a listOfCodecs <<< "$outputCodec" ;;
	esac

	for codec in "${listOfCodecs[@]}"; do
		case "$codec" in
			WAV) copyOtherFiles_WAV="$pattern" ;;
			AIFF) copyOtherFiles_AIFF="$pattern" ;;
			CAF) copyOtherFiles_CAF="$pattern" ;;
			FLAC) copyOtherFiles_FLAC="$pattern" ;;
			ALAC) copyOtherFiles_ALAC="$pattern" ;;
			WavPack) copyOtherFiles_WavPack="$pattern" ;;
			WavPackHybrid) copyOtherFiles_WavPackHybrid="$pattern" ;;
			MonkeysAudio) copyOtherFiles_MonkeysAudio="$pattern" ;;

			WavPackLossy) copyOtherFiles_WavPackLossy="$pattern" ;;
			lossyFLAC) copyOtherFiles_lossyFLAC="$pattern" ;;
			MP3) copyOtherFiles_MP3="$pattern" ;;
			AAC) copyOtherFiles_AAC="$pattern" ;;
			OggVorbis) copyOtherFiles_OggVorbis="$pattern" ;;
			Opus) copyOtherFiles_Opus="$pattern" ;;
		esac
	done
}

getCodecOtherFiles () {
	local outputCodec="$1" otherFilesPattern=""

	case "$outputCodec" in
		WAV) otherFilesPattern="$copyOtherFiles_WAV" ;;
		AIFF) otherFilesPattern="$copyOtherFiles_AIFF" ;;
		CAF) otherFilesPattern="$copyOtherFiles_CAF" ;;
		FLAC) otherFilesPattern="$copyOtherFiles_FLAC" ;;
		ALAC) otherFilesPattern="$copyOtherFiles_ALAC" ;;
		WavPack) otherFilesPattern="$copyOtherFiles_WavPack" ;;
		WavPackHybrid) otherFilesPattern="$copyOtherFiles_WavPackHybrid" ;;
		MonkeysAudio) otherFilesPattern="$copyOtherFiles_MonkeysAudio" ;;

		WavPackLossy) otherFilesPattern="$copyOtherFiles_WavPackLossy" ;;
		lossyFLAC) otherFilesPattern="$copyOtherFiles_lossyFLAC" ;;
		MP3) otherFilesPattern="$copyOtherFiles_MP3" ;;
		AAC) otherFilesPattern="$copyOtherFiles_AAC" ;;
		OggVorbis) otherFilesPattern="$copyOtherFiles_OggVorbis" ;;
		Opus) otherFilesPattern="$copyOtherFiles_Opus" ;;
	esac

	echo "$otherFilesPattern"
}

setCodecCoverArtFile () {
	local outputCodec="$1" coverArtFile="$2" listOfCodecs codec

	case "$outputCodec" in
		default) read -a listOfCodecs <<< "$allCodecsString" ;;
		lossless) read -a listOfCodecs <<< "$losslessCodecsString" ;;
		lossy) read -a listOfCodecs <<< "$lossyCodecsString" ;;
		*) read -a listOfCodecs <<< "$outputCodec" ;;
	esac

	for codec in "${listOfCodecs[@]}"; do
		case "$codec" in
			WAV) coverArtFile_WAV="$coverArtFile" ;;
			AIFF) coverArtFile_AIFF="$coverArtFile" ;;
			CAF) coverArtFile_CAF="$coverArtFile" ;;
			FLAC) coverArtFile_FLAC="$coverArtFile" ;;
			ALAC) coverArtFile_ALAC="$coverArtFile" ;;
			WavPack) coverArtFile_WavPack="$coverArtFile" ;;
			WavPackHybrid) coverArtFile_WavPackHybrid="$coverArtFile" ;;
			MonkeysAudio) coverArtFile_MonkeysAudio="$coverArtFile" ;;

			WavPackLossy) coverArtFile_WavPackLossy="$coverArtFile" ;;
			lossyFLAC) coverArtFile_lossyFLAC="$coverArtFile" ;;
			MP3) coverArtFile_MP3="$coverArtFile" ;;
			AAC) coverArtFile_AAC="$coverArtFile" ;;
			OggVorbis) coverArtFile_OggVorbis="$coverArtFile" ;;
			Opus) coverArtFile_Opus="$coverArtFile" ;;
		esac
	done
}

getCodecCoverArtFile () {
	local outputCodec="$1" coverArtFile=""

	case "$outputCodec" in
		WAV) coverArtFile="$coverArtFile_WAV" ;;
		AIFF) coverArtFile="$coverArtFile_AIFF" ;;
		CAF) coverArtFile="$coverArtFile_CAF" ;;
		FLAC) coverArtFile="$coverArtFile_FLAC" ;;
		ALAC) coverArtFile="$coverArtFile_ALAC" ;;
		WavPack) coverArtFile="$coverArtFile_WavPack" ;;
		WavPackHybrid) coverArtFile="$coverArtFile_WavPackHybrid" ;;
		MonkeysAudio) coverArtFile="$coverArtFile_MonkeysAudio" ;;

		WavPackLossy) coverArtFile="$coverArtFile_WavPackLossy" ;;
		lossyFLAC) coverArtFile="$coverArtFile_lossyFLAC" ;;
		MP3) coverArtFile="$coverArtFile_MP3" ;;
		AAC) coverArtFile="$coverArtFile_AAC" ;;
		OggVorbis) coverArtFile="$coverArtFile_OggVorbis" ;;
		Opus) coverArtFile="$coverArtFile_Opus" ;;
	esac

	echo "$coverArtFile"
}

shouldEmbedCoverArt () {
	local outputCodec="$1" coverArtFile=""

	if [ "$setArtworkParam" = 'true' ]; then
		coverArtFile="$( getCodecCoverArtFile "$outputCodec" )"
		if [ -z "$coverArtFile" ]; then
			echo 'false'
		fi
	fi

	echo 'true'
}

shouldEmbedBinaries () {
	local outputCodec="$1" otherFiles=""

	# FIXME: implement a new -F parameter
	echo 'true'
	return

	if [ "$copyFilesParam" = 'true' ]; then
		otherFiles="$( getCodecOtherFiles "$outputCodec" )"
		if [ -z "$otherFiles" ]; then
			echo 'false'
		fi
	fi

	echo 'true'
}

getNumberOfCpuCores () {
	local core lastCpuID currentCpuID totalNumberOfCores=0

	while read line; do
		core="$( echo "$line" | tr -cd '0-9' 2>/dev/null )"
		case "$line" in
			'physical id'*)
				lastCpuID="$currentCpuID"
				currentCpuID="$core"
				;;

			'cpu cores'*)
				if [ "$currentCpuID" != "$lastCpuID" ]; then
					totalNumberOfCores=$(( totalNumberOfCores + core ))
				fi
				;;
		esac
	done < <( grep -E '^(physical id|cpu cores)' '/proc/cpuinfo' 2>/dev/null )

	echo $totalNumberOfCores
}

startTimer () {
	if [ "$gnudate" = 'true' ]; then
		timerStart="$( $datecmd '+%s.%N' )"
	else
		timerStart="$( $datecmd '+%s' ).0"
	fi
}

endTimer () {
	if [ "$gnudate" = 'true' ]; then
		timerEnd="$( $datecmd '+%s.%N' )"
	else
		timerEnd="$( $datecmd '+%s' ).0"
	fi
	timerSeconds="$( printf "%1.3f" "$( echo "scale=6; $timerEnd - $timerStart" | bc )" )"
	debug ">>> $1 → $timerSeconds seconds"
}

# main() =======================================================================

checkMainBinaries

maxProcesses=''
if which 'nproc' 1>/dev/null 2>&1; then # GNU Coreutils installed
	maxProcesses="$( nproc 2>/dev/null )"
elif which 'gnproc' 1>/dev/null 2>&1; then # GNU Coreutils installed on macOS
	maxProcesses="$( gnproc 2>/dev/null )"
elif [ -e '/proc/cpuinfo' ]; then # Linux
	maxProcesses="$( grep -cF 'cpu MHz' /proc/cpuinfo 2>/dev/null )"
elif [ "$OS" = 'Darwin' ]; then # macOS
	# Many thanks to Tobias Link for helping me port caudec to macOS
	maxProcesses="$( system_profiler -detailLevel full SPHardwareDataType 2>/dev/null | grep -F 'Total Number of Cores:' 2>/dev/null | cut -d ':' -f 2 2>/dev/null | tr -d ' ' | cut -d '(' -f 1 2>/dev/null )"
fi

nProcesses=1
case "$maxProcesses" in
	[1-9]*) nProcesses=$maxProcesses ;;
esac
maxProcessesSetByUser=$nProcesses

case "$orderStrategy" in
	longest|shortest|none) true ;;
	*) orderStrategy="none" ;;
esac

losslessCodecsString="WAV AIFF CAF FLAC ALAC WavPack WavPackHybrid MonkeysAudio"
lossyCodecsString="WavPackLossy lossyFLAC MP3 AAC OggVorbis Opus"
allCodecsString="${losslessCodecsString} ${lossyCodecsString}"

# Set default values
verbose='true'
outputCodecs='' lastCodec='' nCodecs=0 gotWavOutputCodec='false'
defaultDestDir="$PWD" linkDir='' gotLinkedDir='false'
bitDepth='' samplingRate='' preserveMetadata='' applyGain='false' applyGainType='' preamp='' convertToStereo='false'
wavMustBeProcessed='false'
computeReplayGain='false' reverseReplayGain='false'
keepExistingFiles='false' keepNewerFiles='false' macHasVerify='false' outputMode='human'
checkFiles='false' displayInternalHash='false' touchFiles='false' peakReference=0 allFilesAreOpus='true'
setArtworkParam='false' copyFilesParam='false' showInformation='false'

if [ "$Self_Called_As" = "$Self_Decode_Name" ]; then
	lastCodec='WAV' gotWavOutputCodec='true'
	outputCodecs="$outputCodecs $lastCodec"
	(( nCodecs++ ))
fi

getCompressionSetting 'FLAC' "$compression_FLAC" 'caudecrc'
getCompressionSetting 'lossyFLAC' "$compression_lossyWAV" 'caudecrc'
getCompressionSetting 'MonkeysAudio' "$compression_MonkeysAudio" 'caudecrc'
getCompressionSetting 'MP3' "$compression_MP3" 'caudecrc'
getCompressionSetting 'OggVorbis' "$compression_OggVorbis" 'caudecrc'
getCompressionSetting 'Opus' "$compression_Opus" 'caudecrc'
getCompressionSetting 'WavPack' "$compression_WavPack" 'caudecrc'

getConstantBitrate 'AAC' "$bitrate_AAC" 'caudecrc'
getConstantBitrate 'MP3' "$bitrate_MP3" 'caudecrc'
getConstantBitrate 'OggVorbis' "$bitrate_OggVorbis" 'caudecrc'
getConstantBitrate 'Opus' "$bitrate_Opus" 'caudecrc'
getConstantBitrate 'WavPackLossy' "$bitrate_WavPackLossy" 'caudecrc'  # for backwards compatibility

getAverageBitrate 'AAC' "$average_bitrate_AAC" 'caudecrc'
getAverageBitrate 'MP3' "$average_bitrate_MP3" 'caudecrc'
getAverageBitrate 'OggVorbis' "$average_bitrate_OggVorbis" 'caudecrc'
getAverageBitrate 'Opus' "$average_bitrate_Opus" 'caudecrc'
getAverageBitrate 'WavPackLossy' "$average_bitrate_WavPackLossy" 'caudecrc'

getBitrateMode 'AAC' "$AAC_MODE" 'caudecrc'
getBitrateMode 'MP3' "$MP3_MODE" 'caudecrc'
getBitrateMode 'OggVorbis' "$OggVorbis_MODE" 'caudecrc'
getBitrateMode 'Opus' "$Opus_MODE" 'caudecrc'

if which 'mac' 1>/dev/null 2>&1; then
	if mac 2>&1 | grep -F 'Verify:' 1>/dev/null 2>&1; then # mac has the patch that adds the -v parameter
		macHasVerify='true'
	fi
fi

if [ -n "$defaultDestination" ]; then
	if [ ! -e "$defaultDestination" ]; then
		if ! mkdir -p "$defaultDestination" 1>/dev/null 2>&1 ; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultDestination}" "$Self_Name: failed to create '\$defaultDestination' (do you have write permissions?)." ; exit $Ex_Cant_Create
		fi
	fi

	if [ -n "$defaultDestination" ]; then
		if [ ! -d "$defaultDestination" ]; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultDestination}" "$Self_Name: '\$defaultDestination' not a directory." ; exit $Ex_Cant_Create
		elif [ ! -w "$defaultDestination" ]; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultDestination}" "$Self_Name: '\$defaultDestination' is not writable (permission denied)." ; exit $Ex_Cant_Create
		else
			if [ "$defaultDestination" != '/' -a "${defaultDestination%/}" != "$defaultDestination" ]; then
				defaultDestination="${defaultDestination%/}"
			fi
			setDestDir "$allCodecString" "$defaultDestination" 'true'
			defaultDestDir="$defaultDestination"
		fi
	fi
fi

if [ -n "$defaultLosslessDestination" ]; then
	if [ ! -e "$defaultLosslessDestination" ]; then
		if ! mkdir -p "$defaultLosslessDestination" 1>/dev/null 2>&1 ; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultLosslessDestination}" "$Self_Name: failed to create '\$defaultLosslessDestination' (do you have write permissions?)." ; exit $Ex_Cant_Create
		fi
	fi

	if [ -n "$defaultLosslessDestination" ]; then
		if [ ! -d "$defaultLosslessDestination" ]; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultLosslessDestination}" "$Self_Name: '\$defaultLosslessDestination' not a directory." ; exit $Ex_Cant_Create
		elif [ ! -w "$defaultLosslessDestination" ]; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultLosslessDestination}" "$Self_Name: '\$defaultLosslessDestination' is not writable (permission denied)." ; exit $Ex_Cant_Create
		else
			if [ "$defaultLosslessDestination" != '/' -a "${defaultLosslessDestination%/}" != "$defaultLosslessDestination" ]; then
				defaultLosslessDestination="${defaultLosslessDestination%/}"
			fi
			setDestDir "$losslessCodecsString" "$defaultLosslessDestination" 'true'
		fi
	fi
fi

if [ -n "$defaultLossyDestination" ]; then
	if [ ! -e "$defaultLossyDestination" ]; then
		if ! mkdir -p "$defaultLossyDestination" 1>/dev/null 2>&1 ; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultLossyDestination}" "$Self_Name: failed to create '\$defaultLossyDestination' (do you have write permissions?)." ; exit $Ex_Cant_Create
		fi
	fi

	if [ -n "$defaultLossyDestination" ]; then
		if [ ! -d "$defaultLossyDestination" ]; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultLossyDestination}" "$Self_Name: '\$defaultLossyDestination' not a directory." ; exit $Ex_Cant_Create
		elif [ ! -w "$defaultLossyDestination" ]; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultLossyDestination}" "$Self_Name: '\$defaultLossyDestination' is not writable (permission denied)." ; exit $Ex_Cant_Create
		else
			if [ "$defaultLossyDestination" != '/' -a "${defaultLossyDestination%/}" != "$defaultLossyDestination" ]; then
				defaultLossyDestination="${defaultLossyDestination%/}"
			fi
			setDestDir "$lossyCodecsString" "$defaultLossyDestination" 'true'
		fi
	fi
fi

# defaultLinkedDestination
if [ -n "$defaultLinkedDestination" ]; then
	if [ ! -e "$defaultLinkedDestination" ]; then
		if ! mkdir -p "$defaultLinkedDestination" 1>/dev/null 2>&1 ; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultLinkedDestination}" "$Self_Name: failed to create '\$defaultLinkedDestination' (do you have write permissions?)." ; exit $Ex_Cant_Create
		fi
	fi

	if [ -n "$defaultLinkedDestination" ]; then
		if [ ! -d "$defaultLinkedDestination" ]; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultLinkedDestination}" "$Self_Name: '\$defaultLinkedDestination' not a directory." ; exit $Ex_Cant_Create
		elif [ ! -w "$defaultLinkedDestination" ]; then
			printMessage 'error' 'usage' 'filesystem' "path:${defaultLinkedDestination}" "$Self_Name: '\$defaultLinkedDestination' is not writable (permission denied)." ; exit $Ex_Cant_Create
		else
			if [ "$defaultLinkedDestination" != '/' -a "${defaultLinkedDestination%/}" != "$defaultLinkedDestination" ]; then
				defaultLinkedDestination="${defaultLinkedDestination%/}"
			fi
			gotLinkedDir='true'
			linkDir="$defaultLinkedDestination"
		fi
	fi
fi

if [ -n "$setCoverArtworkFileByDefault" ]; then
	setCodecCoverArtFile "default" "$setCoverArtworkFileByDefault"
fi
if [ -n "$setCoverArtworkFileForLosslessByDefault" ]; then
	setCodecCoverArtFile "lossless" "$setCoverArtworkFileForLosslessByDefault"
fi
if [ -n "$setCoverArtworkFileForLossyByDefault" ]; then
	setCodecCoverArtFile "lossy" "$setCoverArtworkFileForLossyByDefault"
fi

if [ -n "$copyOtherFilesByDefault" ]; then
	setCodecOtherFiles "default" "$copyOtherFilesByDefault"
fi
if [ -n "$copyOtherFilesForLosslessByDefault" ]; then
	setCodecOtherFiles "lossless" "$copyOtherFilesForLosslessByDefault"
fi
if [ -n "$copyOtherFilesForLossyByDefault" ]; then
	setCodecOtherFiles "lossy" "$copyOtherFilesForLossyByDefault"
fi

while getopts '2a:B:b:C:c:df:G:ghHiIKkL:l:n:O:o:P:q:r:S:sTtuVZz' o ; do
	case $o in
# -----------------------------------------------------------------------------

		n)
			case "$OPTARG" in
				[0-9]|[0-9][0-9])
					if [ $OPTARG -le $maxProcesses ]; then
						nProcesses=$OPTARG
						maxProcessesSetByUser=$OPTARG
					else
						printMessage 'error' 'usage' 'bad_value' "$Self_Name -n: the number of processes must be an integer between 1 and $maxProcesses" ; exit $Ex_Usage
					fi
					;;

				*) printMessage 'error' 'usage' 'bad_value' "$Self_Name -n: the number of processes must be an integer between 1 and $maxProcesses" ; exit $Ex_Usage ;;
			esac
			;;

		i) ignoreUnsupportedFiles='true' ;;

		s) verbose='false' ;;

		S)
			case "$OPTARG" in
				n|none) orderStrategy="none" ;;
				s|shortest) orderStrategy="shortest" ;;
				l|longest) orderStrategy="longest" ;;
				*) printMessage 'error' 'usage' 'bad_value' "$Self_Name -S: the order strategy must be either 'l' / 'longest', 's' / 'shortest' or 'n' / 'none' (default)" ; exit $Ex_Usage ;;
			esac
			;;

		z) outputMode='machine' ;;

		Z) outputMode='humanAndMachine' ;;

# -----------------------------------------------------------------------------

		b)
			if [ -z "$lastCodec" ]; then
				case "$OPTARG" in
					16|24) bitDepth=$OPTARG wavMustBeProcessed='true' ;;
					*) printMessage 'error' 'usage' 'bad_value' "$Self_Name -b: bit depth must be either 16 or 24" ; exit $Ex_Usage
				esac
			else
				case "$lastCodec" in
					AAC) getConstantBitrate 'AAC' "$OPTARG" ; AAC_MODE='CBR' ;;
					MP3) getConstantBitrate 'MP3' "$OPTARG" ; MP3_MODE='CBR' ;;
					OggVorbis) getConstantBitrate 'OggVorbis' "$OPTARG" ; OggVorbis_MODE='CBR' ;;
					Opus) getConstantBitrate 'Opus' "$OPTARG" ; Opus_MODE='CBR' ;;
					WavPackHybrid|WavPackLossy) getAverageBitrate 'WavPackLossy' "$OPTARG" ;; # for backwards compatibility
					*) printMessage 'error' 'usage' 'command_line' "$Self_Name -b: parameter not available with the selected codec" ; exit $Ex_Usage ;;
				esac
			fi
			;;

		r)
			if [ -n "$lastCodec" -a "$Self_Called_As" != "$Self_Decode_Name" ]; then
				printMessage 'error' 'usage' 'command_line' "$Self_Name -r: parameter must be given before -c" ; exit $Ex_Usage
			fi
			case "$OPTARG" in
				44|44.1) samplingRate=44100 ;;
				88|88.2) samplingRate=88200 ;;
				176|176.4) samplingRate=176400 ;;
				352|352.8) samplingRate=352800 ;;
				48|96|192|384) samplingRate="${OPTARG}000" ;;
				44100|48000|88200|96000|176400|192000|352800|384000) samplingRate=$OPTARG ;;
				cd|CD) bitDepth=16 samplingRate=44100 convertToStereo='flat' ;;
				dvd|DVD) bitDepth=16 samplingRate=48000 ;;
				sacd|SACD) bitDepth=24 samplingRate=88200 ;;
				dvda|DVDA|dvdaudio|DVDAUDIO|DVDAudio|bd|BD|bluray|BLURAY|BluRay) bitDepth=24 samplingRate=96000 ;;
				pono|Pono|PONO) bitDepth=24 samplingRate=192000 ;;
				dxd|DXD) bitDepth=24 samplingRate=352800 ;;
				*) printMessage 'error' 'usage' 'bad_value' "$Self_Name -r: sampling rate must be one of 44[100], 48[000], 88[200], 96[000], 176[400], 192[000], 352[800], 384[000], cd, dvd, sacd, dvda, bluray, pono or dxd" ; exit $Ex_Usage
			esac
			 wavMustBeProcessed='true'
			;;

		2)
			if [ -n "$lastCodec" -a "$Self_Called_As" != "$Self_Decode_Name" ]; then
				printMessage 'error' 'usage' 'command_line' "$Self_Name -2: parameter must be given before -c" ; exit $Ex_Usage
			fi
			convertToStereo='flat' wavMustBeProcessed='true'
			;;

# -----------------------------------------------------------------------------

		c|C)
			case "$OPTARG" in
				wav)                 lastCodec='WAV' gotWavOutputCodec='true' ;;
				aiff)                lastCodec='AIFF' ;;
				caf)                 lastCodec='CAF' ;;
				flac)                lastCodec='FLAC' ;;
				alac)                lastCodec='ALAC' ;;
				wv)                  lastCodec='WavPack' ;;
				wvh)                 lastCodec='WavPackHybrid' ;;

				wvl)                 lastCodec='WavPackLossy' ;;
				aac)                 lastCodec='AAC' ;;
				ape)                 lastCodec='MonkeysAudio' ;;
				lossyFLAC|lossyflac) lastCodec='lossyFLAC' ;;
				mp3)                 lastCodec='MP3' ;;
				ogg|vorbis)          lastCodec='OggVorbis' ;;
				opus)                lastCodec='Opus' ;;
				*) printMessage 'error' 'usage' 'bad_value' "$Self_Name -c: invalid codec (try $Self_Name -h)" ; exit $Ex_Usage ;;
			esac

			outputCodecs="$outputCodecs $lastCodec"; (( nCodecs++ ))
			if [ "$o" = 'c' ]; then
				preserveMetadata="${preserveMetadata}x${lastCodec}Y"
			fi

			grep -E "(WavPack.*WavPackLossy)|(WavPackLossy.*WavPack)" < <( echo "$outputCodecs" ) 1>/dev/null 2>/dev/null; exitCode=$?
			if [ $exitCode -eq $Ex_Ok ]; then
				printMessage 'error' 'usage' 'bad_value' "$Self_Name -c: don't specify both WavPack[*] and WavPackLossy; choose one or the other."
				printMessage 'error' 'usage' 'bad_value' "$Self_Name -c: if you want both lossless and lossy WavPack, choose -c wvh (possibly with -l DIR)"
				exit $Ex_Usage
			fi

			if [ "$lastCodec" = "WavPackLossy" -a -n "$linkDir" ]; then
				gotLinkedDir='false'
				linkDir=""
			fi
			;;

		q)
			if [ -z "$lastCodec" ]; then
				printMessage 'error' 'usage' 'command_line' "$Self_Name -q: you must specify a codec first (-c)" ; exit $Ex_Usage
			fi

			case "$lastCodec" in
				FLAC) getCompressionSetting 'FLAC' "$OPTARG" ;;
				lossyFLAC) getCompressionSetting "$lastCodec" "$OPTARG" ;;
				MonkeysAudio) getCompressionSetting 'MonkeysAudio' "$OPTARG" ;;
				MP3) getCompressionSetting 'MP3' "$OPTARG" ; MP3_MODE='VBR' ;;
				OggVorbis) getCompressionSetting 'OggVorbis' "$OPTARG" ; OggVorbis_MODE='VBR' ;;
				Opus) getCompressionSetting 'Opus' "$OPTARG" ; Opus_MODE='VBR' ;;
				WavPack|WavPackHybrid) getCompressionSetting 'WavPack' "$OPTARG" ;;
				WavPackLossy) getCompressionSetting 'WavPackLossy' "$OPTARG" ;;
				*) printMessage 'error' 'usage' 'command_line' "$Self_Name -q: parameter not available with the selected codec" ; exit $Ex_Usage ;;
			esac ;;

		B)
			if [ -z "$lastCodec" ]; then
				printMessage 'error' 'usage' 'command_line' "$Self_Name -B: you must select a codec first (-c)" ; exit $Ex_Usage
			fi
			case "$lastCodec" in
				AAC) getAverageBitrate 'AAC' "$OPTARG" ; AAC_MODE='ABR' ;;
				MP3) getAverageBitrate 'MP3' "$OPTARG" ; MP3_MODE='ABR' ;;
				OggVorbis) getAverageBitrate 'OggVorbis' "$OPTARG" ; OggVorbis_MODE='ABR' ;;
				Opus) getAverageBitrate 'Opus' "$OPTARG" ; Opus_MODE='ABR' ;;
				WavPackHybrid|WavPackLossy) getAverageBitrate 'WavPackLossy' "$OPTARG" ;;
				*) printMessage 'error' 'usage' 'command_line' "$Self_Name -B: parameter not available with the selected codec" ; exit $Ex_Usage ;;
			esac
			;;

		o)
			lastCodecDestDir="$OPTARG"
			if [ "$lastCodecDestDir" != '/' -a "${lastCodecDestDir%/}" != "$lastCodecDestDir" ]; then
				lastCodecDestDir="${lastCodecDestDir%/}"
			fi
			if [ ! -e "$lastCodecDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${lastCodecDestDir}" "$Self_Name -o: directory doesn't exist. Either create it manually, or try again with -O." ; exit $Ex_Cant_Create
			elif [ ! -d "$lastCodecDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${lastCodecDestDir}" "$Self_Name -o: not a directory." ; exit $Ex_Cant_Create
			elif [ ! -w "$lastCodecDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${lastCodecDestDir}" "$Self_Name -o: directory is not writable (permission denied)." ; exit $Ex_Cant_Create
			fi
			setDestDir "$lastCodec" "$lastCodecDestDir" 'false'
			lastCodecDestDir=""
			;;

		O|P)
			lastCodecDestDir="$OPTARG"
			if [ "$lastCodecDestDir" != '/' -a "${lastCodecDestDir%/}" != "$lastCodecDestDir" ]; then
				lastCodecDestDir="${lastCodecDestDir%/}"
			fi
			if [ ! -e "$lastCodecDestDir" ]; then
				if ! mkdir -p "$lastCodecDestDir" 1>/dev/null 2>&1 ; then
					printMessage 'error' 'usage' 'filesystem' "path:${lastCodecDestDir}" "$Self_Name -O/P: failed to create directory (do you have write permissions?)." ; exit $Ex_Cant_Create
				fi
			elif [ ! -d "$lastCodecDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${lastCodecDestDir}" "$Self_Name -O/P: not a directory." ; exit $Ex_Cant_Create
			elif [ ! -w "$lastCodecDestDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${lastCodecDestDir}" "$Self_Name -O/P: directory is not writable (permission denied)." ; exit $Ex_Cant_Create
			fi
			if [ "$o" = 'P' ]; then
				setDestDir "$lastCodec" "$lastCodecDestDir" 'true'
			else
				setDestDir "$lastCodec" "$lastCodecDestDir" 'false'
			fi
			lastCodecDestDir=""
			;;

		# from an original idea by Porcus on https://hydrogenaudio.org/index.php/topic,127856.msg1062957.html#msg1062957
		l)
			if [ "$lastCodec" != "WavPackHybrid" -a "$touchFiles" = 'false' ]; then
				printMessage 'error' 'usage' 'command_line' "$Self_Name -l: it must be preceded by -c wvh or -T." ; exit $Ex_Usage
			fi
			gotLinkedDir='false'
			linkDir="$OPTARG"
			if [ "$linkDir" != '/' -a "${linkDir%/}" != "$linkDir" ]; then
				linkDir="${linkDir%/}"
			fi
			if [ ! -e "$linkDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${linkDir}" "$Self_Name -l: directory doesn't exist. Either create it manually, or try again with -L." ; exit $Ex_Cant_Create
			elif [ ! -d "$linkDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${linkDir}" "$Self_Name -l: not a directory." ; exit $Ex_Cant_Create
			elif [ ! -w "$linkDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${linkDir}" "$Self_Name -l: directory is not writable (permission denied)." ; exit $Ex_Cant_Create
			fi
			gotLinkedDir='true'
			;;

		# from an original idea by Porcus on https://hydrogenaudio.org/index.php/topic,127856.msg1062957.html#msg1062957
		L)
			if [ "$lastCodec" != "WavPackHybrid" -a "$touchFiles" = 'false' ]; then
				printMessage 'error' 'usage' 'command_line' "$Self_Name -L: it must be preceded by -c wvh or -T." ; exit $Ex_Usage
			fi
			gotLinkedDir='false'
			linkDir="$OPTARG"
			if [ "$linkDir" != '/' -a "${linkDir%/}" != "$linkDir" ]; then
				linkDir="${linkDir%/}"
			fi
			if [ ! -e "$linkDir" ]; then
				if ! mkdir -p "$linkDir" 1>/dev/null 2>&1 ; then
					printMessage 'error' 'usage' 'filesystem' "path:${linkDir}" "$Self_Name -L: failed to create directory (do you have write permissions?)." ; exit $Ex_Cant_Create
				fi
			elif [ ! -d "$linkDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${linkDir}" "$Self_Name -L: not a directory." ; exit $Ex_Cant_Create
			elif [ ! -w "$linkDir" ]; then
				printMessage 'error' 'usage' 'filesystem' "path:${linkDir}" "$Self_Name -L: directory is not writable (permission denied)." ; exit $Ex_Cant_Create
			fi
			gotLinkedDir='true'
			;;

		a)
			setArtworkParam='true'
			case "$OPTARG" in
				*.jpg|*.jpeg|*.png|"")
				 	# "" disables embedding artwork
					if [ -z "$lastCodec" ]; then
						setCodecCoverArtFile "default" "$OPTARG"
					elif [ -n "$lastCodec" ]; then
						setCodecCoverArtFile "$lastCodec" "$OPTARG"
					fi
					;;

				*) printMessage 'error' 'usage' 'bad_value' "$Self_Name -a: the argument must be a JPEG or PNG file" ; exit $Ex_Usage ;;
			esac
			;;

		f)
			copyFilesParam='true'
			if [ -z "$lastCodec" ]; then
				setCodecOtherFiles "default" "$OPTARG"
			elif [ -n "$lastCodec" ]; then
				if [ "$lastCodec" = "WavPackHybrid" ]; then
					if [ "$gotLinkedDir" = 'true' ]; then
						setCodecOtherFiles "WavPackLossy" "$OPTARG"
					else
						setCodecOtherFiles "WavPackHybrid" "$OPTARG"
					fi
				# elif [ "$lastCodec" = "WavPackLossy" ]; then
				# 	setCodecOtherFiles "WavPackLossy" "$OPTARG"
				else
					setCodecOtherFiles "$lastCodec" "$OPTARG"
				fi
			fi
			;;

		k)
			keepExistingFiles='true'
			if [ "$keepNewerFiles" = 'true' ]; then
				printMessage 'error' 'usage' 'command_line' "$Self_Name -k: parameters -k and -K are mutually exclusive. Choose one or the other." ; exit $Ex_Usage
			fi
			;;

		K)
			keepNewerFiles='true'
			if [ "$keepExistingFiles" = 'true' ]; then
				printMessage 'error' 'usage' 'command_line' "$Self_Name -K: parameters -k and -K are mutually exclusive. Choose one or the other." ; exit $Ex_Usage
			fi
			;;

# -----------------------------------------------------------------------------

		d)
			if [ "$Self_Called_As" != "$Self_Decode_Name" ]; then
				lastCodec='WAV'; outputCodecs="$outputCodecs $lastCodec"
			fi
			;;

		t) checkFiles='true' ;;

		H) displayInternalHash='true' ;;

# -----------------------------------------------------------------------------

		g) computeReplayGain='true' ;;

		# FIXME
		G)
			if [ -z "$outputCodecs" ]; then
				case "$OPTARG" in
					album) gainValue='ALBUM'; computeReplayGain='true' applyGain='true' applyGainType="$gainValue" ;;
					track) gainValue='TRACK'; computeReplayGain='true' applyGain='true' applyGainType="$gainValue"  ;;
					undo) reverseReplayGain='true' ;;
					*) printMessage 'error' 'usage' 'bad_value' "$Self_Name -G: MP3 gain type must be 'album', 'track' or 'undo'" ; exit $Ex_Usage ;;
				esac
			else
				case "$OPTARG" in
					album) gainValue='ALBUM' ;;
					track) gainValue='TRACK' ;;
					albumpeak) gainValue='ALBUM_PEAK' ;;
					trackpeak) gainValue='TRACK_PEAK' ;;
					+[0-9]|+[1-9][0-9]) gainValue="${OPTARG}.00" ;; # integer
					+[0-9].[0-9]|+[1-9][0-9].[0-9]) gainValue="${OPTARG}0" ;; # floating point, 1 decimal
					+[0-9].[0-9][0-9]|+[1-9][0-9].[0-9][0-9]) gainValue="$OPTARG" ;; # floating point, 2 decimals
					-[0-9]|-[1-9][0-9]) gainValue="${OPTARG}.00" ;; # integer
					-[0-9].[0-9]|-[1-9][0-9].[0-9]) gainValue="${OPTARG}0" ;; # floating point, 1 decimal
					-[0-9].[0-9][0-9]|-[1-9][0-9].[0-9][0-9]) gainValue="$OPTARG" ;; # floating point, 2 decimals
					*) printMessage 'error' 'usage' 'bad_value' "$Self_Name -G: gain type must be either album or track, albumpeak or trackpeak, or a signed number between -99.99 and +99.99" ; exit $Ex_Usage
				esac
				if [ "$applyGain" = 'true' ]; then
					case "$applyGainType" in
						ALBUM|TRACK)
							preamp="$gainValue"
							;;

						ALBUM_PEAK|TRACK_PEAK)
							if [ "${gainValue:0:1}" = '-' ]; then
								peakReference="$gainValue"
							fi
							;;
					esac
				else
					applyGainType="$gainValue"
				fi
				applyGain='true'
				if [ "${gainValue:1}" = '0.00' ]; then
					printMessage 'error' 'usage' 'bad_value' "$Self_Name -G: gain value must not be equal to 0" ; exit $Ex_Usage
				fi
				unset gainValue
			fi
			;;

# -----------------------------------------------------------------------------

		T) touchFiles='true' ;;

# -----------------------------------------------------------------------------

		h) printUsage; exit $Ex_Ok ;;

		I) showInformation='true' ;;

		V) echo "$Self_Name $Self_Version"; exit $Ex_Ok ;;

# -----------------------------------------------------------------------------

		*) printMessage 'error' 'usage' 'command_line' "Run '$Self_Name -h' for more information." ; exit $Ex_Usage ;;
	esac
done

shift $(( OPTIND - 1 ))
if [ $# -lt 1 ]; then
	if [ "$outputMode" = 'machine' ]; then
		printMachineSyntax
		exit $Ex_Ok
	else
		printUsage 1>&2
		exit $Ex_Usage
	fi
fi

outputCodecs="${outputCodecs# }"

if [ "$outputCodecs" = 'WAV' -a "$applyGain" = 'true' ]; then
	wavMustBeProcessed='true'
fi

# transcode, test, replaygain, touch, hash
if [ -z "$outputCodecs" -a "$checkFiles" = 'false' -a "$computeReplayGain" = 'false' -a "$reverseReplayGain" = 'false' -a "$touchFiles" = 'false' -a "$displayInternalHash" = 'false' -a "$showInformation" = 'false' ]; then
	printMessage 'error' 'usage' 'command_line' "$Self_Name: no action specified"
	exit $Ex_Usage
fi

# transcode
if [ -z "$outputCodecs" ]; then
	if [ "$setArtworkParam" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -a is only available when transcoding (-c)."
		exit $Ex_Usage
	fi
	if [ "$copyFilesParam" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -f is only available when transcoding (-c)."
		exit $Ex_Usage
	fi
	if [ "$keepExistingFiles" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -k is only available when -c has been provided."
		exit $Ex_Usage
	fi
	if [ "$keepNewerFiles" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -K is only available when -c has been provided."
		exit $Ex_Usage
	fi
fi

# transcode (test, replaygain, touch, hash, information)
if [ -n "$outputCodecs" ]; then
	if [ "$computeReplayGain" = 'true' -o "$reverseReplayGain" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -c/-d and -g/-G are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ "$displayInternalHash" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -c/-d and -H are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ "$touchFiles" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -c/-d and -T are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ "$checkFiles" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -c/-d and -t are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ "$showInformation" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -c/-d and -I are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
fi

# Test files (replaygain, touch, hash, information)
if [ "$checkFiles" = 'true' ]; then
	if [ "$computeReplayGain" = 'true' -o "$reverseReplayGain" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -t and -g/-G are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ "$touchFiles" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -t and -T are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ "$displayInternalHash" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -t and -H are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ "$showInformation" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -t and -I are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
fi

# ReplayGain (test, touch, hash, information)
if [ "$computeReplayGain" = 'true' -o "$reverseReplayGain" = 'true' ]; then
	if [ "$checkFiles" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -g/-G and -t are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ "$touchFiles" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -g/-G and -T are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ "$displayInternalHash" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -g/-G and -H are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ "$showInformation" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -g/-G and -I are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
fi

# Touch files (test, replaygain, hash, information)
if [ "$touchFiles" = 'true' ]; then
	if [ "$checkFiles" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -T and -t are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ "$computeReplayGain" = 'true' -o "$reverseReplayGain" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -T and -g/-G are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ "$displayInternalHash" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -T and -H are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ "$showInformation" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -T and -I are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
fi

# Hash files (test, replaygain, touch, information)
if [ "$displayInternalHash" = 'true' ]; then
	if [ "$checkFiles" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -H and -t are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ "$computeReplayGain" = 'true' -o "$reverseReplayGain" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -H and -g/-G are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ "$touchFiles" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -H and -T are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ "$showInformation" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -H and -I are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
fi

# Show information (test, replaygain, touch, hash)
if [ "$showInformation" = 'true' ]; then
	if [ "$checkFiles" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -I and -t are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ "$computeReplayGain" = 'true' -o "$reverseReplayGain" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -I and -g/-G are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ "$touchFiles" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -I and -T are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
	if [ "$displayInternalHash" = 'true' ]; then
		printMessage 'error' 'usage' 'command_line' "$Self_Name: -I and -H are mutually exclusive. Try again with either one alone."
		exit $Ex_Usage
	fi
fi

exitCode=$Ex_Ok
declare -a inputFilesAndDirs=("$@")
declare -a inputFiles=()
declare -a sourceFiles=()
numberOfInputFiles=0
numberOfSourceFiles=0

# startTimer
getInputFiles
# endTimer "getInputFiles()"

# startTimer
checkInputFiles
# endTimer "checkInputFiles()"

# startTimer
checkBinaries
# endTimer "checkBinaries()"

# startTimer
handleInstance
# endTimer "handleInstance()"

# startTimer
setupControlDir
# endTimer "setupControlDir()"

# startTimer
setupSwapDir
# endTimer "setupSwapDir()"
# endTimer "setup"

numberOfOutputFiles=$(( numberOfSourceFiles * nCodecs ))

for signal in INT TERM ABRT PIPE; do
	trap "cleanAbort" $signal
done

if [ -n "$outputCodecs" -a "$tagCompressionSetting" = 'true' ]; then
	getEncoderVersions
fi

if [ $nCodecs -gt 0 ]; then # action: transcode files
	checkOutputDirectories

	adjustNumberOfProcesses $numberOfOutputFiles
	if [ "$gnudate" = 'true' ]; then
		time1="$( $datecmd '+%s.%N' )"
	else
		time1="$( $datecmd '+%s' ).0"
	fi
	for (( processNumber=0; processNumber < nProcesses; processNumber++ )); do
		transcode &
	done
elif [ "$checkFiles" = 'true' ]; then
	adjustNumberOfProcesses $numberOfSourceFiles
	if [ "$gnudate" = 'true' ]; then
		time1="$( $datecmd '+%s.%N' )"
	else
		time1="$( $datecmd '+%s' ).0"
	fi
	for (( processNumber=0; processNumber < nProcesses; processNumber++ )); do
		testFiles &
	done
elif [ "$computeReplayGain" = 'true' ]; then
	adjustNumberOfProcesses $numberOfSourceFiles
	if [ "$gnudate" = 'true' ]; then
		time1="$( $datecmd '+%s.%N' )"
	else
		time1="$( $datecmd '+%s' ).0"
	fi
	for (( processNumber=0; processNumber < nProcesses; processNumber++ )); do
		computeTrackGains &
	done
elif [ "$reverseReplayGain" = 'true' ]; then
	adjustNumberOfProcesses $numberOfSourceFiles
	if [ "$gnudate" = 'true' ]; then
		time1="$( $datecmd '+%s.%N' )"
	else
		time1="$( $datecmd '+%s' ).0"
	fi
	if [ "$allFilesAreOpus" = 'true' ]; then
		reverseOpusTrackGains || exitCode=$Ex_Ko
	else
		for (( processNumber=0; processNumber < nProcesses; processNumber++ )); do
			reverseTrackGains &
		done
	fi
elif [ "$touchFiles" = 'true' ]; then
	adjustNumberOfProcesses $numberOfSourceFiles
	if [ "$gnudate" = 'true' ]; then
		time1="$( $datecmd '+%s.%N' )"
	else
		time1="$( $datecmd '+%s' ).0"
	fi
	for (( processNumber=0; processNumber < nProcesses; processNumber++ )); do
		computeTrackDateTimes &
	done
elif [ "$displayInternalHash" = 'true' ]; then
	adjustNumberOfProcesses $numberOfSourceFiles
	if [ "$gnudate" = 'true' ]; then
		time1="$( $datecmd '+%s.%N' )"
	else
		time1="$( $datecmd '+%s' ).0"
	fi
	for (( processNumber=0; processNumber < nProcesses; processNumber++ )); do
		showInternalHashes &
	done
elif [ "$showInformation" = 'true' ]; then
	adjustNumberOfProcesses $numberOfSourceFiles
	if [ "$gnudate" = 'true' ]; then
		time1="$( $datecmd '+%s.%N' )"
	else
		time1="$( $datecmd '+%s' ).0"
	fi
	for (( processNumber=0; processNumber < nProcesses; processNumber++ )); do
		showTracksInformation &
	done
fi
exitCode=$Ex_Ok ; for jobIndex in $( jobs -p ); do wait $jobIndex || exitCode=$Ex_Ko ; done

if [ $exitCode -eq $Ex_Ok ]; then
	if [ "$computeReplayGain" = 'true' ]; then
		if [ "$allFilesAreOpus" = 'true' ]; then
			computeOpusAlbumGain || exitCode=$Ex_Ko
		else
			if [ "$applyGain" = 'false' -o "$applyGainType" = 'ALBUM' ]; then
				computeAlbumGain || exitCode=$Ex_Ko
			fi
		fi
	elif [ "$touchFiles" = 'true' ]; then
		touchAllFiles || exitCode=$Ex_Ko
	fi
fi

if [ "$gnudate" = 'true' ]; then
	time2="$( $datecmd '+%s.%N' )"
else
	time2="$( $datecmd '+%s' ).0"
fi

# print transcoding stats if applicable
if [ $exitCode -eq $Ex_Ok -a "$verbose" = 'true' ]; then
	# startTimer
	if [ "$outputMode" = 'machine' ]; then
		printMachineStats
	else
		printHumanStats
	fi
	# endTimer "print stats"
fi

cleanExit $exitCode
