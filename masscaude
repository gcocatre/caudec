#!/bin/bash

# Copyright © 2012 - 2025 Guillaume Cocatre-Zilgien <guillaume@cocatre.net>
# https://github.com/gcocatre/caudec
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Global variables =============================================================

declare -r Self_Name='masscaude'
declare -r Self_Version='4.6.0'

# Ex_Usage: The command was used incorrectly, e.g., with the wrong number of arguments, a bad flag, a bad syntax in a parameter, or whatever.
# Ex_Data_Err: The input data was incorrect in some way. This should only be used for user's data & not system files.
# Ex_No_Input: An input file (not a system file) did not exist or was not readable. This could also include errors like "No message" to a mailer (if it cared to catch it).
# Ex_No_User: The user specified did not exist. This might be used for mail addresses or remote logins.
# Ex_No_Host: The host specified did not exist. This is used in mail addresses or network requests.
# Ex_Unavailable: A service is unavailable. This can occur if a support program or file does not exist. This can also be used as a catchall message when something you wanted to do doesn't work, but you don't know why.
# Ex_Software: An internal software error has been detected. This should be limited to non-operating system related errors as possible.
# Ex_Os_Err: An operating system error has been detected. This is intended to be used for such things as "cannot fork", "cannot create pipe", or the like. It includes things like getuid returning a user that does not exist in the passwd file.
# Ex_Os_File: Some system file (e.g., /etc/passwd, /etc/utmp, etc.) does not exist, cannot be opened, or has some sort of error (e.g., syntax error).
# Ex_Cant_Create: A (user specified) output file cannot be created.
# Ex_Io_Err: An error occurred while doing I/O on some file.
# Ex_Temp_Fail: temporary failure, indicating something that is not really an error. In sendmail, this means that a mailer (e.g.) could not create a connection, and the request should be reattempted later.
# Ex_Protocol: the remote system returned something that was "not possible" during a protocol exchange.
# Ex_No_Perm: You did not have sufficient permission to perform the operation. This is not intended for file system problems, which should use NOINPUT or CANTCREAT, but rather for higher level permissions.

declare -r Ex_Ok=0            # successful termination
declare -r Ex_Ko=1            # unsuccessful termination
declare -r Ex_Usage=64        # command line usage error
declare -r Ex_Data_Err=65     # data format error
declare -r Ex_No_Input=66     # cannot open input
declare -r Ex_No_User=67      # addressee unknown
declare -r Ex_No_Host=68      # host name unknown
declare -r Ex_Unavailable=69  # service unavailable
declare -r Ex_Software=70     # internal software error
declare -r Ex_Os_Err=71       # system error (e.g., can't fork)
declare -r Ex_Os_File=72      # critical OS file missing
declare -r Ex_Cant_Create=73	# can't create (user) output file
declare -r Ex_Io_Err=74       # input/output error
declare -r Ex_Temp_Fail=75    # temp failure; user is invited to retry
declare -r Ex_Protocol=76     # remote error in protocol
declare -r Ex_No_Perm=77      # permission denied
declare -r Ex_Config_Err=78   # configuration error
declare -r Ex_Interrupt=143   # user interruption (Ctrl+C)

# https://dev.to/ifenna__/adding-colors-to-bash-scripts-48g4

# Clr_El="\\033[2K\\033[0G" # FIXME: can't remember what that does
Clr_Ok="\\033[1;32m" # bright green
Clr_Ko="\\033[1;31m" # bright red
Clr_Wg="\\033[1;33m" # bright yellow

Clr_Rst="\\033[0m" # reset (normal color)

Clr_N_Bk="\\033[0;30m" # black
Clr_B_Bk="\\033[1;30m" # dark gray
Clr_N_Rd="\\033[0;31m" # dark red
Clr_B_Rd="\\033[1;31m" # bright red
Clr_N_Gr="\\033[0;32m" # dark green
Clr_B_Gr="\\033[1;32m" # bright green
Clr_N_Yl="\\033[0;33m" # brown
Clr_B_Yl="\\033[1;33m" # yellow
Clr_N_Bl="\\033[0;34m" # dark blue
Clr_B_Bl="\\033[1;34m" # bright blue
Clr_N_Pp="\\033[0;35m" # dark purple
Clr_B_Pp="\\033[1;35m" # bright purple
Clr_N_Cy="\\033[0;36m" # dark cyan
Clr_B_Cy="\\033[1;36m" # bright cyan
Clr_N_Wh="\\033[0;37m" # bright gray
Clr_B_Wh="\\033[1;37m" # white

declare -r Self_Permissions='u=rwX,go=rX'

for arg in "$@"; do
  if [ "${arg:0:2}" = '--' ]; then
    echo "${Self_Name}: error: try -h" 1>&2
    exit $Ex_Usage
  fi
done

if [ -r '/etc/caudecrc' ]; then
	. '/etc/caudecrc'
fi

if [ -r "${HOME}/.caudecrc" ]; then
	. "${HOME}/.caudecrc"
fi

if [ "$transcaudeTouchFiles" != 'false' ]; then
  transcaudeTouchFiles='true'
fi
if [ "$computeLosslessReplayGain" != 'false' ]; then
  computeLosslessReplayGain='true'
fi

datecmd='date' gnudate='true'
findcmd='find' gnufind='true'
sedcmd='sed' gnused='true'
statcmd='stat' gnustat='true'
if which 'uname' 1>/dev/null 2>&1 ; then
	OS="$( uname -s )"
	if [ "$OS" = 'Darwin' ]; then
		gnudate='false' gnufind='false' gnused='false' gnustat='false'
		if which 'gdate' 1>/dev/null 2>&1; then
			datecmd='gdate' gnudate='true'
		fi
		if which 'gfind' 1>/dev/null 2>&1; then
			findcmd='gfind' gnufind='true'
		fi
		if which 'gsed' 1>/dev/null 2>&1; then
			sedcmd='gsed' gnused='true'
		fi
		if which 'gstat' 1>/dev/null 2>&1; then
			statcmd='gstat' gnustat='true'
		fi
	fi
fi

cleanExit () {
	local exitCode=$1

	if [ -n "$Self_Instance_Dir" ]; then
		rm -rf "$Self_Instance_Dir"
	fi

	exit $exitCode
}

cleanAbort () {
	echo
	echo "$Self_Name: aborting." 1>&2
	kill $( jobs -p ) 1>/dev/null 2>&1
	cleanExit $Ex_Interrupt
}

printUsage () {
  echo "$Self_Name ${Self_Version}: transcode album(s), compute ReplayGain and touch files
Copyright © 2012 - 2025 Guillaume Cocatre-Zilgien
https://github.com/gcocatre/caudec

Usage: $Self_Name [ PARAMS ] [ CAUDEC PARAMS ] DIR(S)
Mass transcode albums using caudec, while optionally computing ReplayGain,
and touching the resulting directories to reflect their date of release, and
track durations. A single directory, or multiple directories, must be passed as
arguments. Run 'caudec -h' to learn about CAUDEC PARAMS.

-------------------------------------------------------------------------------

Global parameters:

  -h        display this help and exit
  -V        output version information and exit

-------------------------------------------------------------------------------

Disable additional actions:

  -R        do not compute ReplayGain to lossless targets (useful if you know
            that your lossless source already has ReplayGain data)
  -M        do not touch target files and directories modification times

-------------------------------------------------------------------------------

For more help, see the online documentation:
https://github.com/gcocatre/caudec"
}

debug () {
	local str="$1"
	echo -e "${Clr_Wg}>>> DEBUG:${Clr_Rst} $str" 1>&2
}

outputWarningOrError () {
  local fileName="$( basename "$path" )"

  if [ ! -f "$fileName" ]; then
    fileName="$path"
  fi

  # processId|status|context|data|message|path
	case "$status" in
		error)
			if [ "$context" = 'decoding' ]; then
				str="$( printf "${Clr_B_Bk} * ${Clr_Ko}DC ${Clr_N_Cy}%s${Clr_Rst}\n" "$fileName" )"
			elif [ "$context" = 'processing' ]; then
				str="$( printf "${Clr_B_Bk} * ${Clr_Ko}PR ${Clr_N_Cy}%s${Clr_Rst}\n" "$fileName" )"
			elif [ -n "$path" ]; then
				if [ -n "$message" ]; then
					str="$( printf "${Clr_B_Bk} * ${Clr_Ko}ER ${Clr_N_Cy}%s${Clr_Rst}: %s\n" "$fileName" "$message" )"
				else
					str="$( printf "${Clr_B_Bk} * ${Clr_Ko}ER ${Clr_N_Cy}%s${Clr_Rst}\n" "$fileName" )"
				fi
			elif [ -n "$message" ]; then
				str="$( printf "${Clr_B_Bk} * ${Clr_Ko}ER ${Clr_Rst}%s\n" "$message" )"
			fi
      echo -e "$str" 1>&2
			;;

		warning)
			if [ -n "$path" ]; then
				str="$( printf "${Clr_B_Bk} * ${Clr_Wg}WG ${Clr_N_Cy}%s${Clr_Rst}: %s\n" "$fileName" "$message" )"
			else
				str="$( printf "${Clr_B_Bk} * ${Clr_Wg}WG ${Clr_Rst}%s\n" "$message" )"
			fi
      echo -e "$str" 1>&2
			;;
	esac
}

maxProcesses=''
if which 'nproc' 1>/dev/null 2>&1; then # GNU Coreutils installed
	maxProcesses="$( nproc 2>/dev/null )"
elif which 'gnproc' 1>/dev/null 2>&1; then # GNU Coreutils installed on macOS
	maxProcesses="$( gnproc 2>/dev/null )"
elif [ -e '/proc/cpuinfo' ]; then # Linux
	maxProcesses="$( grep -cF 'cpu MHz' /proc/cpuinfo 2>/dev/null )"
elif [ "$OS" = 'Darwin' ]; then # macOS
	# Many thanks to Tobias Link for helping me port caudec to macOS
	maxProcesses="$( system_profiler -detailLevel full SPHardwareDataType 2>/dev/null | grep -F 'Total Number of Cores:' 2>/dev/null | cut -d ':' -f 2 2>/dev/null | tr -d ' ' | cut -d '(' -f 1 2>/dev/null )"
fi

nProcesses=1
case "$maxProcesses" in
	[1-9]*) nProcesses=$maxProcesses ;;
esac

for arg in "$@"; do
  case "$arg" in
    '-h') printUsage ; cleanExit $Ex_Ok ;;
    '-M') transcaudeTouchFiles='false' ; shift 1 ;;
    '-R') computeLosslessReplayGain='false' ; shift 1 ;;
    '-V') echo "$Self_Name $Self_Version" ; cleanExit $Ex_Ok ;;
    -[1-9]|-[1-9][0-9]) echo "$Self_Name: error: don't specify a number of processes to use." 1>&2; cleanExit $Ex_Usage ;;
    '-s'|'-z'|'-Z') echo "$Self_Name: error: don't specify -s, -z or -Z." 1>&2; cleanExit $Ex_Usage ;;
  esac
done

if [ $# -eq 0 ]; then
  printUsage
  cleanExit $Ex_Usage
fi

for signal in INT TERM ABRT PIPE; do
	trap "cleanAbort" $signal
done

isProcessRunning () {
	if ps "$1" 1>/dev/null 2>&1 ; then
		return $Ex_Ok
	else
		return $Ex_Ko
	fi
}

getNumberOfMasscaudeInstances () {
	local numberOfInstances

	numberOfInstances=$( ls -1d "${Self_Tmp_Dir}/${Self_Name}".* 2>/dev/null | wc -l | tr -cd '[:digit:]' )
	case "$numberOfInstances" in
		[0-9]*) echo $numberOfInstances ;;
		*) echo 1 ;;
	esac
}

cleanUpInstances () {
	local pid tdir lockFile

	for tempDir in "$TMPDIR" '/tmp'; do
		if [ -n "$tempDir" -a -d "$tempDir" ]; then
			for instanceDir in "$tempDir"/"$Self_Name".*; do
				if [ ! -d "$instanceDir" ]; then continue; fi
				if [ -f "${instanceDir}/pid.txt" ]; then
					read pid < "${instanceDir}/pid.txt"
					if ! isProcessRunning "$pid"; then
						rm -rf "$instanceDir"
					fi
				fi
			done
		fi
	done
}

handleInstance () {
  local mktempDir

  cleanUpInstances

  if [ -n "$TMPDIR" ]; then mktempDir="$TMPDIR"; else mktempDir='/tmp'; fi

	if [ ! -d "$mktempDir" ]; then
    echo "${Self_Name}: error: couldn't create directory \"${mktempDir}\"." 1>&2
		cleanExit $Ex_Cant_Create
	elif [ ! -w "$mktempDir" ]; then
    echo "${Self_Name}: error: \"${mktempDir}\" is not writable (permission denied)." 1>&2
		cleanExit $Ex_No_Perm
	fi
	Self_Tmp_Dir="$mktempDir"

	Self_Instance_Dir="$( mktemp -d -p "$Self_Tmp_Dir" "${Self_Name}.XXXXXXXX" 2>/dev/null )"
	if [ -z "$Self_Instance_Dir" ]; then
    echo "${Self_Name}: error: mktemp failed to create \"${mktempDir}\" (do you have write permissions?)." 1>&2
		cleanExit $Ex_Os_Err
	elif [ ! -w "$Self_Instance_Dir" ]; then
    echo "${Self_Name}: error: \"${mktempDir}\" is not writable (permission denied)." 1>&2
		cleanExit $Ex_No_Perm
	fi
	chmod "$Self_Permissions" "$Self_Instance_Dir"

	Self_Pid_File="${Self_Instance_Dir}/pid.txt"
	echo "$$" > "${Self_Pid_File}" 2>&1 || cleanExit $Ex_Temp_Fail

	nRunningInstances="$( getNumberOfMasscaudeInstances )"
	if [ $nRunningInstances -gt 1 ]; then
    echo "${Self_Name}: error: only one instance of ${Self_Name} can be run at any one time (another instance is running)." 1>&2
		cleanExit $Ex_Temp_Fail
	fi

  for inputDir in "${inputDirs[@]}"; do
    if [ -d "$inputDir" ]; then
      echo "${Self_Name}: error: \"${inputDir}\" is not a directory. Ignoring." 1>&2
    else
      ls -ld "$inputDir"
    fi
  done
}

findAudioDirectories () {
	local arg="$1"

	if [ "$gnufind" = 'true' ]; then
		$findcmd "$arg" -type f -regextype 'posix-egrep' -regex '.*\.(wav|aiff|caf|flac|wv|ape|mp3|m4a|ogg|opus)$' 2>/dev/null | sed -e 's@/[^/]*\.*$@@' -e 's@^\./@@' | sort -u
	else
		$findcmd -E "$arg" -type f -regex '.*\.(wav|aiff|caf|flac|wv|ape|mp3|m4a|ogg|opus)$' 2>/dev/null | sed -e 's@/[^/]*\.*$@@' -e 's@^\./@@' | sort -u
	fi
}

masscode () {
  local returnCode=$Ex_Ok audioDirIndex audioDirectory

    # ls "${directoryArguments[@]}"
  caudec "${caudecParams[@]}" "${directoryArguments[@]}" || returnCode=$Ex_Ko
  # if [ $returnCode -eq $Ex_Ok ]; then
  #   for (( audioDirIndex=$lastAudioDirIndex; audioDirIndex > -1; audioDirIndex-- )); do
  #     audioDirectory="${directoryArguments[$audioDirIndex]}"
  #     while read audioDirectory; do
  #       caudec -g "$audioDirectory"; returnCode=$?
  #       if [ $returnCode -eq $Ex_Ok ]; then
  #         caudec -T "$audioDirectory"; returnCode=$?
  #       fi
  #       # if [ $returnCode -ne $Ex_Ok ]; then
  #       #   echo "$Self_Name: an error occurred while transcoding \"${audioDirectory}\"" 1>&2
  #       # fi
  #     done < <( findAudioDirectories "$audioDirectory" 2>/dev/null )
  #   done
  # fi

  return $returnCode
}

handleInstance

declare -a arguments=("$@")
numberOfArguments=${#arguments[@]}
lastArgIndex=$(( numberOfArguments - 1 ))
declare -a directoryArguments
numberOfDirectyArguments=0
gotOutputDirectory='false'

# list target directories
for (( argIndex=lastArgIndex; argIndex > -1; argIndex-- )); do
  arg="${arguments[$argIndex]}"
  if [ $argIndex = 2 -a $numberOfDirectyArguments -eq 0 ]; then
    echo "$Self_Name: error: at least one directory containing audio files must be provided" 1>&2
    cleanExit $Ex_Usage
  else
    argMinusOneIndex=$(( argIndex - 1 ))
    argMinusOne="${arguments[$argMinusOneIndex]}"
    argMinusTwoIndex=$(( argIndex - 2 ))
    argMinusTwo="${arguments[$argMinusTwoIndex]}"
    if [ -d "$arg" ]; then
      if [ "$argMinusOne" = '-o' -o "$argMinusOne" = '-O' -o "$argMinusOne" = '-P' ]; then
        gotOutputDirectory='true'
        break
      elif [ "$argMinusOne" = '-l' -o "$argMinusOne" = '-L' ]; then
        break
      else
        if [ "$arg" = "$PWD" ]; then
          echo "$Self_Name: error: the current path (\$PWD) is not allowed as a source directory" 1>&2
          cleanExit $Ex_Usage
        fi
        case "$arg" in
          .*|./*|../*)
            echo "$Self_Name: error: relative paths are not allowed as source directories" 1>&2
            cleanExit $Ex_Usage
           ;;
          *) directoryArguments[$numberOfDirectyArguments]="$arg" ; (( numberOfDirectyArguments++ )) ;;
        esac
      fi
    else
      break
    fi
  fi
done

if [ $numberOfDirectyArguments -eq 0 ]; then
  echo "$Self_Name: error: at least one directory containing audio files must be provided" 1>&2
  cleanExit $Ex_Usage
fi
lastAudioDirIndex=$(( numberOfDirectyArguments - 1 ))

# list caudec parameters and arguments
declare -a caudecParams=()
numberOfCaudecParams=0
for (( argIndex=0; argIndex < numberOfArguments; argIndex++ )); do
  arg="${arguments[$argIndex]}"
  if [ "$arg" = "${directoryArguments[$lastAudioDirIndex]}" ]; then break; fi
  if [ "$arg" = '-o' -o "$arg" = '-O' -o "$arg" = '-P' -o "$arg" = '-l' -o "$arg" = '-L' ]; then
      argPlusOneIndex=$(( argIndex + 1 ))
      if [ $argPlusOneIndex -ge $numberOfArguments ]; then
        echo "$Self_Name ${arg}: error: no directory provided" 1>&2
        cleanExit $Ex_Usage
      else
        argPlusOne="${arguments[$argPlusOneIndex]}"
        if [ "$arg" = '-o' -o "$arg" = '-l' ]; then
          if [ ! -d "$argPlusOne" ]; then
            echo "$Self_Name ${arg}: error: no such directory \"${argPlusOne}\"" 1>&2
            cleanExit $Ex_Cant_Create
          elif [ ! -w "$argPlusOne" ]; then
            echo "$Self_Name ${arg}: error: output directory \"${argPlusOne}\" is not writable" 1>&2
            cleanExit $Ex_No_Perm
          fi
        fi
      fi
      if [ "$arg" = '-o' -o "$arg" = '-O' -o "$arg" = '-P' ]; then
        gotOutputDirectory='true'
      fi
  fi
  caudecParams[$numberOfCaudecParams]="$arg"
  (( numberOfCaudecParams++ ))
done

masscode

# for (( processNumber=0; processNumber < nProcesses; processNumber++ )); do
#   masscode &
# done
# for jobIndex in $( jobs -p ); do wait $jobIndex || exitCode=$Ex_Ko ; done

cleanExit $Ex_Ok
